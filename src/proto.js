/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.api = (function() {

    /**
     * Namespace api.
     * @exports api
     * @namespace
     */
    var api = {};

    api.Cipher = (function() {

        /**
         * Properties of a Cipher.
         * @memberof api
         * @interface ICipher
         * @property {Uint8Array|null} [nonce] Cipher nonce
         * @property {Uint8Array|null} [message] Cipher message
         * @property {api.IIdentityKeyID|null} [sign] Cipher sign
         */

        /**
         * Constructs a new Cipher.
         * @memberof api
         * @classdesc Represents a Cipher.
         * @implements ICipher
         * @constructor
         * @param {api.ICipher=} [properties] Properties to set
         */
        function Cipher(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Cipher nonce.
         * @member {Uint8Array} nonce
         * @memberof api.Cipher
         * @instance
         */
        Cipher.prototype.nonce = $util.newBuffer([]);

        /**
         * Cipher message.
         * @member {Uint8Array} message
         * @memberof api.Cipher
         * @instance
         */
        Cipher.prototype.message = $util.newBuffer([]);

        /**
         * Cipher sign.
         * @member {api.IIdentityKeyID|null|undefined} sign
         * @memberof api.Cipher
         * @instance
         */
        Cipher.prototype.sign = null;

        /**
         * Creates a new Cipher instance using the specified properties.
         * @function create
         * @memberof api.Cipher
         * @static
         * @param {api.ICipher=} [properties] Properties to set
         * @returns {api.Cipher} Cipher instance
         */
        Cipher.create = function create(properties) {
            return new Cipher(properties);
        };

        /**
         * Encodes the specified Cipher message. Does not implicitly {@link api.Cipher.verify|verify} messages.
         * @function encode
         * @memberof api.Cipher
         * @static
         * @param {api.ICipher} message Cipher message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Cipher.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.nonce);
            if (message.message != null && message.hasOwnProperty("message"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.message);
            if (message.sign != null && message.hasOwnProperty("sign"))
                $root.api.IdentityKeyID.encode(message.sign, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Cipher message, length delimited. Does not implicitly {@link api.Cipher.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.Cipher
         * @static
         * @param {api.ICipher} message Cipher message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Cipher.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Cipher message from the specified reader or buffer.
         * @function decode
         * @memberof api.Cipher
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.Cipher} Cipher
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Cipher.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Cipher();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nonce = reader.bytes();
                    break;
                case 2:
                    message.message = reader.bytes();
                    break;
                case 3:
                    message.sign = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Cipher message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.Cipher
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.Cipher} Cipher
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Cipher.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Cipher message.
         * @function verify
         * @memberof api.Cipher
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Cipher.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                    return "nonce: buffer expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!(message.message && typeof message.message.length === "number" || $util.isString(message.message)))
                    return "message: buffer expected";
            if (message.sign != null && message.hasOwnProperty("sign")) {
                var error = $root.api.IdentityKeyID.verify(message.sign);
                if (error)
                    return "sign." + error;
            }
            return null;
        };

        /**
         * Creates a Cipher message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.Cipher
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.Cipher} Cipher
         */
        Cipher.fromObject = function fromObject(object) {
            if (object instanceof $root.api.Cipher)
                return object;
            var message = new $root.api.Cipher();
            if (object.nonce != null)
                if (typeof object.nonce === "string")
                    $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                else if (object.nonce.length)
                    message.nonce = object.nonce;
            if (object.message != null)
                if (typeof object.message === "string")
                    $util.base64.decode(object.message, message.message = $util.newBuffer($util.base64.length(object.message)), 0);
                else if (object.message.length)
                    message.message = object.message;
            if (object.sign != null) {
                if (typeof object.sign !== "object")
                    throw TypeError(".api.Cipher.sign: object expected");
                message.sign = $root.api.IdentityKeyID.fromObject(object.sign);
            }
            return message;
        };

        /**
         * Creates a plain object from a Cipher message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.Cipher
         * @static
         * @param {api.Cipher} message Cipher
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Cipher.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.nonce = "";
                else {
                    object.nonce = [];
                    if (options.bytes !== Array)
                        object.nonce = $util.newBuffer(object.nonce);
                }
                if (options.bytes === String)
                    object.message = "";
                else {
                    object.message = [];
                    if (options.bytes !== Array)
                        object.message = $util.newBuffer(object.message);
                }
                object.sign = null;
            }
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = options.bytes === String ? $util.base64.encode(message.message, 0, message.message.length) : options.bytes === Array ? Array.prototype.slice.call(message.message) : message.message;
            if (message.sign != null && message.hasOwnProperty("sign"))
                object.sign = $root.api.IdentityKeyID.toObject(message.sign, options);
            return object;
        };

        /**
         * Converts this Cipher to JSON.
         * @function toJSON
         * @memberof api.Cipher
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Cipher.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Cipher;
    })();

    api.IdentityFields = (function() {

        /**
         * Properties of an IdentityFields.
         * @memberof api
         * @interface IIdentityFields
         * @property {string|null} [login] IdentityFields login
         * @property {string|null} [name] IdentityFields name
         * @property {string|null} [kind] IdentityFields kind
         * @property {Uint8Array|null} [payload] IdentityFields payload
         */

        /**
         * Constructs a new IdentityFields.
         * @memberof api
         * @classdesc Represents an IdentityFields.
         * @implements IIdentityFields
         * @constructor
         * @param {api.IIdentityFields=} [properties] Properties to set
         */
        function IdentityFields(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityFields login.
         * @member {string} login
         * @memberof api.IdentityFields
         * @instance
         */
        IdentityFields.prototype.login = "";

        /**
         * IdentityFields name.
         * @member {string} name
         * @memberof api.IdentityFields
         * @instance
         */
        IdentityFields.prototype.name = "";

        /**
         * IdentityFields kind.
         * @member {string} kind
         * @memberof api.IdentityFields
         * @instance
         */
        IdentityFields.prototype.kind = "";

        /**
         * IdentityFields payload.
         * @member {Uint8Array} payload
         * @memberof api.IdentityFields
         * @instance
         */
        IdentityFields.prototype.payload = $util.newBuffer([]);

        /**
         * Creates a new IdentityFields instance using the specified properties.
         * @function create
         * @memberof api.IdentityFields
         * @static
         * @param {api.IIdentityFields=} [properties] Properties to set
         * @returns {api.IdentityFields} IdentityFields instance
         */
        IdentityFields.create = function create(properties) {
            return new IdentityFields(properties);
        };

        /**
         * Encodes the specified IdentityFields message. Does not implicitly {@link api.IdentityFields.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityFields
         * @static
         * @param {api.IIdentityFields} message IdentityFields message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityFields.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.kind != null && message.hasOwnProperty("kind"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.kind);
            if (message.payload != null && message.hasOwnProperty("payload"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.payload);
            return writer;
        };

        /**
         * Encodes the specified IdentityFields message, length delimited. Does not implicitly {@link api.IdentityFields.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityFields
         * @static
         * @param {api.IIdentityFields} message IdentityFields message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityFields.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityFields message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityFields
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityFields} IdentityFields
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityFields.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityFields();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.kind = reader.string();
                    break;
                case 4:
                    message.payload = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityFields message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityFields
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityFields} IdentityFields
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityFields.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityFields message.
         * @function verify
         * @memberof api.IdentityFields
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityFields.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.kind != null && message.hasOwnProperty("kind"))
                if (!$util.isString(message.kind))
                    return "kind: string expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            return null;
        };

        /**
         * Creates an IdentityFields message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityFields
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityFields} IdentityFields
         */
        IdentityFields.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityFields)
                return object;
            var message = new $root.api.IdentityFields();
            if (object.login != null)
                message.login = String(object.login);
            if (object.name != null)
                message.name = String(object.name);
            if (object.kind != null)
                message.kind = String(object.kind);
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            return message;
        };

        /**
         * Creates a plain object from an IdentityFields message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityFields
         * @static
         * @param {api.IdentityFields} message IdentityFields
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityFields.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.name = "";
                object.kind = "";
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.kind != null && message.hasOwnProperty("kind"))
                object.kind = message.kind;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            return object;
        };

        /**
         * Converts this IdentityFields to JSON.
         * @function toJSON
         * @memberof api.IdentityFields
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityFields.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityFields;
    })();

    api.Identity = (function() {

        /**
         * Properties of an Identity.
         * @memberof api
         * @interface IIdentity
         * @property {string|null} [login] Identity login
         * @property {string|null} [name] Identity name
         * @property {string|null} [kind] Identity kind
         * @property {number|Long|null} [created] Identity created
         * @property {boolean|null} [admin] Identity admin
         * @property {boolean|null} [active] Identity active
         * @property {Uint8Array|null} [payload] Identity payload
         */

        /**
         * Constructs a new Identity.
         * @memberof api
         * @classdesc Represents an Identity.
         * @implements IIdentity
         * @constructor
         * @param {api.IIdentity=} [properties] Properties to set
         */
        function Identity(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Identity login.
         * @member {string} login
         * @memberof api.Identity
         * @instance
         */
        Identity.prototype.login = "";

        /**
         * Identity name.
         * @member {string} name
         * @memberof api.Identity
         * @instance
         */
        Identity.prototype.name = "";

        /**
         * Identity kind.
         * @member {string} kind
         * @memberof api.Identity
         * @instance
         */
        Identity.prototype.kind = "";

        /**
         * Identity created.
         * @member {number|Long} created
         * @memberof api.Identity
         * @instance
         */
        Identity.prototype.created = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Identity admin.
         * @member {boolean} admin
         * @memberof api.Identity
         * @instance
         */
        Identity.prototype.admin = false;

        /**
         * Identity active.
         * @member {boolean} active
         * @memberof api.Identity
         * @instance
         */
        Identity.prototype.active = false;

        /**
         * Identity payload.
         * @member {Uint8Array} payload
         * @memberof api.Identity
         * @instance
         */
        Identity.prototype.payload = $util.newBuffer([]);

        /**
         * Creates a new Identity instance using the specified properties.
         * @function create
         * @memberof api.Identity
         * @static
         * @param {api.IIdentity=} [properties] Properties to set
         * @returns {api.Identity} Identity instance
         */
        Identity.create = function create(properties) {
            return new Identity(properties);
        };

        /**
         * Encodes the specified Identity message. Does not implicitly {@link api.Identity.verify|verify} messages.
         * @function encode
         * @memberof api.Identity
         * @static
         * @param {api.IIdentity} message Identity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Identity.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.kind != null && message.hasOwnProperty("kind"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.kind);
            if (message.created != null && message.hasOwnProperty("created"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.created);
            if (message.admin != null && message.hasOwnProperty("admin"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.admin);
            if (message.active != null && message.hasOwnProperty("active"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.active);
            if (message.payload != null && message.hasOwnProperty("payload"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.payload);
            return writer;
        };

        /**
         * Encodes the specified Identity message, length delimited. Does not implicitly {@link api.Identity.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.Identity
         * @static
         * @param {api.IIdentity} message Identity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Identity.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Identity message from the specified reader or buffer.
         * @function decode
         * @memberof api.Identity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.Identity} Identity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Identity.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Identity();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.kind = reader.string();
                    break;
                case 4:
                    message.created = reader.int64();
                    break;
                case 5:
                    message.admin = reader.bool();
                    break;
                case 6:
                    message.active = reader.bool();
                    break;
                case 7:
                    message.payload = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Identity message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.Identity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.Identity} Identity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Identity.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Identity message.
         * @function verify
         * @memberof api.Identity
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Identity.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.kind != null && message.hasOwnProperty("kind"))
                if (!$util.isString(message.kind))
                    return "kind: string expected";
            if (message.created != null && message.hasOwnProperty("created"))
                if (!$util.isInteger(message.created) && !(message.created && $util.isInteger(message.created.low) && $util.isInteger(message.created.high)))
                    return "created: integer|Long expected";
            if (message.admin != null && message.hasOwnProperty("admin"))
                if (typeof message.admin !== "boolean")
                    return "admin: boolean expected";
            if (message.active != null && message.hasOwnProperty("active"))
                if (typeof message.active !== "boolean")
                    return "active: boolean expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            return null;
        };

        /**
         * Creates an Identity message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.Identity
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.Identity} Identity
         */
        Identity.fromObject = function fromObject(object) {
            if (object instanceof $root.api.Identity)
                return object;
            var message = new $root.api.Identity();
            if (object.login != null)
                message.login = String(object.login);
            if (object.name != null)
                message.name = String(object.name);
            if (object.kind != null)
                message.kind = String(object.kind);
            if (object.created != null)
                if ($util.Long)
                    (message.created = $util.Long.fromValue(object.created)).unsigned = false;
                else if (typeof object.created === "string")
                    message.created = parseInt(object.created, 10);
                else if (typeof object.created === "number")
                    message.created = object.created;
                else if (typeof object.created === "object")
                    message.created = new $util.LongBits(object.created.low >>> 0, object.created.high >>> 0).toNumber();
            if (object.admin != null)
                message.admin = Boolean(object.admin);
            if (object.active != null)
                message.active = Boolean(object.active);
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            return message;
        };

        /**
         * Creates a plain object from an Identity message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.Identity
         * @static
         * @param {api.Identity} message Identity
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Identity.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.name = "";
                object.kind = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.created = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.created = options.longs === String ? "0" : 0;
                object.admin = false;
                object.active = false;
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.kind != null && message.hasOwnProperty("kind"))
                object.kind = message.kind;
            if (message.created != null && message.hasOwnProperty("created"))
                if (typeof message.created === "number")
                    object.created = options.longs === String ? String(message.created) : message.created;
                else
                    object.created = options.longs === String ? $util.Long.prototype.toString.call(message.created) : options.longs === Number ? new $util.LongBits(message.created.low >>> 0, message.created.high >>> 0).toNumber() : message.created;
            if (message.admin != null && message.hasOwnProperty("admin"))
                object.admin = message.admin;
            if (message.active != null && message.hasOwnProperty("active"))
                object.active = message.active;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            return object;
        };

        /**
         * Converts this Identity to JSON.
         * @function toJSON
         * @memberof api.Identity
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Identity.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Identity;
    })();

    api.IdentityKeyID = (function() {

        /**
         * Properties of an IdentityKeyID.
         * @memberof api
         * @interface IIdentityKeyID
         * @property {string|null} [login] IdentityKeyID login
         * @property {number|null} [version] IdentityKeyID version
         */

        /**
         * Constructs a new IdentityKeyID.
         * @memberof api
         * @classdesc Represents an IdentityKeyID.
         * @implements IIdentityKeyID
         * @constructor
         * @param {api.IIdentityKeyID=} [properties] Properties to set
         */
        function IdentityKeyID(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityKeyID login.
         * @member {string} login
         * @memberof api.IdentityKeyID
         * @instance
         */
        IdentityKeyID.prototype.login = "";

        /**
         * IdentityKeyID version.
         * @member {number} version
         * @memberof api.IdentityKeyID
         * @instance
         */
        IdentityKeyID.prototype.version = 0;

        /**
         * Creates a new IdentityKeyID instance using the specified properties.
         * @function create
         * @memberof api.IdentityKeyID
         * @static
         * @param {api.IIdentityKeyID=} [properties] Properties to set
         * @returns {api.IdentityKeyID} IdentityKeyID instance
         */
        IdentityKeyID.create = function create(properties) {
            return new IdentityKeyID(properties);
        };

        /**
         * Encodes the specified IdentityKeyID message. Does not implicitly {@link api.IdentityKeyID.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityKeyID
         * @static
         * @param {api.IIdentityKeyID} message IdentityKeyID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityKeyID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            return writer;
        };

        /**
         * Encodes the specified IdentityKeyID message, length delimited. Does not implicitly {@link api.IdentityKeyID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityKeyID
         * @static
         * @param {api.IIdentityKeyID} message IdentityKeyID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityKeyID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityKeyID message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityKeyID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityKeyID} IdentityKeyID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityKeyID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityKeyID();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityKeyID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityKeyID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityKeyID} IdentityKeyID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityKeyID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityKeyID message.
         * @function verify
         * @memberof api.IdentityKeyID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityKeyID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            return null;
        };

        /**
         * Creates an IdentityKeyID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityKeyID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityKeyID} IdentityKeyID
         */
        IdentityKeyID.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityKeyID)
                return object;
            var message = new $root.api.IdentityKeyID();
            if (object.login != null)
                message.login = String(object.login);
            if (object.version != null)
                message.version = object.version >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an IdentityKeyID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityKeyID
         * @static
         * @param {api.IdentityKeyID} message IdentityKeyID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityKeyID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.version = 0;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            return object;
        };

        /**
         * Converts this IdentityKeyID to JSON.
         * @function toJSON
         * @memberof api.IdentityKeyID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityKeyID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityKeyID;
    })();

    api.IdentityPublicKey = (function() {

        /**
         * Properties of an IdentityPublicKey.
         * @memberof api
         * @interface IIdentityPublicKey
         * @property {Uint8Array|null} [sign] IdentityPublicKey sign
         * @property {Uint8Array|null} [box] IdentityPublicKey box
         * @property {string|null} [login] IdentityPublicKey login
         * @property {number|null} [version] IdentityPublicKey version
         */

        /**
         * Constructs a new IdentityPublicKey.
         * @memberof api
         * @classdesc Represents an IdentityPublicKey.
         * @implements IIdentityPublicKey
         * @constructor
         * @param {api.IIdentityPublicKey=} [properties] Properties to set
         */
        function IdentityPublicKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityPublicKey sign.
         * @member {Uint8Array} sign
         * @memberof api.IdentityPublicKey
         * @instance
         */
        IdentityPublicKey.prototype.sign = $util.newBuffer([]);

        /**
         * IdentityPublicKey box.
         * @member {Uint8Array} box
         * @memberof api.IdentityPublicKey
         * @instance
         */
        IdentityPublicKey.prototype.box = $util.newBuffer([]);

        /**
         * IdentityPublicKey login.
         * @member {string} login
         * @memberof api.IdentityPublicKey
         * @instance
         */
        IdentityPublicKey.prototype.login = "";

        /**
         * IdentityPublicKey version.
         * @member {number} version
         * @memberof api.IdentityPublicKey
         * @instance
         */
        IdentityPublicKey.prototype.version = 0;

        /**
         * Creates a new IdentityPublicKey instance using the specified properties.
         * @function create
         * @memberof api.IdentityPublicKey
         * @static
         * @param {api.IIdentityPublicKey=} [properties] Properties to set
         * @returns {api.IdentityPublicKey} IdentityPublicKey instance
         */
        IdentityPublicKey.create = function create(properties) {
            return new IdentityPublicKey(properties);
        };

        /**
         * Encodes the specified IdentityPublicKey message. Does not implicitly {@link api.IdentityPublicKey.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityPublicKey
         * @static
         * @param {api.IIdentityPublicKey} message IdentityPublicKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPublicKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sign != null && message.hasOwnProperty("sign"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.sign);
            if (message.box != null && message.hasOwnProperty("box"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.box);
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.login);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.version);
            return writer;
        };

        /**
         * Encodes the specified IdentityPublicKey message, length delimited. Does not implicitly {@link api.IdentityPublicKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityPublicKey
         * @static
         * @param {api.IIdentityPublicKey} message IdentityPublicKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPublicKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityPublicKey message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityPublicKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityPublicKey} IdentityPublicKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPublicKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityPublicKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sign = reader.bytes();
                    break;
                case 2:
                    message.box = reader.bytes();
                    break;
                case 3:
                    message.login = reader.string();
                    break;
                case 4:
                    message.version = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityPublicKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityPublicKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityPublicKey} IdentityPublicKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPublicKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityPublicKey message.
         * @function verify
         * @memberof api.IdentityPublicKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityPublicKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sign != null && message.hasOwnProperty("sign"))
                if (!(message.sign && typeof message.sign.length === "number" || $util.isString(message.sign)))
                    return "sign: buffer expected";
            if (message.box != null && message.hasOwnProperty("box"))
                if (!(message.box && typeof message.box.length === "number" || $util.isString(message.box)))
                    return "box: buffer expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            return null;
        };

        /**
         * Creates an IdentityPublicKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityPublicKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityPublicKey} IdentityPublicKey
         */
        IdentityPublicKey.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityPublicKey)
                return object;
            var message = new $root.api.IdentityPublicKey();
            if (object.sign != null)
                if (typeof object.sign === "string")
                    $util.base64.decode(object.sign, message.sign = $util.newBuffer($util.base64.length(object.sign)), 0);
                else if (object.sign.length)
                    message.sign = object.sign;
            if (object.box != null)
                if (typeof object.box === "string")
                    $util.base64.decode(object.box, message.box = $util.newBuffer($util.base64.length(object.box)), 0);
                else if (object.box.length)
                    message.box = object.box;
            if (object.login != null)
                message.login = String(object.login);
            if (object.version != null)
                message.version = object.version >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an IdentityPublicKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityPublicKey
         * @static
         * @param {api.IdentityPublicKey} message IdentityPublicKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityPublicKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.sign = "";
                else {
                    object.sign = [];
                    if (options.bytes !== Array)
                        object.sign = $util.newBuffer(object.sign);
                }
                if (options.bytes === String)
                    object.box = "";
                else {
                    object.box = [];
                    if (options.bytes !== Array)
                        object.box = $util.newBuffer(object.box);
                }
                object.login = "";
                object.version = 0;
            }
            if (message.sign != null && message.hasOwnProperty("sign"))
                object.sign = options.bytes === String ? $util.base64.encode(message.sign, 0, message.sign.length) : options.bytes === Array ? Array.prototype.slice.call(message.sign) : message.sign;
            if (message.box != null && message.hasOwnProperty("box"))
                object.box = options.bytes === String ? $util.base64.encode(message.box, 0, message.box.length) : options.bytes === Array ? Array.prototype.slice.call(message.box) : message.box;
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            return object;
        };

        /**
         * Converts this IdentityPublicKey to JSON.
         * @function toJSON
         * @memberof api.IdentityPublicKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityPublicKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityPublicKey;
    })();

    api.IdentityPublicKeyWithMetadata = (function() {

        /**
         * Properties of an IdentityPublicKeyWithMetadata.
         * @memberof api
         * @interface IIdentityPublicKeyWithMetadata
         * @property {api.IIdentityPublicKey|null} [publicKey] IdentityPublicKeyWithMetadata publicKey
         * @property {number|Long|null} [created] IdentityPublicKeyWithMetadata created
         */

        /**
         * Constructs a new IdentityPublicKeyWithMetadata.
         * @memberof api
         * @classdesc Represents an IdentityPublicKeyWithMetadata.
         * @implements IIdentityPublicKeyWithMetadata
         * @constructor
         * @param {api.IIdentityPublicKeyWithMetadata=} [properties] Properties to set
         */
        function IdentityPublicKeyWithMetadata(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityPublicKeyWithMetadata publicKey.
         * @member {api.IIdentityPublicKey|null|undefined} publicKey
         * @memberof api.IdentityPublicKeyWithMetadata
         * @instance
         */
        IdentityPublicKeyWithMetadata.prototype.publicKey = null;

        /**
         * IdentityPublicKeyWithMetadata created.
         * @member {number|Long} created
         * @memberof api.IdentityPublicKeyWithMetadata
         * @instance
         */
        IdentityPublicKeyWithMetadata.prototype.created = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new IdentityPublicKeyWithMetadata instance using the specified properties.
         * @function create
         * @memberof api.IdentityPublicKeyWithMetadata
         * @static
         * @param {api.IIdentityPublicKeyWithMetadata=} [properties] Properties to set
         * @returns {api.IdentityPublicKeyWithMetadata} IdentityPublicKeyWithMetadata instance
         */
        IdentityPublicKeyWithMetadata.create = function create(properties) {
            return new IdentityPublicKeyWithMetadata(properties);
        };

        /**
         * Encodes the specified IdentityPublicKeyWithMetadata message. Does not implicitly {@link api.IdentityPublicKeyWithMetadata.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityPublicKeyWithMetadata
         * @static
         * @param {api.IIdentityPublicKeyWithMetadata} message IdentityPublicKeyWithMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPublicKeyWithMetadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                $root.api.IdentityPublicKey.encode(message.publicKey, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.created != null && message.hasOwnProperty("created"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.created);
            return writer;
        };

        /**
         * Encodes the specified IdentityPublicKeyWithMetadata message, length delimited. Does not implicitly {@link api.IdentityPublicKeyWithMetadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityPublicKeyWithMetadata
         * @static
         * @param {api.IIdentityPublicKeyWithMetadata} message IdentityPublicKeyWithMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPublicKeyWithMetadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityPublicKeyWithMetadata message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityPublicKeyWithMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityPublicKeyWithMetadata} IdentityPublicKeyWithMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPublicKeyWithMetadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityPublicKeyWithMetadata();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.publicKey = $root.api.IdentityPublicKey.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.created = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityPublicKeyWithMetadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityPublicKeyWithMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityPublicKeyWithMetadata} IdentityPublicKeyWithMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPublicKeyWithMetadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityPublicKeyWithMetadata message.
         * @function verify
         * @memberof api.IdentityPublicKeyWithMetadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityPublicKeyWithMetadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey")) {
                var error = $root.api.IdentityPublicKey.verify(message.publicKey);
                if (error)
                    return "publicKey." + error;
            }
            if (message.created != null && message.hasOwnProperty("created"))
                if (!$util.isInteger(message.created) && !(message.created && $util.isInteger(message.created.low) && $util.isInteger(message.created.high)))
                    return "created: integer|Long expected";
            return null;
        };

        /**
         * Creates an IdentityPublicKeyWithMetadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityPublicKeyWithMetadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityPublicKeyWithMetadata} IdentityPublicKeyWithMetadata
         */
        IdentityPublicKeyWithMetadata.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityPublicKeyWithMetadata)
                return object;
            var message = new $root.api.IdentityPublicKeyWithMetadata();
            if (object.publicKey != null) {
                if (typeof object.publicKey !== "object")
                    throw TypeError(".api.IdentityPublicKeyWithMetadata.publicKey: object expected");
                message.publicKey = $root.api.IdentityPublicKey.fromObject(object.publicKey);
            }
            if (object.created != null)
                if ($util.Long)
                    (message.created = $util.Long.fromValue(object.created)).unsigned = false;
                else if (typeof object.created === "string")
                    message.created = parseInt(object.created, 10);
                else if (typeof object.created === "number")
                    message.created = object.created;
                else if (typeof object.created === "object")
                    message.created = new $util.LongBits(object.created.low >>> 0, object.created.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an IdentityPublicKeyWithMetadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityPublicKeyWithMetadata
         * @static
         * @param {api.IdentityPublicKeyWithMetadata} message IdentityPublicKeyWithMetadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityPublicKeyWithMetadata.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.publicKey = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.created = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.created = options.longs === String ? "0" : 0;
            }
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = $root.api.IdentityPublicKey.toObject(message.publicKey, options);
            if (message.created != null && message.hasOwnProperty("created"))
                if (typeof message.created === "number")
                    object.created = options.longs === String ? String(message.created) : message.created;
                else
                    object.created = options.longs === String ? $util.Long.prototype.toString.call(message.created) : options.longs === Number ? new $util.LongBits(message.created.low >>> 0, message.created.high >>> 0).toNumber() : message.created;
            return object;
        };

        /**
         * Converts this IdentityPublicKeyWithMetadata to JSON.
         * @function toJSON
         * @memberof api.IdentityPublicKeyWithMetadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityPublicKeyWithMetadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityPublicKeyWithMetadata;
    })();

    api.IdentityPublicChain = (function() {

        /**
         * Properties of an IdentityPublicChain.
         * @memberof api
         * @interface IIdentityPublicChain
         * @property {string|null} [login] IdentityPublicChain login
         * @property {number|null} [version] IdentityPublicChain version
         * @property {Array.<api.IdentityPublicChain.IElt>|null} [chains] IdentityPublicChain chains
         */

        /**
         * Constructs a new IdentityPublicChain.
         * @memberof api
         * @classdesc Represents an IdentityPublicChain.
         * @implements IIdentityPublicChain
         * @constructor
         * @param {api.IIdentityPublicChain=} [properties] Properties to set
         */
        function IdentityPublicChain(properties) {
            this.chains = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityPublicChain login.
         * @member {string} login
         * @memberof api.IdentityPublicChain
         * @instance
         */
        IdentityPublicChain.prototype.login = "";

        /**
         * IdentityPublicChain version.
         * @member {number} version
         * @memberof api.IdentityPublicChain
         * @instance
         */
        IdentityPublicChain.prototype.version = 0;

        /**
         * IdentityPublicChain chains.
         * @member {Array.<api.IdentityPublicChain.IElt>} chains
         * @memberof api.IdentityPublicChain
         * @instance
         */
        IdentityPublicChain.prototype.chains = $util.emptyArray;

        /**
         * Creates a new IdentityPublicChain instance using the specified properties.
         * @function create
         * @memberof api.IdentityPublicChain
         * @static
         * @param {api.IIdentityPublicChain=} [properties] Properties to set
         * @returns {api.IdentityPublicChain} IdentityPublicChain instance
         */
        IdentityPublicChain.create = function create(properties) {
            return new IdentityPublicChain(properties);
        };

        /**
         * Encodes the specified IdentityPublicChain message. Does not implicitly {@link api.IdentityPublicChain.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityPublicChain
         * @static
         * @param {api.IIdentityPublicChain} message IdentityPublicChain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPublicChain.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            if (message.chains != null && message.chains.length)
                for (var i = 0; i < message.chains.length; ++i)
                    $root.api.IdentityPublicChain.Elt.encode(message.chains[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityPublicChain message, length delimited. Does not implicitly {@link api.IdentityPublicChain.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityPublicChain
         * @static
         * @param {api.IIdentityPublicChain} message IdentityPublicChain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPublicChain.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityPublicChain message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityPublicChain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityPublicChain} IdentityPublicChain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPublicChain.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityPublicChain();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                case 3:
                    if (!(message.chains && message.chains.length))
                        message.chains = [];
                    message.chains.push($root.api.IdentityPublicChain.Elt.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityPublicChain message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityPublicChain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityPublicChain} IdentityPublicChain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPublicChain.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityPublicChain message.
         * @function verify
         * @memberof api.IdentityPublicChain
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityPublicChain.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.chains != null && message.hasOwnProperty("chains")) {
                if (!Array.isArray(message.chains))
                    return "chains: array expected";
                for (var i = 0; i < message.chains.length; ++i) {
                    var error = $root.api.IdentityPublicChain.Elt.verify(message.chains[i]);
                    if (error)
                        return "chains." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityPublicChain message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityPublicChain
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityPublicChain} IdentityPublicChain
         */
        IdentityPublicChain.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityPublicChain)
                return object;
            var message = new $root.api.IdentityPublicChain();
            if (object.login != null)
                message.login = String(object.login);
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.chains) {
                if (!Array.isArray(object.chains))
                    throw TypeError(".api.IdentityPublicChain.chains: array expected");
                message.chains = [];
                for (var i = 0; i < object.chains.length; ++i) {
                    if (typeof object.chains[i] !== "object")
                        throw TypeError(".api.IdentityPublicChain.chains: object expected");
                    message.chains[i] = $root.api.IdentityPublicChain.Elt.fromObject(object.chains[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityPublicChain message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityPublicChain
         * @static
         * @param {api.IdentityPublicChain} message IdentityPublicChain
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityPublicChain.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.chains = [];
            if (options.defaults) {
                object.login = "";
                object.version = 0;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.chains && message.chains.length) {
                object.chains = [];
                for (var j = 0; j < message.chains.length; ++j)
                    object.chains[j] = $root.api.IdentityPublicChain.Elt.toObject(message.chains[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityPublicChain to JSON.
         * @function toJSON
         * @memberof api.IdentityPublicChain
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityPublicChain.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        IdentityPublicChain.Elt = (function() {

            /**
             * Properties of an Elt.
             * @memberof api.IdentityPublicChain
             * @interface IElt
             * @property {Uint8Array|null} [sign] Elt sign
             * @property {Uint8Array|null} [box] Elt box
             * @property {Uint8Array|null} [chain] Elt chain
             * @property {api.IIdentityKeyID|null} [mandate] Elt mandate
             * @property {number|null} [version] Elt version
             */

            /**
             * Constructs a new Elt.
             * @memberof api.IdentityPublicChain
             * @classdesc Represents an Elt.
             * @implements IElt
             * @constructor
             * @param {api.IdentityPublicChain.IElt=} [properties] Properties to set
             */
            function Elt(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Elt sign.
             * @member {Uint8Array} sign
             * @memberof api.IdentityPublicChain.Elt
             * @instance
             */
            Elt.prototype.sign = $util.newBuffer([]);

            /**
             * Elt box.
             * @member {Uint8Array} box
             * @memberof api.IdentityPublicChain.Elt
             * @instance
             */
            Elt.prototype.box = $util.newBuffer([]);

            /**
             * Elt chain.
             * @member {Uint8Array} chain
             * @memberof api.IdentityPublicChain.Elt
             * @instance
             */
            Elt.prototype.chain = $util.newBuffer([]);

            /**
             * Elt mandate.
             * @member {api.IIdentityKeyID|null|undefined} mandate
             * @memberof api.IdentityPublicChain.Elt
             * @instance
             */
            Elt.prototype.mandate = null;

            /**
             * Elt version.
             * @member {number} version
             * @memberof api.IdentityPublicChain.Elt
             * @instance
             */
            Elt.prototype.version = 0;

            /**
             * Creates a new Elt instance using the specified properties.
             * @function create
             * @memberof api.IdentityPublicChain.Elt
             * @static
             * @param {api.IdentityPublicChain.IElt=} [properties] Properties to set
             * @returns {api.IdentityPublicChain.Elt} Elt instance
             */
            Elt.create = function create(properties) {
                return new Elt(properties);
            };

            /**
             * Encodes the specified Elt message. Does not implicitly {@link api.IdentityPublicChain.Elt.verify|verify} messages.
             * @function encode
             * @memberof api.IdentityPublicChain.Elt
             * @static
             * @param {api.IdentityPublicChain.IElt} message Elt message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Elt.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sign != null && message.hasOwnProperty("sign"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.sign);
                if (message.box != null && message.hasOwnProperty("box"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.box);
                if (message.chain != null && message.hasOwnProperty("chain"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.chain);
                if (message.mandate != null && message.hasOwnProperty("mandate"))
                    $root.api.IdentityKeyID.encode(message.mandate, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.version != null && message.hasOwnProperty("version"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.version);
                return writer;
            };

            /**
             * Encodes the specified Elt message, length delimited. Does not implicitly {@link api.IdentityPublicChain.Elt.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.IdentityPublicChain.Elt
             * @static
             * @param {api.IdentityPublicChain.IElt} message Elt message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Elt.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Elt message from the specified reader or buffer.
             * @function decode
             * @memberof api.IdentityPublicChain.Elt
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.IdentityPublicChain.Elt} Elt
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Elt.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityPublicChain.Elt();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sign = reader.bytes();
                        break;
                    case 2:
                        message.box = reader.bytes();
                        break;
                    case 3:
                        message.chain = reader.bytes();
                        break;
                    case 4:
                        message.mandate = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.version = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Elt message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.IdentityPublicChain.Elt
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.IdentityPublicChain.Elt} Elt
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Elt.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Elt message.
             * @function verify
             * @memberof api.IdentityPublicChain.Elt
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Elt.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sign != null && message.hasOwnProperty("sign"))
                    if (!(message.sign && typeof message.sign.length === "number" || $util.isString(message.sign)))
                        return "sign: buffer expected";
                if (message.box != null && message.hasOwnProperty("box"))
                    if (!(message.box && typeof message.box.length === "number" || $util.isString(message.box)))
                        return "box: buffer expected";
                if (message.chain != null && message.hasOwnProperty("chain"))
                    if (!(message.chain && typeof message.chain.length === "number" || $util.isString(message.chain)))
                        return "chain: buffer expected";
                if (message.mandate != null && message.hasOwnProperty("mandate")) {
                    var error = $root.api.IdentityKeyID.verify(message.mandate);
                    if (error)
                        return "mandate." + error;
                }
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isInteger(message.version))
                        return "version: integer expected";
                return null;
            };

            /**
             * Creates an Elt message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.IdentityPublicChain.Elt
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.IdentityPublicChain.Elt} Elt
             */
            Elt.fromObject = function fromObject(object) {
                if (object instanceof $root.api.IdentityPublicChain.Elt)
                    return object;
                var message = new $root.api.IdentityPublicChain.Elt();
                if (object.sign != null)
                    if (typeof object.sign === "string")
                        $util.base64.decode(object.sign, message.sign = $util.newBuffer($util.base64.length(object.sign)), 0);
                    else if (object.sign.length)
                        message.sign = object.sign;
                if (object.box != null)
                    if (typeof object.box === "string")
                        $util.base64.decode(object.box, message.box = $util.newBuffer($util.base64.length(object.box)), 0);
                    else if (object.box.length)
                        message.box = object.box;
                if (object.chain != null)
                    if (typeof object.chain === "string")
                        $util.base64.decode(object.chain, message.chain = $util.newBuffer($util.base64.length(object.chain)), 0);
                    else if (object.chain.length)
                        message.chain = object.chain;
                if (object.mandate != null) {
                    if (typeof object.mandate !== "object")
                        throw TypeError(".api.IdentityPublicChain.Elt.mandate: object expected");
                    message.mandate = $root.api.IdentityKeyID.fromObject(object.mandate);
                }
                if (object.version != null)
                    message.version = object.version >>> 0;
                return message;
            };

            /**
             * Creates a plain object from an Elt message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.IdentityPublicChain.Elt
             * @static
             * @param {api.IdentityPublicChain.Elt} message Elt
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Elt.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.sign = "";
                    else {
                        object.sign = [];
                        if (options.bytes !== Array)
                            object.sign = $util.newBuffer(object.sign);
                    }
                    if (options.bytes === String)
                        object.box = "";
                    else {
                        object.box = [];
                        if (options.bytes !== Array)
                            object.box = $util.newBuffer(object.box);
                    }
                    if (options.bytes === String)
                        object.chain = "";
                    else {
                        object.chain = [];
                        if (options.bytes !== Array)
                            object.chain = $util.newBuffer(object.chain);
                    }
                    object.mandate = null;
                    object.version = 0;
                }
                if (message.sign != null && message.hasOwnProperty("sign"))
                    object.sign = options.bytes === String ? $util.base64.encode(message.sign, 0, message.sign.length) : options.bytes === Array ? Array.prototype.slice.call(message.sign) : message.sign;
                if (message.box != null && message.hasOwnProperty("box"))
                    object.box = options.bytes === String ? $util.base64.encode(message.box, 0, message.box.length) : options.bytes === Array ? Array.prototype.slice.call(message.box) : message.box;
                if (message.chain != null && message.hasOwnProperty("chain"))
                    object.chain = options.bytes === String ? $util.base64.encode(message.chain, 0, message.chain.length) : options.bytes === Array ? Array.prototype.slice.call(message.chain) : message.chain;
                if (message.mandate != null && message.hasOwnProperty("mandate"))
                    object.mandate = $root.api.IdentityKeyID.toObject(message.mandate, options);
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                return object;
            };

            /**
             * Converts this Elt to JSON.
             * @function toJSON
             * @memberof api.IdentityPublicChain.Elt
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Elt.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Elt;
        })();

        return IdentityPublicChain;
    })();

    api.IdentityEncryptedKey = (function() {

        /**
         * Properties of an IdentityEncryptedKey.
         * @memberof api
         * @interface IIdentityEncryptedKey
         * @property {Uint8Array|null} [nonce] IdentityEncryptedKey nonce
         * @property {Uint8Array|null} [publicKey] IdentityEncryptedKey publicKey
         * @property {Uint8Array|null} [encryptedKey] IdentityEncryptedKey encryptedKey
         */

        /**
         * Constructs a new IdentityEncryptedKey.
         * @memberof api
         * @classdesc Represents an IdentityEncryptedKey.
         * @implements IIdentityEncryptedKey
         * @constructor
         * @param {api.IIdentityEncryptedKey=} [properties] Properties to set
         */
        function IdentityEncryptedKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityEncryptedKey nonce.
         * @member {Uint8Array} nonce
         * @memberof api.IdentityEncryptedKey
         * @instance
         */
        IdentityEncryptedKey.prototype.nonce = $util.newBuffer([]);

        /**
         * IdentityEncryptedKey publicKey.
         * @member {Uint8Array} publicKey
         * @memberof api.IdentityEncryptedKey
         * @instance
         */
        IdentityEncryptedKey.prototype.publicKey = $util.newBuffer([]);

        /**
         * IdentityEncryptedKey encryptedKey.
         * @member {Uint8Array} encryptedKey
         * @memberof api.IdentityEncryptedKey
         * @instance
         */
        IdentityEncryptedKey.prototype.encryptedKey = $util.newBuffer([]);

        /**
         * Creates a new IdentityEncryptedKey instance using the specified properties.
         * @function create
         * @memberof api.IdentityEncryptedKey
         * @static
         * @param {api.IIdentityEncryptedKey=} [properties] Properties to set
         * @returns {api.IdentityEncryptedKey} IdentityEncryptedKey instance
         */
        IdentityEncryptedKey.create = function create(properties) {
            return new IdentityEncryptedKey(properties);
        };

        /**
         * Encodes the specified IdentityEncryptedKey message. Does not implicitly {@link api.IdentityEncryptedKey.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityEncryptedKey
         * @static
         * @param {api.IIdentityEncryptedKey} message IdentityEncryptedKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityEncryptedKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.nonce);
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.publicKey);
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.encryptedKey);
            return writer;
        };

        /**
         * Encodes the specified IdentityEncryptedKey message, length delimited. Does not implicitly {@link api.IdentityEncryptedKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityEncryptedKey
         * @static
         * @param {api.IIdentityEncryptedKey} message IdentityEncryptedKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityEncryptedKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityEncryptedKey message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityEncryptedKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityEncryptedKey} IdentityEncryptedKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityEncryptedKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityEncryptedKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nonce = reader.bytes();
                    break;
                case 2:
                    message.publicKey = reader.bytes();
                    break;
                case 3:
                    message.encryptedKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityEncryptedKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityEncryptedKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityEncryptedKey} IdentityEncryptedKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityEncryptedKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityEncryptedKey message.
         * @function verify
         * @memberof api.IdentityEncryptedKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityEncryptedKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                    return "nonce: buffer expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                if (!(message.encryptedKey && typeof message.encryptedKey.length === "number" || $util.isString(message.encryptedKey)))
                    return "encryptedKey: buffer expected";
            return null;
        };

        /**
         * Creates an IdentityEncryptedKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityEncryptedKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityEncryptedKey} IdentityEncryptedKey
         */
        IdentityEncryptedKey.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityEncryptedKey)
                return object;
            var message = new $root.api.IdentityEncryptedKey();
            if (object.nonce != null)
                if (typeof object.nonce === "string")
                    $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                else if (object.nonce.length)
                    message.nonce = object.nonce;
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.encryptedKey != null)
                if (typeof object.encryptedKey === "string")
                    $util.base64.decode(object.encryptedKey, message.encryptedKey = $util.newBuffer($util.base64.length(object.encryptedKey)), 0);
                else if (object.encryptedKey.length)
                    message.encryptedKey = object.encryptedKey;
            return message;
        };

        /**
         * Creates a plain object from an IdentityEncryptedKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityEncryptedKey
         * @static
         * @param {api.IdentityEncryptedKey} message IdentityEncryptedKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityEncryptedKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.nonce = "";
                else {
                    object.nonce = [];
                    if (options.bytes !== Array)
                        object.nonce = $util.newBuffer(object.nonce);
                }
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                if (options.bytes === String)
                    object.encryptedKey = "";
                else {
                    object.encryptedKey = [];
                    if (options.bytes !== Array)
                        object.encryptedKey = $util.newBuffer(object.encryptedKey);
                }
            }
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                object.encryptedKey = options.bytes === String ? $util.base64.encode(message.encryptedKey, 0, message.encryptedKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedKey) : message.encryptedKey;
            return object;
        };

        /**
         * Converts this IdentityEncryptedKey to JSON.
         * @function toJSON
         * @memberof api.IdentityEncryptedKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityEncryptedKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityEncryptedKey;
    })();

    api.IdentityEncryption = (function() {

        /**
         * Properties of an IdentityEncryption.
         * @memberof api
         * @interface IIdentityEncryption
         * @property {number|null} [version] IdentityEncryption version
         * @property {Uint8Array|null} [masterSalt] IdentityEncryption masterSalt
         * @property {Uint8Array|null} [masterPublicKey] IdentityEncryption masterPublicKey
         * @property {api.IIdentityEncryptedKey|null} [sharingEncrypted] IdentityEncryption sharingEncrypted
         * @property {api.IIdentityEncryptedKey|null} [boxEncrypted] IdentityEncryption boxEncrypted
         * @property {api.IIdentityEncryptedKey|null} [signEncrypted] IdentityEncryption signEncrypted
         * @property {api.IIdentityEncryptedKey|null} [readEncrypted] IdentityEncryption readEncrypted
         */

        /**
         * Constructs a new IdentityEncryption.
         * @memberof api
         * @classdesc Represents an IdentityEncryption.
         * @implements IIdentityEncryption
         * @constructor
         * @param {api.IIdentityEncryption=} [properties] Properties to set
         */
        function IdentityEncryption(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityEncryption version.
         * @member {number} version
         * @memberof api.IdentityEncryption
         * @instance
         */
        IdentityEncryption.prototype.version = 0;

        /**
         * IdentityEncryption masterSalt.
         * @member {Uint8Array} masterSalt
         * @memberof api.IdentityEncryption
         * @instance
         */
        IdentityEncryption.prototype.masterSalt = $util.newBuffer([]);

        /**
         * IdentityEncryption masterPublicKey.
         * @member {Uint8Array} masterPublicKey
         * @memberof api.IdentityEncryption
         * @instance
         */
        IdentityEncryption.prototype.masterPublicKey = $util.newBuffer([]);

        /**
         * IdentityEncryption sharingEncrypted.
         * @member {api.IIdentityEncryptedKey|null|undefined} sharingEncrypted
         * @memberof api.IdentityEncryption
         * @instance
         */
        IdentityEncryption.prototype.sharingEncrypted = null;

        /**
         * IdentityEncryption boxEncrypted.
         * @member {api.IIdentityEncryptedKey|null|undefined} boxEncrypted
         * @memberof api.IdentityEncryption
         * @instance
         */
        IdentityEncryption.prototype.boxEncrypted = null;

        /**
         * IdentityEncryption signEncrypted.
         * @member {api.IIdentityEncryptedKey|null|undefined} signEncrypted
         * @memberof api.IdentityEncryption
         * @instance
         */
        IdentityEncryption.prototype.signEncrypted = null;

        /**
         * IdentityEncryption readEncrypted.
         * @member {api.IIdentityEncryptedKey|null|undefined} readEncrypted
         * @memberof api.IdentityEncryption
         * @instance
         */
        IdentityEncryption.prototype.readEncrypted = null;

        /**
         * Creates a new IdentityEncryption instance using the specified properties.
         * @function create
         * @memberof api.IdentityEncryption
         * @static
         * @param {api.IIdentityEncryption=} [properties] Properties to set
         * @returns {api.IdentityEncryption} IdentityEncryption instance
         */
        IdentityEncryption.create = function create(properties) {
            return new IdentityEncryption(properties);
        };

        /**
         * Encodes the specified IdentityEncryption message. Does not implicitly {@link api.IdentityEncryption.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityEncryption
         * @static
         * @param {api.IIdentityEncryption} message IdentityEncryption message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityEncryption.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.version);
            if (message.masterSalt != null && message.hasOwnProperty("masterSalt"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.masterSalt);
            if (message.masterPublicKey != null && message.hasOwnProperty("masterPublicKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.masterPublicKey);
            if (message.sharingEncrypted != null && message.hasOwnProperty("sharingEncrypted"))
                $root.api.IdentityEncryptedKey.encode(message.sharingEncrypted, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.boxEncrypted != null && message.hasOwnProperty("boxEncrypted"))
                $root.api.IdentityEncryptedKey.encode(message.boxEncrypted, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.signEncrypted != null && message.hasOwnProperty("signEncrypted"))
                $root.api.IdentityEncryptedKey.encode(message.signEncrypted, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.readEncrypted != null && message.hasOwnProperty("readEncrypted"))
                $root.api.IdentityEncryptedKey.encode(message.readEncrypted, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityEncryption message, length delimited. Does not implicitly {@link api.IdentityEncryption.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityEncryption
         * @static
         * @param {api.IIdentityEncryption} message IdentityEncryption message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityEncryption.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityEncryption message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityEncryption
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityEncryption} IdentityEncryption
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityEncryption.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityEncryption();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.version = reader.uint32();
                    break;
                case 2:
                    message.masterSalt = reader.bytes();
                    break;
                case 3:
                    message.masterPublicKey = reader.bytes();
                    break;
                case 4:
                    message.sharingEncrypted = $root.api.IdentityEncryptedKey.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.boxEncrypted = $root.api.IdentityEncryptedKey.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.signEncrypted = $root.api.IdentityEncryptedKey.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.readEncrypted = $root.api.IdentityEncryptedKey.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityEncryption message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityEncryption
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityEncryption} IdentityEncryption
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityEncryption.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityEncryption message.
         * @function verify
         * @memberof api.IdentityEncryption
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityEncryption.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.masterSalt != null && message.hasOwnProperty("masterSalt"))
                if (!(message.masterSalt && typeof message.masterSalt.length === "number" || $util.isString(message.masterSalt)))
                    return "masterSalt: buffer expected";
            if (message.masterPublicKey != null && message.hasOwnProperty("masterPublicKey"))
                if (!(message.masterPublicKey && typeof message.masterPublicKey.length === "number" || $util.isString(message.masterPublicKey)))
                    return "masterPublicKey: buffer expected";
            if (message.sharingEncrypted != null && message.hasOwnProperty("sharingEncrypted")) {
                var error = $root.api.IdentityEncryptedKey.verify(message.sharingEncrypted);
                if (error)
                    return "sharingEncrypted." + error;
            }
            if (message.boxEncrypted != null && message.hasOwnProperty("boxEncrypted")) {
                var error = $root.api.IdentityEncryptedKey.verify(message.boxEncrypted);
                if (error)
                    return "boxEncrypted." + error;
            }
            if (message.signEncrypted != null && message.hasOwnProperty("signEncrypted")) {
                var error = $root.api.IdentityEncryptedKey.verify(message.signEncrypted);
                if (error)
                    return "signEncrypted." + error;
            }
            if (message.readEncrypted != null && message.hasOwnProperty("readEncrypted")) {
                var error = $root.api.IdentityEncryptedKey.verify(message.readEncrypted);
                if (error)
                    return "readEncrypted." + error;
            }
            return null;
        };

        /**
         * Creates an IdentityEncryption message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityEncryption
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityEncryption} IdentityEncryption
         */
        IdentityEncryption.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityEncryption)
                return object;
            var message = new $root.api.IdentityEncryption();
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.masterSalt != null)
                if (typeof object.masterSalt === "string")
                    $util.base64.decode(object.masterSalt, message.masterSalt = $util.newBuffer($util.base64.length(object.masterSalt)), 0);
                else if (object.masterSalt.length)
                    message.masterSalt = object.masterSalt;
            if (object.masterPublicKey != null)
                if (typeof object.masterPublicKey === "string")
                    $util.base64.decode(object.masterPublicKey, message.masterPublicKey = $util.newBuffer($util.base64.length(object.masterPublicKey)), 0);
                else if (object.masterPublicKey.length)
                    message.masterPublicKey = object.masterPublicKey;
            if (object.sharingEncrypted != null) {
                if (typeof object.sharingEncrypted !== "object")
                    throw TypeError(".api.IdentityEncryption.sharingEncrypted: object expected");
                message.sharingEncrypted = $root.api.IdentityEncryptedKey.fromObject(object.sharingEncrypted);
            }
            if (object.boxEncrypted != null) {
                if (typeof object.boxEncrypted !== "object")
                    throw TypeError(".api.IdentityEncryption.boxEncrypted: object expected");
                message.boxEncrypted = $root.api.IdentityEncryptedKey.fromObject(object.boxEncrypted);
            }
            if (object.signEncrypted != null) {
                if (typeof object.signEncrypted !== "object")
                    throw TypeError(".api.IdentityEncryption.signEncrypted: object expected");
                message.signEncrypted = $root.api.IdentityEncryptedKey.fromObject(object.signEncrypted);
            }
            if (object.readEncrypted != null) {
                if (typeof object.readEncrypted !== "object")
                    throw TypeError(".api.IdentityEncryption.readEncrypted: object expected");
                message.readEncrypted = $root.api.IdentityEncryptedKey.fromObject(object.readEncrypted);
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityEncryption message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityEncryption
         * @static
         * @param {api.IdentityEncryption} message IdentityEncryption
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityEncryption.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.version = 0;
                if (options.bytes === String)
                    object.masterSalt = "";
                else {
                    object.masterSalt = [];
                    if (options.bytes !== Array)
                        object.masterSalt = $util.newBuffer(object.masterSalt);
                }
                if (options.bytes === String)
                    object.masterPublicKey = "";
                else {
                    object.masterPublicKey = [];
                    if (options.bytes !== Array)
                        object.masterPublicKey = $util.newBuffer(object.masterPublicKey);
                }
                object.sharingEncrypted = null;
                object.boxEncrypted = null;
                object.signEncrypted = null;
                object.readEncrypted = null;
            }
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.masterSalt != null && message.hasOwnProperty("masterSalt"))
                object.masterSalt = options.bytes === String ? $util.base64.encode(message.masterSalt, 0, message.masterSalt.length) : options.bytes === Array ? Array.prototype.slice.call(message.masterSalt) : message.masterSalt;
            if (message.masterPublicKey != null && message.hasOwnProperty("masterPublicKey"))
                object.masterPublicKey = options.bytes === String ? $util.base64.encode(message.masterPublicKey, 0, message.masterPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.masterPublicKey) : message.masterPublicKey;
            if (message.sharingEncrypted != null && message.hasOwnProperty("sharingEncrypted"))
                object.sharingEncrypted = $root.api.IdentityEncryptedKey.toObject(message.sharingEncrypted, options);
            if (message.boxEncrypted != null && message.hasOwnProperty("boxEncrypted"))
                object.boxEncrypted = $root.api.IdentityEncryptedKey.toObject(message.boxEncrypted, options);
            if (message.signEncrypted != null && message.hasOwnProperty("signEncrypted"))
                object.signEncrypted = $root.api.IdentityEncryptedKey.toObject(message.signEncrypted, options);
            if (message.readEncrypted != null && message.hasOwnProperty("readEncrypted"))
                object.readEncrypted = $root.api.IdentityEncryptedKey.toObject(message.readEncrypted, options);
            return object;
        };

        /**
         * Converts this IdentityEncryption to JSON.
         * @function toJSON
         * @memberof api.IdentityEncryption
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityEncryption.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityEncryption;
    })();

    /**
     * IdentityShareKind enum.
     * @name api.IdentityShareKind
     * @enum {string}
     * @property {number} BOX=0 BOX value
     * @property {number} SHARING=1 SHARING value
     */
    api.IdentityShareKind = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "BOX"] = 0;
        values[valuesById[1] = "SHARING"] = 1;
        return values;
    })();

    /**
     * IdentityAccessKeyKind enum.
     * @name api.IdentityAccessKeyKind
     * @enum {string}
     * @property {number} READ=0 READ value
     * @property {number} WRITE=1 WRITE value
     */
    api.IdentityAccessKeyKind = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "READ"] = 0;
        values[valuesById[1] = "WRITE"] = 1;
        return values;
    })();

    api.ApplicationIdentity = (function() {

        /**
         * Properties of an ApplicationIdentity.
         * @memberof api
         * @interface IApplicationIdentity
         * @property {api.IIdentity|null} [identity] ApplicationIdentity identity
         * @property {api.IIdentityExternalAuth|null} [auth] ApplicationIdentity auth
         */

        /**
         * Constructs a new ApplicationIdentity.
         * @memberof api
         * @classdesc Represents an ApplicationIdentity.
         * @implements IApplicationIdentity
         * @constructor
         * @param {api.IApplicationIdentity=} [properties] Properties to set
         */
        function ApplicationIdentity(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApplicationIdentity identity.
         * @member {api.IIdentity|null|undefined} identity
         * @memberof api.ApplicationIdentity
         * @instance
         */
        ApplicationIdentity.prototype.identity = null;

        /**
         * ApplicationIdentity auth.
         * @member {api.IIdentityExternalAuth|null|undefined} auth
         * @memberof api.ApplicationIdentity
         * @instance
         */
        ApplicationIdentity.prototype.auth = null;

        /**
         * Creates a new ApplicationIdentity instance using the specified properties.
         * @function create
         * @memberof api.ApplicationIdentity
         * @static
         * @param {api.IApplicationIdentity=} [properties] Properties to set
         * @returns {api.ApplicationIdentity} ApplicationIdentity instance
         */
        ApplicationIdentity.create = function create(properties) {
            return new ApplicationIdentity(properties);
        };

        /**
         * Encodes the specified ApplicationIdentity message. Does not implicitly {@link api.ApplicationIdentity.verify|verify} messages.
         * @function encode
         * @memberof api.ApplicationIdentity
         * @static
         * @param {api.IApplicationIdentity} message ApplicationIdentity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationIdentity.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.identity != null && message.hasOwnProperty("identity"))
                $root.api.Identity.encode(message.identity, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.auth != null && message.hasOwnProperty("auth"))
                $root.api.IdentityExternalAuth.encode(message.auth, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ApplicationIdentity message, length delimited. Does not implicitly {@link api.ApplicationIdentity.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ApplicationIdentity
         * @static
         * @param {api.IApplicationIdentity} message ApplicationIdentity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationIdentity.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApplicationIdentity message from the specified reader or buffer.
         * @function decode
         * @memberof api.ApplicationIdentity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ApplicationIdentity} ApplicationIdentity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationIdentity.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ApplicationIdentity();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.identity = $root.api.Identity.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.auth = $root.api.IdentityExternalAuth.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApplicationIdentity message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ApplicationIdentity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ApplicationIdentity} ApplicationIdentity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationIdentity.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApplicationIdentity message.
         * @function verify
         * @memberof api.ApplicationIdentity
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApplicationIdentity.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.identity != null && message.hasOwnProperty("identity")) {
                var error = $root.api.Identity.verify(message.identity);
                if (error)
                    return "identity." + error;
            }
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.api.IdentityExternalAuth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            return null;
        };

        /**
         * Creates an ApplicationIdentity message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ApplicationIdentity
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ApplicationIdentity} ApplicationIdentity
         */
        ApplicationIdentity.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ApplicationIdentity)
                return object;
            var message = new $root.api.ApplicationIdentity();
            if (object.identity != null) {
                if (typeof object.identity !== "object")
                    throw TypeError(".api.ApplicationIdentity.identity: object expected");
                message.identity = $root.api.Identity.fromObject(object.identity);
            }
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".api.ApplicationIdentity.auth: object expected");
                message.auth = $root.api.IdentityExternalAuth.fromObject(object.auth);
            }
            return message;
        };

        /**
         * Creates a plain object from an ApplicationIdentity message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ApplicationIdentity
         * @static
         * @param {api.ApplicationIdentity} message ApplicationIdentity
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApplicationIdentity.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.identity = null;
                object.auth = null;
            }
            if (message.identity != null && message.hasOwnProperty("identity"))
                object.identity = $root.api.Identity.toObject(message.identity, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.api.IdentityExternalAuth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this ApplicationIdentity to JSON.
         * @function toJSON
         * @memberof api.ApplicationIdentity
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApplicationIdentity.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApplicationIdentity;
    })();

    api.IdentityRegisterRequest = (function() {

        /**
         * Properties of an IdentityRegisterRequest.
         * @memberof api
         * @interface IIdentityRegisterRequest
         * @property {api.IIdentityFields|null} [identity] IdentityRegisterRequest identity
         * @property {api.IIdentityEncryption|null} [encryption] IdentityRegisterRequest encryption
         */

        /**
         * Constructs a new IdentityRegisterRequest.
         * @memberof api
         * @classdesc Represents an IdentityRegisterRequest.
         * @implements IIdentityRegisterRequest
         * @constructor
         * @param {api.IIdentityRegisterRequest=} [properties] Properties to set
         */
        function IdentityRegisterRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityRegisterRequest identity.
         * @member {api.IIdentityFields|null|undefined} identity
         * @memberof api.IdentityRegisterRequest
         * @instance
         */
        IdentityRegisterRequest.prototype.identity = null;

        /**
         * IdentityRegisterRequest encryption.
         * @member {api.IIdentityEncryption|null|undefined} encryption
         * @memberof api.IdentityRegisterRequest
         * @instance
         */
        IdentityRegisterRequest.prototype.encryption = null;

        /**
         * Creates a new IdentityRegisterRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityRegisterRequest
         * @static
         * @param {api.IIdentityRegisterRequest=} [properties] Properties to set
         * @returns {api.IdentityRegisterRequest} IdentityRegisterRequest instance
         */
        IdentityRegisterRequest.create = function create(properties) {
            return new IdentityRegisterRequest(properties);
        };

        /**
         * Encodes the specified IdentityRegisterRequest message. Does not implicitly {@link api.IdentityRegisterRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityRegisterRequest
         * @static
         * @param {api.IIdentityRegisterRequest} message IdentityRegisterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityRegisterRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.identity != null && message.hasOwnProperty("identity"))
                $root.api.IdentityFields.encode(message.identity, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.api.IdentityEncryption.encode(message.encryption, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityRegisterRequest message, length delimited. Does not implicitly {@link api.IdentityRegisterRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityRegisterRequest
         * @static
         * @param {api.IIdentityRegisterRequest} message IdentityRegisterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityRegisterRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityRegisterRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityRegisterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityRegisterRequest} IdentityRegisterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityRegisterRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityRegisterRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.identity = $root.api.IdentityFields.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.encryption = $root.api.IdentityEncryption.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityRegisterRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityRegisterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityRegisterRequest} IdentityRegisterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityRegisterRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityRegisterRequest message.
         * @function verify
         * @memberof api.IdentityRegisterRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityRegisterRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.identity != null && message.hasOwnProperty("identity")) {
                var error = $root.api.IdentityFields.verify(message.identity);
                if (error)
                    return "identity." + error;
            }
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.api.IdentityEncryption.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            return null;
        };

        /**
         * Creates an IdentityRegisterRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityRegisterRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityRegisterRequest} IdentityRegisterRequest
         */
        IdentityRegisterRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityRegisterRequest)
                return object;
            var message = new $root.api.IdentityRegisterRequest();
            if (object.identity != null) {
                if (typeof object.identity !== "object")
                    throw TypeError(".api.IdentityRegisterRequest.identity: object expected");
                message.identity = $root.api.IdentityFields.fromObject(object.identity);
            }
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".api.IdentityRegisterRequest.encryption: object expected");
                message.encryption = $root.api.IdentityEncryption.fromObject(object.encryption);
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityRegisterRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityRegisterRequest
         * @static
         * @param {api.IdentityRegisterRequest} message IdentityRegisterRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityRegisterRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.identity = null;
                object.encryption = null;
            }
            if (message.identity != null && message.hasOwnProperty("identity"))
                object.identity = $root.api.IdentityFields.toObject(message.identity, options);
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.api.IdentityEncryption.toObject(message.encryption, options);
            return object;
        };

        /**
         * Converts this IdentityRegisterRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityRegisterRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityRegisterRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityRegisterRequest;
    })();

    api.IdentityExternalAuth = (function() {

        /**
         * Properties of an IdentityExternalAuth.
         * @memberof api
         * @interface IIdentityExternalAuth
         * @property {api.IdentityExternalAuth.IJWT|null} [jwt] IdentityExternalAuth jwt
         */

        /**
         * Constructs a new IdentityExternalAuth.
         * @memberof api
         * @classdesc Represents an IdentityExternalAuth.
         * @implements IIdentityExternalAuth
         * @constructor
         * @param {api.IIdentityExternalAuth=} [properties] Properties to set
         */
        function IdentityExternalAuth(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityExternalAuth jwt.
         * @member {api.IdentityExternalAuth.IJWT|null|undefined} jwt
         * @memberof api.IdentityExternalAuth
         * @instance
         */
        IdentityExternalAuth.prototype.jwt = null;

        /**
         * Creates a new IdentityExternalAuth instance using the specified properties.
         * @function create
         * @memberof api.IdentityExternalAuth
         * @static
         * @param {api.IIdentityExternalAuth=} [properties] Properties to set
         * @returns {api.IdentityExternalAuth} IdentityExternalAuth instance
         */
        IdentityExternalAuth.create = function create(properties) {
            return new IdentityExternalAuth(properties);
        };

        /**
         * Encodes the specified IdentityExternalAuth message. Does not implicitly {@link api.IdentityExternalAuth.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityExternalAuth
         * @static
         * @param {api.IIdentityExternalAuth} message IdentityExternalAuth message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityExternalAuth.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.jwt != null && message.hasOwnProperty("jwt"))
                $root.api.IdentityExternalAuth.JWT.encode(message.jwt, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityExternalAuth message, length delimited. Does not implicitly {@link api.IdentityExternalAuth.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityExternalAuth
         * @static
         * @param {api.IIdentityExternalAuth} message IdentityExternalAuth message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityExternalAuth.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityExternalAuth message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityExternalAuth
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityExternalAuth} IdentityExternalAuth
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityExternalAuth.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityExternalAuth();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.jwt = $root.api.IdentityExternalAuth.JWT.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityExternalAuth message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityExternalAuth
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityExternalAuth} IdentityExternalAuth
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityExternalAuth.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityExternalAuth message.
         * @function verify
         * @memberof api.IdentityExternalAuth
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityExternalAuth.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.jwt != null && message.hasOwnProperty("jwt")) {
                var error = $root.api.IdentityExternalAuth.JWT.verify(message.jwt);
                if (error)
                    return "jwt." + error;
            }
            return null;
        };

        /**
         * Creates an IdentityExternalAuth message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityExternalAuth
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityExternalAuth} IdentityExternalAuth
         */
        IdentityExternalAuth.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityExternalAuth)
                return object;
            var message = new $root.api.IdentityExternalAuth();
            if (object.jwt != null) {
                if (typeof object.jwt !== "object")
                    throw TypeError(".api.IdentityExternalAuth.jwt: object expected");
                message.jwt = $root.api.IdentityExternalAuth.JWT.fromObject(object.jwt);
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityExternalAuth message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityExternalAuth
         * @static
         * @param {api.IdentityExternalAuth} message IdentityExternalAuth
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityExternalAuth.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.jwt = null;
            if (message.jwt != null && message.hasOwnProperty("jwt"))
                object.jwt = $root.api.IdentityExternalAuth.JWT.toObject(message.jwt, options);
            return object;
        };

        /**
         * Converts this IdentityExternalAuth to JSON.
         * @function toJSON
         * @memberof api.IdentityExternalAuth
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityExternalAuth.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        IdentityExternalAuth.JWT = (function() {

            /**
             * Properties of a JWT.
             * @memberof api.IdentityExternalAuth
             * @interface IJWT
             * @property {string|null} [token] JWT token
             */

            /**
             * Constructs a new JWT.
             * @memberof api.IdentityExternalAuth
             * @classdesc Represents a JWT.
             * @implements IJWT
             * @constructor
             * @param {api.IdentityExternalAuth.IJWT=} [properties] Properties to set
             */
            function JWT(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * JWT token.
             * @member {string} token
             * @memberof api.IdentityExternalAuth.JWT
             * @instance
             */
            JWT.prototype.token = "";

            /**
             * Creates a new JWT instance using the specified properties.
             * @function create
             * @memberof api.IdentityExternalAuth.JWT
             * @static
             * @param {api.IdentityExternalAuth.IJWT=} [properties] Properties to set
             * @returns {api.IdentityExternalAuth.JWT} JWT instance
             */
            JWT.create = function create(properties) {
                return new JWT(properties);
            };

            /**
             * Encodes the specified JWT message. Does not implicitly {@link api.IdentityExternalAuth.JWT.verify|verify} messages.
             * @function encode
             * @memberof api.IdentityExternalAuth.JWT
             * @static
             * @param {api.IdentityExternalAuth.IJWT} message JWT message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JWT.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.token != null && message.hasOwnProperty("token"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.token);
                return writer;
            };

            /**
             * Encodes the specified JWT message, length delimited. Does not implicitly {@link api.IdentityExternalAuth.JWT.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.IdentityExternalAuth.JWT
             * @static
             * @param {api.IdentityExternalAuth.IJWT} message JWT message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JWT.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a JWT message from the specified reader or buffer.
             * @function decode
             * @memberof api.IdentityExternalAuth.JWT
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.IdentityExternalAuth.JWT} JWT
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JWT.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityExternalAuth.JWT();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.token = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a JWT message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.IdentityExternalAuth.JWT
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.IdentityExternalAuth.JWT} JWT
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JWT.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a JWT message.
             * @function verify
             * @memberof api.IdentityExternalAuth.JWT
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            JWT.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                return null;
            };

            /**
             * Creates a JWT message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.IdentityExternalAuth.JWT
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.IdentityExternalAuth.JWT} JWT
             */
            JWT.fromObject = function fromObject(object) {
                if (object instanceof $root.api.IdentityExternalAuth.JWT)
                    return object;
                var message = new $root.api.IdentityExternalAuth.JWT();
                if (object.token != null)
                    message.token = String(object.token);
                return message;
            };

            /**
             * Creates a plain object from a JWT message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.IdentityExternalAuth.JWT
             * @static
             * @param {api.IdentityExternalAuth.JWT} message JWT
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            JWT.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.token = "";
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = message.token;
                return object;
            };

            /**
             * Converts this JWT to JSON.
             * @function toJSON
             * @memberof api.IdentityExternalAuth.JWT
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            JWT.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return JWT;
        })();

        return IdentityExternalAuth;
    })();

    api.RegisterApplicationIdentityRequest = (function() {

        /**
         * Properties of a RegisterApplicationIdentityRequest.
         * @memberof api
         * @interface IRegisterApplicationIdentityRequest
         * @property {string|null} [appID] RegisterApplicationIdentityRequest appID
         * @property {api.IIdentityFields|null} [identity] RegisterApplicationIdentityRequest identity
         * @property {api.IIdentityEncryption|null} [encryption] RegisterApplicationIdentityRequest encryption
         * @property {Object.<string,api.IResourcePostRequest>|null} [resources] RegisterApplicationIdentityRequest resources
         * @property {api.IIdentityExternalAuth|null} [auth] RegisterApplicationIdentityRequest auth
         */

        /**
         * Constructs a new RegisterApplicationIdentityRequest.
         * @memberof api
         * @classdesc Represents a RegisterApplicationIdentityRequest.
         * @implements IRegisterApplicationIdentityRequest
         * @constructor
         * @param {api.IRegisterApplicationIdentityRequest=} [properties] Properties to set
         */
        function RegisterApplicationIdentityRequest(properties) {
            this.resources = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegisterApplicationIdentityRequest appID.
         * @member {string} appID
         * @memberof api.RegisterApplicationIdentityRequest
         * @instance
         */
        RegisterApplicationIdentityRequest.prototype.appID = "";

        /**
         * RegisterApplicationIdentityRequest identity.
         * @member {api.IIdentityFields|null|undefined} identity
         * @memberof api.RegisterApplicationIdentityRequest
         * @instance
         */
        RegisterApplicationIdentityRequest.prototype.identity = null;

        /**
         * RegisterApplicationIdentityRequest encryption.
         * @member {api.IIdentityEncryption|null|undefined} encryption
         * @memberof api.RegisterApplicationIdentityRequest
         * @instance
         */
        RegisterApplicationIdentityRequest.prototype.encryption = null;

        /**
         * RegisterApplicationIdentityRequest resources.
         * @member {Object.<string,api.IResourcePostRequest>} resources
         * @memberof api.RegisterApplicationIdentityRequest
         * @instance
         */
        RegisterApplicationIdentityRequest.prototype.resources = $util.emptyObject;

        /**
         * RegisterApplicationIdentityRequest auth.
         * @member {api.IIdentityExternalAuth|null|undefined} auth
         * @memberof api.RegisterApplicationIdentityRequest
         * @instance
         */
        RegisterApplicationIdentityRequest.prototype.auth = null;

        /**
         * Creates a new RegisterApplicationIdentityRequest instance using the specified properties.
         * @function create
         * @memberof api.RegisterApplicationIdentityRequest
         * @static
         * @param {api.IRegisterApplicationIdentityRequest=} [properties] Properties to set
         * @returns {api.RegisterApplicationIdentityRequest} RegisterApplicationIdentityRequest instance
         */
        RegisterApplicationIdentityRequest.create = function create(properties) {
            return new RegisterApplicationIdentityRequest(properties);
        };

        /**
         * Encodes the specified RegisterApplicationIdentityRequest message. Does not implicitly {@link api.RegisterApplicationIdentityRequest.verify|verify} messages.
         * @function encode
         * @memberof api.RegisterApplicationIdentityRequest
         * @static
         * @param {api.IRegisterApplicationIdentityRequest} message RegisterApplicationIdentityRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterApplicationIdentityRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.appID != null && message.hasOwnProperty("appID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.appID);
            if (message.identity != null && message.hasOwnProperty("identity"))
                $root.api.IdentityFields.encode(message.identity, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.api.IdentityEncryption.encode(message.encryption, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.resources != null && message.hasOwnProperty("resources"))
                for (var keys = Object.keys(message.resources), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.api.ResourcePostRequest.encode(message.resources[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.auth != null && message.hasOwnProperty("auth"))
                $root.api.IdentityExternalAuth.encode(message.auth, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RegisterApplicationIdentityRequest message, length delimited. Does not implicitly {@link api.RegisterApplicationIdentityRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.RegisterApplicationIdentityRequest
         * @static
         * @param {api.IRegisterApplicationIdentityRequest} message RegisterApplicationIdentityRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterApplicationIdentityRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterApplicationIdentityRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.RegisterApplicationIdentityRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.RegisterApplicationIdentityRequest} RegisterApplicationIdentityRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterApplicationIdentityRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.RegisterApplicationIdentityRequest(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.appID = reader.string();
                    break;
                case 2:
                    message.identity = $root.api.IdentityFields.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.encryption = $root.api.IdentityEncryption.decode(reader, reader.uint32());
                    break;
                case 4:
                    reader.skip().pos++;
                    if (message.resources === $util.emptyObject)
                        message.resources = {};
                    key = reader.string();
                    reader.pos++;
                    message.resources[key] = $root.api.ResourcePostRequest.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.auth = $root.api.IdentityExternalAuth.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterApplicationIdentityRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.RegisterApplicationIdentityRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.RegisterApplicationIdentityRequest} RegisterApplicationIdentityRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterApplicationIdentityRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterApplicationIdentityRequest message.
         * @function verify
         * @memberof api.RegisterApplicationIdentityRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterApplicationIdentityRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.appID != null && message.hasOwnProperty("appID"))
                if (!$util.isString(message.appID))
                    return "appID: string expected";
            if (message.identity != null && message.hasOwnProperty("identity")) {
                var error = $root.api.IdentityFields.verify(message.identity);
                if (error)
                    return "identity." + error;
            }
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.api.IdentityEncryption.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            if (message.resources != null && message.hasOwnProperty("resources")) {
                if (!$util.isObject(message.resources))
                    return "resources: object expected";
                var key = Object.keys(message.resources);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.api.ResourcePostRequest.verify(message.resources[key[i]]);
                    if (error)
                        return "resources." + error;
                }
            }
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.api.IdentityExternalAuth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            return null;
        };

        /**
         * Creates a RegisterApplicationIdentityRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.RegisterApplicationIdentityRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.RegisterApplicationIdentityRequest} RegisterApplicationIdentityRequest
         */
        RegisterApplicationIdentityRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.RegisterApplicationIdentityRequest)
                return object;
            var message = new $root.api.RegisterApplicationIdentityRequest();
            if (object.appID != null)
                message.appID = String(object.appID);
            if (object.identity != null) {
                if (typeof object.identity !== "object")
                    throw TypeError(".api.RegisterApplicationIdentityRequest.identity: object expected");
                message.identity = $root.api.IdentityFields.fromObject(object.identity);
            }
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".api.RegisterApplicationIdentityRequest.encryption: object expected");
                message.encryption = $root.api.IdentityEncryption.fromObject(object.encryption);
            }
            if (object.resources) {
                if (typeof object.resources !== "object")
                    throw TypeError(".api.RegisterApplicationIdentityRequest.resources: object expected");
                message.resources = {};
                for (var keys = Object.keys(object.resources), i = 0; i < keys.length; ++i) {
                    if (typeof object.resources[keys[i]] !== "object")
                        throw TypeError(".api.RegisterApplicationIdentityRequest.resources: object expected");
                    message.resources[keys[i]] = $root.api.ResourcePostRequest.fromObject(object.resources[keys[i]]);
                }
            }
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".api.RegisterApplicationIdentityRequest.auth: object expected");
                message.auth = $root.api.IdentityExternalAuth.fromObject(object.auth);
            }
            return message;
        };

        /**
         * Creates a plain object from a RegisterApplicationIdentityRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.RegisterApplicationIdentityRequest
         * @static
         * @param {api.RegisterApplicationIdentityRequest} message RegisterApplicationIdentityRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegisterApplicationIdentityRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.resources = {};
            if (options.defaults) {
                object.appID = "";
                object.identity = null;
                object.encryption = null;
                object.auth = null;
            }
            if (message.appID != null && message.hasOwnProperty("appID"))
                object.appID = message.appID;
            if (message.identity != null && message.hasOwnProperty("identity"))
                object.identity = $root.api.IdentityFields.toObject(message.identity, options);
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.api.IdentityEncryption.toObject(message.encryption, options);
            var keys2;
            if (message.resources && (keys2 = Object.keys(message.resources)).length) {
                object.resources = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.resources[keys2[j]] = $root.api.ResourcePostRequest.toObject(message.resources[keys2[j]], options);
            }
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.api.IdentityExternalAuth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this RegisterApplicationIdentityRequest to JSON.
         * @function toJSON
         * @memberof api.RegisterApplicationIdentityRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegisterApplicationIdentityRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegisterApplicationIdentityRequest;
    })();

    api.RegisterApplicationIdentityResponse = (function() {

        /**
         * Properties of a RegisterApplicationIdentityResponse.
         * @memberof api
         * @interface IRegisterApplicationIdentityResponse
         * @property {string|null} [login] RegisterApplicationIdentityResponse login
         */

        /**
         * Constructs a new RegisterApplicationIdentityResponse.
         * @memberof api
         * @classdesc Represents a RegisterApplicationIdentityResponse.
         * @implements IRegisterApplicationIdentityResponse
         * @constructor
         * @param {api.IRegisterApplicationIdentityResponse=} [properties] Properties to set
         */
        function RegisterApplicationIdentityResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegisterApplicationIdentityResponse login.
         * @member {string} login
         * @memberof api.RegisterApplicationIdentityResponse
         * @instance
         */
        RegisterApplicationIdentityResponse.prototype.login = "";

        /**
         * Creates a new RegisterApplicationIdentityResponse instance using the specified properties.
         * @function create
         * @memberof api.RegisterApplicationIdentityResponse
         * @static
         * @param {api.IRegisterApplicationIdentityResponse=} [properties] Properties to set
         * @returns {api.RegisterApplicationIdentityResponse} RegisterApplicationIdentityResponse instance
         */
        RegisterApplicationIdentityResponse.create = function create(properties) {
            return new RegisterApplicationIdentityResponse(properties);
        };

        /**
         * Encodes the specified RegisterApplicationIdentityResponse message. Does not implicitly {@link api.RegisterApplicationIdentityResponse.verify|verify} messages.
         * @function encode
         * @memberof api.RegisterApplicationIdentityResponse
         * @static
         * @param {api.IRegisterApplicationIdentityResponse} message RegisterApplicationIdentityResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterApplicationIdentityResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            return writer;
        };

        /**
         * Encodes the specified RegisterApplicationIdentityResponse message, length delimited. Does not implicitly {@link api.RegisterApplicationIdentityResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.RegisterApplicationIdentityResponse
         * @static
         * @param {api.IRegisterApplicationIdentityResponse} message RegisterApplicationIdentityResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterApplicationIdentityResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterApplicationIdentityResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.RegisterApplicationIdentityResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.RegisterApplicationIdentityResponse} RegisterApplicationIdentityResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterApplicationIdentityResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.RegisterApplicationIdentityResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterApplicationIdentityResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.RegisterApplicationIdentityResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.RegisterApplicationIdentityResponse} RegisterApplicationIdentityResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterApplicationIdentityResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterApplicationIdentityResponse message.
         * @function verify
         * @memberof api.RegisterApplicationIdentityResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterApplicationIdentityResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            return null;
        };

        /**
         * Creates a RegisterApplicationIdentityResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.RegisterApplicationIdentityResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.RegisterApplicationIdentityResponse} RegisterApplicationIdentityResponse
         */
        RegisterApplicationIdentityResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.RegisterApplicationIdentityResponse)
                return object;
            var message = new $root.api.RegisterApplicationIdentityResponse();
            if (object.login != null)
                message.login = String(object.login);
            return message;
        };

        /**
         * Creates a plain object from a RegisterApplicationIdentityResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.RegisterApplicationIdentityResponse
         * @static
         * @param {api.RegisterApplicationIdentityResponse} message RegisterApplicationIdentityResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegisterApplicationIdentityResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.login = "";
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            return object;
        };

        /**
         * Converts this RegisterApplicationIdentityResponse to JSON.
         * @function toJSON
         * @memberof api.RegisterApplicationIdentityResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegisterApplicationIdentityResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegisterApplicationIdentityResponse;
    })();

    api.IdentityCreateRequest = (function() {

        /**
         * Properties of an IdentityCreateRequest.
         * @memberof api
         * @interface IIdentityCreateRequest
         * @property {api.IIdentityFields|null} [identity] IdentityCreateRequest identity
         * @property {api.IIdentityEncryption|null} [encryption] IdentityCreateRequest encryption
         * @property {Uint8Array|null} [signChain] IdentityCreateRequest signChain
         * @property {Array.<api.IIdentityShareEntry>|null} [sharingGroup] IdentityCreateRequest sharingGroup
         * @property {string|null} [email] IdentityCreateRequest email
         */

        /**
         * Constructs a new IdentityCreateRequest.
         * @memberof api
         * @classdesc Represents an IdentityCreateRequest.
         * @implements IIdentityCreateRequest
         * @constructor
         * @param {api.IIdentityCreateRequest=} [properties] Properties to set
         */
        function IdentityCreateRequest(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityCreateRequest identity.
         * @member {api.IIdentityFields|null|undefined} identity
         * @memberof api.IdentityCreateRequest
         * @instance
         */
        IdentityCreateRequest.prototype.identity = null;

        /**
         * IdentityCreateRequest encryption.
         * @member {api.IIdentityEncryption|null|undefined} encryption
         * @memberof api.IdentityCreateRequest
         * @instance
         */
        IdentityCreateRequest.prototype.encryption = null;

        /**
         * IdentityCreateRequest signChain.
         * @member {Uint8Array} signChain
         * @memberof api.IdentityCreateRequest
         * @instance
         */
        IdentityCreateRequest.prototype.signChain = $util.newBuffer([]);

        /**
         * IdentityCreateRequest sharingGroup.
         * @member {Array.<api.IIdentityShareEntry>} sharingGroup
         * @memberof api.IdentityCreateRequest
         * @instance
         */
        IdentityCreateRequest.prototype.sharingGroup = $util.emptyArray;

        /**
         * IdentityCreateRequest email.
         * @member {string} email
         * @memberof api.IdentityCreateRequest
         * @instance
         */
        IdentityCreateRequest.prototype.email = "";

        /**
         * Creates a new IdentityCreateRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityCreateRequest
         * @static
         * @param {api.IIdentityCreateRequest=} [properties] Properties to set
         * @returns {api.IdentityCreateRequest} IdentityCreateRequest instance
         */
        IdentityCreateRequest.create = function create(properties) {
            return new IdentityCreateRequest(properties);
        };

        /**
         * Encodes the specified IdentityCreateRequest message. Does not implicitly {@link api.IdentityCreateRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityCreateRequest
         * @static
         * @param {api.IIdentityCreateRequest} message IdentityCreateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityCreateRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.identity != null && message.hasOwnProperty("identity"))
                $root.api.IdentityFields.encode(message.identity, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.api.IdentityEncryption.encode(message.encryption, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signChain);
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.api.IdentityShareEntry.encode(message.sharingGroup[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.email);
            return writer;
        };

        /**
         * Encodes the specified IdentityCreateRequest message, length delimited. Does not implicitly {@link api.IdentityCreateRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityCreateRequest
         * @static
         * @param {api.IIdentityCreateRequest} message IdentityCreateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityCreateRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityCreateRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityCreateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityCreateRequest} IdentityCreateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityCreateRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityCreateRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.identity = $root.api.IdentityFields.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.encryption = $root.api.IdentityEncryption.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.signChain = reader.bytes();
                    break;
                case 4:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.api.IdentityShareEntry.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.email = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityCreateRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityCreateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityCreateRequest} IdentityCreateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityCreateRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityCreateRequest message.
         * @function verify
         * @memberof api.IdentityCreateRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityCreateRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.identity != null && message.hasOwnProperty("identity")) {
                var error = $root.api.IdentityFields.verify(message.identity);
                if (error)
                    return "identity." + error;
            }
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.api.IdentityEncryption.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                if (!(message.signChain && typeof message.signChain.length === "number" || $util.isString(message.signChain)))
                    return "signChain: buffer expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.api.IdentityShareEntry.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            return null;
        };

        /**
         * Creates an IdentityCreateRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityCreateRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityCreateRequest} IdentityCreateRequest
         */
        IdentityCreateRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityCreateRequest)
                return object;
            var message = new $root.api.IdentityCreateRequest();
            if (object.identity != null) {
                if (typeof object.identity !== "object")
                    throw TypeError(".api.IdentityCreateRequest.identity: object expected");
                message.identity = $root.api.IdentityFields.fromObject(object.identity);
            }
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".api.IdentityCreateRequest.encryption: object expected");
                message.encryption = $root.api.IdentityEncryption.fromObject(object.encryption);
            }
            if (object.signChain != null)
                if (typeof object.signChain === "string")
                    $util.base64.decode(object.signChain, message.signChain = $util.newBuffer($util.base64.length(object.signChain)), 0);
                else if (object.signChain.length)
                    message.signChain = object.signChain;
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".api.IdentityCreateRequest.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".api.IdentityCreateRequest.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.api.IdentityShareEntry.fromObject(object.sharingGroup[i]);
                }
            }
            if (object.email != null)
                message.email = String(object.email);
            return message;
        };

        /**
         * Creates a plain object from an IdentityCreateRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityCreateRequest
         * @static
         * @param {api.IdentityCreateRequest} message IdentityCreateRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityCreateRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults) {
                object.identity = null;
                object.encryption = null;
                if (options.bytes === String)
                    object.signChain = "";
                else {
                    object.signChain = [];
                    if (options.bytes !== Array)
                        object.signChain = $util.newBuffer(object.signChain);
                }
                object.email = "";
            }
            if (message.identity != null && message.hasOwnProperty("identity"))
                object.identity = $root.api.IdentityFields.toObject(message.identity, options);
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.api.IdentityEncryption.toObject(message.encryption, options);
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                object.signChain = options.bytes === String ? $util.base64.encode(message.signChain, 0, message.signChain.length) : options.bytes === Array ? Array.prototype.slice.call(message.signChain) : message.signChain;
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.api.IdentityShareEntry.toObject(message.sharingGroup[j], options);
            }
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            return object;
        };

        /**
         * Converts this IdentityCreateRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityCreateRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityCreateRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityCreateRequest;
    })();

    api.IdentityKeysToReplaceRequest = (function() {

        /**
         * Properties of an IdentityKeysToReplaceRequest.
         * @memberof api
         * @interface IIdentityKeysToReplaceRequest
         * @property {string|null} [login] IdentityKeysToReplaceRequest login
         * @property {api.IIdentityEncryption|null} [encryption] IdentityKeysToReplaceRequest encryption
         * @property {Uint8Array|null} [signChain] IdentityKeysToReplaceRequest signChain
         * @property {Array.<api.IIdentityShareEntry>|null} [sharingGroup] IdentityKeysToReplaceRequest sharingGroup
         */

        /**
         * Constructs a new IdentityKeysToReplaceRequest.
         * @memberof api
         * @classdesc Represents an IdentityKeysToReplaceRequest.
         * @implements IIdentityKeysToReplaceRequest
         * @constructor
         * @param {api.IIdentityKeysToReplaceRequest=} [properties] Properties to set
         */
        function IdentityKeysToReplaceRequest(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityKeysToReplaceRequest login.
         * @member {string} login
         * @memberof api.IdentityKeysToReplaceRequest
         * @instance
         */
        IdentityKeysToReplaceRequest.prototype.login = "";

        /**
         * IdentityKeysToReplaceRequest encryption.
         * @member {api.IIdentityEncryption|null|undefined} encryption
         * @memberof api.IdentityKeysToReplaceRequest
         * @instance
         */
        IdentityKeysToReplaceRequest.prototype.encryption = null;

        /**
         * IdentityKeysToReplaceRequest signChain.
         * @member {Uint8Array} signChain
         * @memberof api.IdentityKeysToReplaceRequest
         * @instance
         */
        IdentityKeysToReplaceRequest.prototype.signChain = $util.newBuffer([]);

        /**
         * IdentityKeysToReplaceRequest sharingGroup.
         * @member {Array.<api.IIdentityShareEntry>} sharingGroup
         * @memberof api.IdentityKeysToReplaceRequest
         * @instance
         */
        IdentityKeysToReplaceRequest.prototype.sharingGroup = $util.emptyArray;

        /**
         * Creates a new IdentityKeysToReplaceRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityKeysToReplaceRequest
         * @static
         * @param {api.IIdentityKeysToReplaceRequest=} [properties] Properties to set
         * @returns {api.IdentityKeysToReplaceRequest} IdentityKeysToReplaceRequest instance
         */
        IdentityKeysToReplaceRequest.create = function create(properties) {
            return new IdentityKeysToReplaceRequest(properties);
        };

        /**
         * Encodes the specified IdentityKeysToReplaceRequest message. Does not implicitly {@link api.IdentityKeysToReplaceRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityKeysToReplaceRequest
         * @static
         * @param {api.IIdentityKeysToReplaceRequest} message IdentityKeysToReplaceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityKeysToReplaceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.api.IdentityEncryption.encode(message.encryption, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signChain);
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.api.IdentityShareEntry.encode(message.sharingGroup[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityKeysToReplaceRequest message, length delimited. Does not implicitly {@link api.IdentityKeysToReplaceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityKeysToReplaceRequest
         * @static
         * @param {api.IIdentityKeysToReplaceRequest} message IdentityKeysToReplaceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityKeysToReplaceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityKeysToReplaceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityKeysToReplaceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityKeysToReplaceRequest} IdentityKeysToReplaceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityKeysToReplaceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityKeysToReplaceRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.encryption = $root.api.IdentityEncryption.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.signChain = reader.bytes();
                    break;
                case 4:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.api.IdentityShareEntry.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityKeysToReplaceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityKeysToReplaceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityKeysToReplaceRequest} IdentityKeysToReplaceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityKeysToReplaceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityKeysToReplaceRequest message.
         * @function verify
         * @memberof api.IdentityKeysToReplaceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityKeysToReplaceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.api.IdentityEncryption.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                if (!(message.signChain && typeof message.signChain.length === "number" || $util.isString(message.signChain)))
                    return "signChain: buffer expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.api.IdentityShareEntry.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityKeysToReplaceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityKeysToReplaceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityKeysToReplaceRequest} IdentityKeysToReplaceRequest
         */
        IdentityKeysToReplaceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityKeysToReplaceRequest)
                return object;
            var message = new $root.api.IdentityKeysToReplaceRequest();
            if (object.login != null)
                message.login = String(object.login);
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".api.IdentityKeysToReplaceRequest.encryption: object expected");
                message.encryption = $root.api.IdentityEncryption.fromObject(object.encryption);
            }
            if (object.signChain != null)
                if (typeof object.signChain === "string")
                    $util.base64.decode(object.signChain, message.signChain = $util.newBuffer($util.base64.length(object.signChain)), 0);
                else if (object.signChain.length)
                    message.signChain = object.signChain;
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".api.IdentityKeysToReplaceRequest.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".api.IdentityKeysToReplaceRequest.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.api.IdentityShareEntry.fromObject(object.sharingGroup[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityKeysToReplaceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityKeysToReplaceRequest
         * @static
         * @param {api.IdentityKeysToReplaceRequest} message IdentityKeysToReplaceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityKeysToReplaceRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults) {
                object.login = "";
                object.encryption = null;
                if (options.bytes === String)
                    object.signChain = "";
                else {
                    object.signChain = [];
                    if (options.bytes !== Array)
                        object.signChain = $util.newBuffer(object.signChain);
                }
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.api.IdentityEncryption.toObject(message.encryption, options);
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                object.signChain = options.bytes === String ? $util.base64.encode(message.signChain, 0, message.signChain.length) : options.bytes === Array ? Array.prototype.slice.call(message.signChain) : message.signChain;
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.api.IdentityShareEntry.toObject(message.sharingGroup[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityKeysToReplaceRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityKeysToReplaceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityKeysToReplaceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityKeysToReplaceRequest;
    })();

    api.IdentityListOptions = (function() {

        /**
         * Properties of an IdentityListOptions.
         * @memberof api
         * @interface IIdentityListOptions
         * @property {number|null} [offset] IdentityListOptions offset
         * @property {number|null} [limit] IdentityListOptions limit
         * @property {string|null} [loginPrefix] IdentityListOptions loginPrefix
         * @property {string|null} [kind] IdentityListOptions kind
         * @property {api.IdentitySortingField|null} [sortedBy] IdentityListOptions sortedBy
         * @property {api.SortingOrder|null} [order] IdentityListOptions order
         */

        /**
         * Constructs a new IdentityListOptions.
         * @memberof api
         * @classdesc Represents an IdentityListOptions.
         * @implements IIdentityListOptions
         * @constructor
         * @param {api.IIdentityListOptions=} [properties] Properties to set
         */
        function IdentityListOptions(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityListOptions offset.
         * @member {number} offset
         * @memberof api.IdentityListOptions
         * @instance
         */
        IdentityListOptions.prototype.offset = 0;

        /**
         * IdentityListOptions limit.
         * @member {number} limit
         * @memberof api.IdentityListOptions
         * @instance
         */
        IdentityListOptions.prototype.limit = 0;

        /**
         * IdentityListOptions loginPrefix.
         * @member {string} loginPrefix
         * @memberof api.IdentityListOptions
         * @instance
         */
        IdentityListOptions.prototype.loginPrefix = "";

        /**
         * IdentityListOptions kind.
         * @member {string} kind
         * @memberof api.IdentityListOptions
         * @instance
         */
        IdentityListOptions.prototype.kind = "";

        /**
         * IdentityListOptions sortedBy.
         * @member {api.IdentitySortingField} sortedBy
         * @memberof api.IdentityListOptions
         * @instance
         */
        IdentityListOptions.prototype.sortedBy = 0;

        /**
         * IdentityListOptions order.
         * @member {api.SortingOrder} order
         * @memberof api.IdentityListOptions
         * @instance
         */
        IdentityListOptions.prototype.order = 0;

        /**
         * Creates a new IdentityListOptions instance using the specified properties.
         * @function create
         * @memberof api.IdentityListOptions
         * @static
         * @param {api.IIdentityListOptions=} [properties] Properties to set
         * @returns {api.IdentityListOptions} IdentityListOptions instance
         */
        IdentityListOptions.create = function create(properties) {
            return new IdentityListOptions(properties);
        };

        /**
         * Encodes the specified IdentityListOptions message. Does not implicitly {@link api.IdentityListOptions.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityListOptions
         * @static
         * @param {api.IIdentityListOptions} message IdentityListOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityListOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.offset != null && message.hasOwnProperty("offset"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.offset);
            if (message.limit != null && message.hasOwnProperty("limit"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.limit);
            if (message.loginPrefix != null && message.hasOwnProperty("loginPrefix"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.loginPrefix);
            if (message.kind != null && message.hasOwnProperty("kind"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.kind);
            if (message.sortedBy != null && message.hasOwnProperty("sortedBy"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.sortedBy);
            if (message.order != null && message.hasOwnProperty("order"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.order);
            return writer;
        };

        /**
         * Encodes the specified IdentityListOptions message, length delimited. Does not implicitly {@link api.IdentityListOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityListOptions
         * @static
         * @param {api.IIdentityListOptions} message IdentityListOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityListOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityListOptions message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityListOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityListOptions} IdentityListOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityListOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityListOptions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.offset = reader.uint32();
                    break;
                case 2:
                    message.limit = reader.uint32();
                    break;
                case 3:
                    message.loginPrefix = reader.string();
                    break;
                case 4:
                    message.kind = reader.string();
                    break;
                case 5:
                    message.sortedBy = reader.int32();
                    break;
                case 6:
                    message.order = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityListOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityListOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityListOptions} IdentityListOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityListOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityListOptions message.
         * @function verify
         * @memberof api.IdentityListOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityListOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.offset != null && message.hasOwnProperty("offset"))
                if (!$util.isInteger(message.offset))
                    return "offset: integer expected";
            if (message.limit != null && message.hasOwnProperty("limit"))
                if (!$util.isInteger(message.limit))
                    return "limit: integer expected";
            if (message.loginPrefix != null && message.hasOwnProperty("loginPrefix"))
                if (!$util.isString(message.loginPrefix))
                    return "loginPrefix: string expected";
            if (message.kind != null && message.hasOwnProperty("kind"))
                if (!$util.isString(message.kind))
                    return "kind: string expected";
            if (message.sortedBy != null && message.hasOwnProperty("sortedBy"))
                switch (message.sortedBy) {
                default:
                    return "sortedBy: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.order != null && message.hasOwnProperty("order"))
                switch (message.order) {
                default:
                    return "order: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates an IdentityListOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityListOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityListOptions} IdentityListOptions
         */
        IdentityListOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityListOptions)
                return object;
            var message = new $root.api.IdentityListOptions();
            if (object.offset != null)
                message.offset = object.offset >>> 0;
            if (object.limit != null)
                message.limit = object.limit >>> 0;
            if (object.loginPrefix != null)
                message.loginPrefix = String(object.loginPrefix);
            if (object.kind != null)
                message.kind = String(object.kind);
            switch (object.sortedBy) {
            case "LOGIN":
            case 0:
                message.sortedBy = 0;
                break;
            case "CREATED":
            case 1:
                message.sortedBy = 1;
                break;
            case "KIND":
            case 2:
                message.sortedBy = 2;
                break;
            }
            switch (object.order) {
            case "DESC":
            case 0:
                message.order = 0;
                break;
            case "ASC":
            case 1:
                message.order = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityListOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityListOptions
         * @static
         * @param {api.IdentityListOptions} message IdentityListOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityListOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.offset = 0;
                object.limit = 0;
                object.loginPrefix = "";
                object.kind = "";
                object.sortedBy = options.enums === String ? "LOGIN" : 0;
                object.order = options.enums === String ? "DESC" : 0;
            }
            if (message.offset != null && message.hasOwnProperty("offset"))
                object.offset = message.offset;
            if (message.limit != null && message.hasOwnProperty("limit"))
                object.limit = message.limit;
            if (message.loginPrefix != null && message.hasOwnProperty("loginPrefix"))
                object.loginPrefix = message.loginPrefix;
            if (message.kind != null && message.hasOwnProperty("kind"))
                object.kind = message.kind;
            if (message.sortedBy != null && message.hasOwnProperty("sortedBy"))
                object.sortedBy = options.enums === String ? $root.api.IdentitySortingField[message.sortedBy] : message.sortedBy;
            if (message.order != null && message.hasOwnProperty("order"))
                object.order = options.enums === String ? $root.api.SortingOrder[message.order] : message.order;
            return object;
        };

        /**
         * Converts this IdentityListOptions to JSON.
         * @function toJSON
         * @memberof api.IdentityListOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityListOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityListOptions;
    })();

    api.IdentityListRequest = (function() {

        /**
         * Properties of an IdentityListRequest.
         * @memberof api
         * @interface IIdentityListRequest
         * @property {api.IIdentityListOptions|null} [options] IdentityListRequest options
         */

        /**
         * Constructs a new IdentityListRequest.
         * @memberof api
         * @classdesc Represents an IdentityListRequest.
         * @implements IIdentityListRequest
         * @constructor
         * @param {api.IIdentityListRequest=} [properties] Properties to set
         */
        function IdentityListRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityListRequest options.
         * @member {api.IIdentityListOptions|null|undefined} options
         * @memberof api.IdentityListRequest
         * @instance
         */
        IdentityListRequest.prototype.options = null;

        /**
         * Creates a new IdentityListRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityListRequest
         * @static
         * @param {api.IIdentityListRequest=} [properties] Properties to set
         * @returns {api.IdentityListRequest} IdentityListRequest instance
         */
        IdentityListRequest.create = function create(properties) {
            return new IdentityListRequest(properties);
        };

        /**
         * Encodes the specified IdentityListRequest message. Does not implicitly {@link api.IdentityListRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityListRequest
         * @static
         * @param {api.IIdentityListRequest} message IdentityListRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityListRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.options != null && message.hasOwnProperty("options"))
                $root.api.IdentityListOptions.encode(message.options, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityListRequest message, length delimited. Does not implicitly {@link api.IdentityListRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityListRequest
         * @static
         * @param {api.IIdentityListRequest} message IdentityListRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityListRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityListRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityListRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityListRequest} IdentityListRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityListRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityListRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.options = $root.api.IdentityListOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityListRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityListRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityListRequest} IdentityListRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityListRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityListRequest message.
         * @function verify
         * @memberof api.IdentityListRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityListRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.api.IdentityListOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            return null;
        };

        /**
         * Creates an IdentityListRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityListRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityListRequest} IdentityListRequest
         */
        IdentityListRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityListRequest)
                return object;
            var message = new $root.api.IdentityListRequest();
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".api.IdentityListRequest.options: object expected");
                message.options = $root.api.IdentityListOptions.fromObject(object.options);
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityListRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityListRequest
         * @static
         * @param {api.IdentityListRequest} message IdentityListRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityListRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.options = null;
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.api.IdentityListOptions.toObject(message.options, options);
            return object;
        };

        /**
         * Converts this IdentityListRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityListRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityListRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityListRequest;
    })();

    api.IdentityListResponse = (function() {

        /**
         * Properties of an IdentityListResponse.
         * @memberof api
         * @interface IIdentityListResponse
         * @property {Array.<api.IIdentity>|null} [identities] IdentityListResponse identities
         * @property {number|null} [totalIdentitiesCount] IdentityListResponse totalIdentitiesCount
         */

        /**
         * Constructs a new IdentityListResponse.
         * @memberof api
         * @classdesc Represents an IdentityListResponse.
         * @implements IIdentityListResponse
         * @constructor
         * @param {api.IIdentityListResponse=} [properties] Properties to set
         */
        function IdentityListResponse(properties) {
            this.identities = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityListResponse identities.
         * @member {Array.<api.IIdentity>} identities
         * @memberof api.IdentityListResponse
         * @instance
         */
        IdentityListResponse.prototype.identities = $util.emptyArray;

        /**
         * IdentityListResponse totalIdentitiesCount.
         * @member {number} totalIdentitiesCount
         * @memberof api.IdentityListResponse
         * @instance
         */
        IdentityListResponse.prototype.totalIdentitiesCount = 0;

        /**
         * Creates a new IdentityListResponse instance using the specified properties.
         * @function create
         * @memberof api.IdentityListResponse
         * @static
         * @param {api.IIdentityListResponse=} [properties] Properties to set
         * @returns {api.IdentityListResponse} IdentityListResponse instance
         */
        IdentityListResponse.create = function create(properties) {
            return new IdentityListResponse(properties);
        };

        /**
         * Encodes the specified IdentityListResponse message. Does not implicitly {@link api.IdentityListResponse.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityListResponse
         * @static
         * @param {api.IIdentityListResponse} message IdentityListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityListResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.identities != null && message.identities.length)
                for (var i = 0; i < message.identities.length; ++i)
                    $root.api.Identity.encode(message.identities[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.totalIdentitiesCount != null && message.hasOwnProperty("totalIdentitiesCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.totalIdentitiesCount);
            return writer;
        };

        /**
         * Encodes the specified IdentityListResponse message, length delimited. Does not implicitly {@link api.IdentityListResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityListResponse
         * @static
         * @param {api.IIdentityListResponse} message IdentityListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityListResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityListResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityListResponse} IdentityListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityListResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityListResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.identities && message.identities.length))
                        message.identities = [];
                    message.identities.push($root.api.Identity.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.totalIdentitiesCount = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityListResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityListResponse} IdentityListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityListResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityListResponse message.
         * @function verify
         * @memberof api.IdentityListResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityListResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.identities != null && message.hasOwnProperty("identities")) {
                if (!Array.isArray(message.identities))
                    return "identities: array expected";
                for (var i = 0; i < message.identities.length; ++i) {
                    var error = $root.api.Identity.verify(message.identities[i]);
                    if (error)
                        return "identities." + error;
                }
            }
            if (message.totalIdentitiesCount != null && message.hasOwnProperty("totalIdentitiesCount"))
                if (!$util.isInteger(message.totalIdentitiesCount))
                    return "totalIdentitiesCount: integer expected";
            return null;
        };

        /**
         * Creates an IdentityListResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityListResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityListResponse} IdentityListResponse
         */
        IdentityListResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityListResponse)
                return object;
            var message = new $root.api.IdentityListResponse();
            if (object.identities) {
                if (!Array.isArray(object.identities))
                    throw TypeError(".api.IdentityListResponse.identities: array expected");
                message.identities = [];
                for (var i = 0; i < object.identities.length; ++i) {
                    if (typeof object.identities[i] !== "object")
                        throw TypeError(".api.IdentityListResponse.identities: object expected");
                    message.identities[i] = $root.api.Identity.fromObject(object.identities[i]);
                }
            }
            if (object.totalIdentitiesCount != null)
                message.totalIdentitiesCount = object.totalIdentitiesCount >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an IdentityListResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityListResponse
         * @static
         * @param {api.IdentityListResponse} message IdentityListResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityListResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.identities = [];
            if (options.defaults)
                object.totalIdentitiesCount = 0;
            if (message.identities && message.identities.length) {
                object.identities = [];
                for (var j = 0; j < message.identities.length; ++j)
                    object.identities[j] = $root.api.Identity.toObject(message.identities[j], options);
            }
            if (message.totalIdentitiesCount != null && message.hasOwnProperty("totalIdentitiesCount"))
                object.totalIdentitiesCount = message.totalIdentitiesCount;
            return object;
        };

        /**
         * Converts this IdentityListResponse to JSON.
         * @function toJSON
         * @memberof api.IdentityListResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityListResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityListResponse;
    })();

    api.ApplicationListIdentitiesRequest = (function() {

        /**
         * Properties of an ApplicationListIdentitiesRequest.
         * @memberof api
         * @interface IApplicationListIdentitiesRequest
         * @property {string|null} [appID] ApplicationListIdentitiesRequest appID
         * @property {api.IIdentityListOptions|null} [options] ApplicationListIdentitiesRequest options
         */

        /**
         * Constructs a new ApplicationListIdentitiesRequest.
         * @memberof api
         * @classdesc Represents an ApplicationListIdentitiesRequest.
         * @implements IApplicationListIdentitiesRequest
         * @constructor
         * @param {api.IApplicationListIdentitiesRequest=} [properties] Properties to set
         */
        function ApplicationListIdentitiesRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApplicationListIdentitiesRequest appID.
         * @member {string} appID
         * @memberof api.ApplicationListIdentitiesRequest
         * @instance
         */
        ApplicationListIdentitiesRequest.prototype.appID = "";

        /**
         * ApplicationListIdentitiesRequest options.
         * @member {api.IIdentityListOptions|null|undefined} options
         * @memberof api.ApplicationListIdentitiesRequest
         * @instance
         */
        ApplicationListIdentitiesRequest.prototype.options = null;

        /**
         * Creates a new ApplicationListIdentitiesRequest instance using the specified properties.
         * @function create
         * @memberof api.ApplicationListIdentitiesRequest
         * @static
         * @param {api.IApplicationListIdentitiesRequest=} [properties] Properties to set
         * @returns {api.ApplicationListIdentitiesRequest} ApplicationListIdentitiesRequest instance
         */
        ApplicationListIdentitiesRequest.create = function create(properties) {
            return new ApplicationListIdentitiesRequest(properties);
        };

        /**
         * Encodes the specified ApplicationListIdentitiesRequest message. Does not implicitly {@link api.ApplicationListIdentitiesRequest.verify|verify} messages.
         * @function encode
         * @memberof api.ApplicationListIdentitiesRequest
         * @static
         * @param {api.IApplicationListIdentitiesRequest} message ApplicationListIdentitiesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationListIdentitiesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.appID != null && message.hasOwnProperty("appID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.appID);
            if (message.options != null && message.hasOwnProperty("options"))
                $root.api.IdentityListOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ApplicationListIdentitiesRequest message, length delimited. Does not implicitly {@link api.ApplicationListIdentitiesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ApplicationListIdentitiesRequest
         * @static
         * @param {api.IApplicationListIdentitiesRequest} message ApplicationListIdentitiesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationListIdentitiesRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApplicationListIdentitiesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.ApplicationListIdentitiesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ApplicationListIdentitiesRequest} ApplicationListIdentitiesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationListIdentitiesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ApplicationListIdentitiesRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.appID = reader.string();
                    break;
                case 2:
                    message.options = $root.api.IdentityListOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApplicationListIdentitiesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ApplicationListIdentitiesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ApplicationListIdentitiesRequest} ApplicationListIdentitiesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationListIdentitiesRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApplicationListIdentitiesRequest message.
         * @function verify
         * @memberof api.ApplicationListIdentitiesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApplicationListIdentitiesRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.appID != null && message.hasOwnProperty("appID"))
                if (!$util.isString(message.appID))
                    return "appID: string expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.api.IdentityListOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            return null;
        };

        /**
         * Creates an ApplicationListIdentitiesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ApplicationListIdentitiesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ApplicationListIdentitiesRequest} ApplicationListIdentitiesRequest
         */
        ApplicationListIdentitiesRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ApplicationListIdentitiesRequest)
                return object;
            var message = new $root.api.ApplicationListIdentitiesRequest();
            if (object.appID != null)
                message.appID = String(object.appID);
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".api.ApplicationListIdentitiesRequest.options: object expected");
                message.options = $root.api.IdentityListOptions.fromObject(object.options);
            }
            return message;
        };

        /**
         * Creates a plain object from an ApplicationListIdentitiesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ApplicationListIdentitiesRequest
         * @static
         * @param {api.ApplicationListIdentitiesRequest} message ApplicationListIdentitiesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApplicationListIdentitiesRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.appID = "";
                object.options = null;
            }
            if (message.appID != null && message.hasOwnProperty("appID"))
                object.appID = message.appID;
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.api.IdentityListOptions.toObject(message.options, options);
            return object;
        };

        /**
         * Converts this ApplicationListIdentitiesRequest to JSON.
         * @function toJSON
         * @memberof api.ApplicationListIdentitiesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApplicationListIdentitiesRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApplicationListIdentitiesRequest;
    })();

    api.ApplicationListIdentitiesResponse = (function() {

        /**
         * Properties of an ApplicationListIdentitiesResponse.
         * @memberof api
         * @interface IApplicationListIdentitiesResponse
         * @property {Array.<api.IApplicationIdentity>|null} [identities] ApplicationListIdentitiesResponse identities
         * @property {number|null} [totalIdentitiesCount] ApplicationListIdentitiesResponse totalIdentitiesCount
         */

        /**
         * Constructs a new ApplicationListIdentitiesResponse.
         * @memberof api
         * @classdesc Represents an ApplicationListIdentitiesResponse.
         * @implements IApplicationListIdentitiesResponse
         * @constructor
         * @param {api.IApplicationListIdentitiesResponse=} [properties] Properties to set
         */
        function ApplicationListIdentitiesResponse(properties) {
            this.identities = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApplicationListIdentitiesResponse identities.
         * @member {Array.<api.IApplicationIdentity>} identities
         * @memberof api.ApplicationListIdentitiesResponse
         * @instance
         */
        ApplicationListIdentitiesResponse.prototype.identities = $util.emptyArray;

        /**
         * ApplicationListIdentitiesResponse totalIdentitiesCount.
         * @member {number} totalIdentitiesCount
         * @memberof api.ApplicationListIdentitiesResponse
         * @instance
         */
        ApplicationListIdentitiesResponse.prototype.totalIdentitiesCount = 0;

        /**
         * Creates a new ApplicationListIdentitiesResponse instance using the specified properties.
         * @function create
         * @memberof api.ApplicationListIdentitiesResponse
         * @static
         * @param {api.IApplicationListIdentitiesResponse=} [properties] Properties to set
         * @returns {api.ApplicationListIdentitiesResponse} ApplicationListIdentitiesResponse instance
         */
        ApplicationListIdentitiesResponse.create = function create(properties) {
            return new ApplicationListIdentitiesResponse(properties);
        };

        /**
         * Encodes the specified ApplicationListIdentitiesResponse message. Does not implicitly {@link api.ApplicationListIdentitiesResponse.verify|verify} messages.
         * @function encode
         * @memberof api.ApplicationListIdentitiesResponse
         * @static
         * @param {api.IApplicationListIdentitiesResponse} message ApplicationListIdentitiesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationListIdentitiesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.identities != null && message.identities.length)
                for (var i = 0; i < message.identities.length; ++i)
                    $root.api.ApplicationIdentity.encode(message.identities[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.totalIdentitiesCount != null && message.hasOwnProperty("totalIdentitiesCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.totalIdentitiesCount);
            return writer;
        };

        /**
         * Encodes the specified ApplicationListIdentitiesResponse message, length delimited. Does not implicitly {@link api.ApplicationListIdentitiesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ApplicationListIdentitiesResponse
         * @static
         * @param {api.IApplicationListIdentitiesResponse} message ApplicationListIdentitiesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationListIdentitiesResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApplicationListIdentitiesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.ApplicationListIdentitiesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ApplicationListIdentitiesResponse} ApplicationListIdentitiesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationListIdentitiesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ApplicationListIdentitiesResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.identities && message.identities.length))
                        message.identities = [];
                    message.identities.push($root.api.ApplicationIdentity.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.totalIdentitiesCount = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApplicationListIdentitiesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ApplicationListIdentitiesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ApplicationListIdentitiesResponse} ApplicationListIdentitiesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationListIdentitiesResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApplicationListIdentitiesResponse message.
         * @function verify
         * @memberof api.ApplicationListIdentitiesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApplicationListIdentitiesResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.identities != null && message.hasOwnProperty("identities")) {
                if (!Array.isArray(message.identities))
                    return "identities: array expected";
                for (var i = 0; i < message.identities.length; ++i) {
                    var error = $root.api.ApplicationIdentity.verify(message.identities[i]);
                    if (error)
                        return "identities." + error;
                }
            }
            if (message.totalIdentitiesCount != null && message.hasOwnProperty("totalIdentitiesCount"))
                if (!$util.isInteger(message.totalIdentitiesCount))
                    return "totalIdentitiesCount: integer expected";
            return null;
        };

        /**
         * Creates an ApplicationListIdentitiesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ApplicationListIdentitiesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ApplicationListIdentitiesResponse} ApplicationListIdentitiesResponse
         */
        ApplicationListIdentitiesResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ApplicationListIdentitiesResponse)
                return object;
            var message = new $root.api.ApplicationListIdentitiesResponse();
            if (object.identities) {
                if (!Array.isArray(object.identities))
                    throw TypeError(".api.ApplicationListIdentitiesResponse.identities: array expected");
                message.identities = [];
                for (var i = 0; i < object.identities.length; ++i) {
                    if (typeof object.identities[i] !== "object")
                        throw TypeError(".api.ApplicationListIdentitiesResponse.identities: object expected");
                    message.identities[i] = $root.api.ApplicationIdentity.fromObject(object.identities[i]);
                }
            }
            if (object.totalIdentitiesCount != null)
                message.totalIdentitiesCount = object.totalIdentitiesCount >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an ApplicationListIdentitiesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ApplicationListIdentitiesResponse
         * @static
         * @param {api.ApplicationListIdentitiesResponse} message ApplicationListIdentitiesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApplicationListIdentitiesResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.identities = [];
            if (options.defaults)
                object.totalIdentitiesCount = 0;
            if (message.identities && message.identities.length) {
                object.identities = [];
                for (var j = 0; j < message.identities.length; ++j)
                    object.identities[j] = $root.api.ApplicationIdentity.toObject(message.identities[j], options);
            }
            if (message.totalIdentitiesCount != null && message.hasOwnProperty("totalIdentitiesCount"))
                object.totalIdentitiesCount = message.totalIdentitiesCount;
            return object;
        };

        /**
         * Converts this ApplicationListIdentitiesResponse to JSON.
         * @function toJSON
         * @memberof api.ApplicationListIdentitiesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApplicationListIdentitiesResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApplicationListIdentitiesResponse;
    })();

    api.IdentityPromoteRequest = (function() {

        /**
         * Properties of an IdentityPromoteRequest.
         * @memberof api
         * @interface IIdentityPromoteRequest
         * @property {string|null} [login] IdentityPromoteRequest login
         * @property {boolean|null} [admin] IdentityPromoteRequest admin
         */

        /**
         * Constructs a new IdentityPromoteRequest.
         * @memberof api
         * @classdesc Represents an IdentityPromoteRequest.
         * @implements IIdentityPromoteRequest
         * @constructor
         * @param {api.IIdentityPromoteRequest=} [properties] Properties to set
         */
        function IdentityPromoteRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityPromoteRequest login.
         * @member {string} login
         * @memberof api.IdentityPromoteRequest
         * @instance
         */
        IdentityPromoteRequest.prototype.login = "";

        /**
         * IdentityPromoteRequest admin.
         * @member {boolean} admin
         * @memberof api.IdentityPromoteRequest
         * @instance
         */
        IdentityPromoteRequest.prototype.admin = false;

        /**
         * Creates a new IdentityPromoteRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityPromoteRequest
         * @static
         * @param {api.IIdentityPromoteRequest=} [properties] Properties to set
         * @returns {api.IdentityPromoteRequest} IdentityPromoteRequest instance
         */
        IdentityPromoteRequest.create = function create(properties) {
            return new IdentityPromoteRequest(properties);
        };

        /**
         * Encodes the specified IdentityPromoteRequest message. Does not implicitly {@link api.IdentityPromoteRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityPromoteRequest
         * @static
         * @param {api.IIdentityPromoteRequest} message IdentityPromoteRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPromoteRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.admin != null && message.hasOwnProperty("admin"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.admin);
            return writer;
        };

        /**
         * Encodes the specified IdentityPromoteRequest message, length delimited. Does not implicitly {@link api.IdentityPromoteRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityPromoteRequest
         * @static
         * @param {api.IIdentityPromoteRequest} message IdentityPromoteRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPromoteRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityPromoteRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityPromoteRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityPromoteRequest} IdentityPromoteRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPromoteRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityPromoteRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.admin = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityPromoteRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityPromoteRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityPromoteRequest} IdentityPromoteRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPromoteRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityPromoteRequest message.
         * @function verify
         * @memberof api.IdentityPromoteRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityPromoteRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.admin != null && message.hasOwnProperty("admin"))
                if (typeof message.admin !== "boolean")
                    return "admin: boolean expected";
            return null;
        };

        /**
         * Creates an IdentityPromoteRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityPromoteRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityPromoteRequest} IdentityPromoteRequest
         */
        IdentityPromoteRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityPromoteRequest)
                return object;
            var message = new $root.api.IdentityPromoteRequest();
            if (object.login != null)
                message.login = String(object.login);
            if (object.admin != null)
                message.admin = Boolean(object.admin);
            return message;
        };

        /**
         * Creates a plain object from an IdentityPromoteRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityPromoteRequest
         * @static
         * @param {api.IdentityPromoteRequest} message IdentityPromoteRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityPromoteRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.admin = false;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.admin != null && message.hasOwnProperty("admin"))
                object.admin = message.admin;
            return object;
        };

        /**
         * Converts this IdentityPromoteRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityPromoteRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityPromoteRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityPromoteRequest;
    })();

    api.IdentityGetKeysResponse = (function() {

        /**
         * Properties of an IdentityGetKeysResponse.
         * @memberof api
         * @interface IIdentityGetKeysResponse
         * @property {Array.<api.ICipher>|null} [sharingKey] IdentityGetKeysResponse sharingKey
         * @property {api.ICipher|null} [signKey] IdentityGetKeysResponse signKey
         * @property {api.ICipher|null} [boxKey] IdentityGetKeysResponse boxKey
         * @property {api.ICipher|null} [readKey] IdentityGetKeysResponse readKey
         * @property {number|null} [version] IdentityGetKeysResponse version
         */

        /**
         * Constructs a new IdentityGetKeysResponse.
         * @memberof api
         * @classdesc Represents an IdentityGetKeysResponse.
         * @implements IIdentityGetKeysResponse
         * @constructor
         * @param {api.IIdentityGetKeysResponse=} [properties] Properties to set
         */
        function IdentityGetKeysResponse(properties) {
            this.sharingKey = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetKeysResponse sharingKey.
         * @member {Array.<api.ICipher>} sharingKey
         * @memberof api.IdentityGetKeysResponse
         * @instance
         */
        IdentityGetKeysResponse.prototype.sharingKey = $util.emptyArray;

        /**
         * IdentityGetKeysResponse signKey.
         * @member {api.ICipher|null|undefined} signKey
         * @memberof api.IdentityGetKeysResponse
         * @instance
         */
        IdentityGetKeysResponse.prototype.signKey = null;

        /**
         * IdentityGetKeysResponse boxKey.
         * @member {api.ICipher|null|undefined} boxKey
         * @memberof api.IdentityGetKeysResponse
         * @instance
         */
        IdentityGetKeysResponse.prototype.boxKey = null;

        /**
         * IdentityGetKeysResponse readKey.
         * @member {api.ICipher|null|undefined} readKey
         * @memberof api.IdentityGetKeysResponse
         * @instance
         */
        IdentityGetKeysResponse.prototype.readKey = null;

        /**
         * IdentityGetKeysResponse version.
         * @member {number} version
         * @memberof api.IdentityGetKeysResponse
         * @instance
         */
        IdentityGetKeysResponse.prototype.version = 0;

        /**
         * Creates a new IdentityGetKeysResponse instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetKeysResponse
         * @static
         * @param {api.IIdentityGetKeysResponse=} [properties] Properties to set
         * @returns {api.IdentityGetKeysResponse} IdentityGetKeysResponse instance
         */
        IdentityGetKeysResponse.create = function create(properties) {
            return new IdentityGetKeysResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetKeysResponse message. Does not implicitly {@link api.IdentityGetKeysResponse.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetKeysResponse
         * @static
         * @param {api.IIdentityGetKeysResponse} message IdentityGetKeysResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetKeysResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sharingKey != null && message.sharingKey.length)
                for (var i = 0; i < message.sharingKey.length; ++i)
                    $root.api.Cipher.encode(message.sharingKey[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.signKey != null && message.hasOwnProperty("signKey"))
                $root.api.Cipher.encode(message.signKey, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.boxKey != null && message.hasOwnProperty("boxKey"))
                $root.api.Cipher.encode(message.boxKey, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.readKey != null && message.hasOwnProperty("readKey"))
                $root.api.Cipher.encode(message.readKey, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.version);
            return writer;
        };

        /**
         * Encodes the specified IdentityGetKeysResponse message, length delimited. Does not implicitly {@link api.IdentityGetKeysResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetKeysResponse
         * @static
         * @param {api.IIdentityGetKeysResponse} message IdentityGetKeysResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetKeysResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetKeysResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetKeysResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetKeysResponse} IdentityGetKeysResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetKeysResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetKeysResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.sharingKey && message.sharingKey.length))
                        message.sharingKey = [];
                    message.sharingKey.push($root.api.Cipher.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.signKey = $root.api.Cipher.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.boxKey = $root.api.Cipher.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.readKey = $root.api.Cipher.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.version = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetKeysResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetKeysResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetKeysResponse} IdentityGetKeysResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetKeysResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetKeysResponse message.
         * @function verify
         * @memberof api.IdentityGetKeysResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetKeysResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sharingKey != null && message.hasOwnProperty("sharingKey")) {
                if (!Array.isArray(message.sharingKey))
                    return "sharingKey: array expected";
                for (var i = 0; i < message.sharingKey.length; ++i) {
                    var error = $root.api.Cipher.verify(message.sharingKey[i]);
                    if (error)
                        return "sharingKey." + error;
                }
            }
            if (message.signKey != null && message.hasOwnProperty("signKey")) {
                var error = $root.api.Cipher.verify(message.signKey);
                if (error)
                    return "signKey." + error;
            }
            if (message.boxKey != null && message.hasOwnProperty("boxKey")) {
                var error = $root.api.Cipher.verify(message.boxKey);
                if (error)
                    return "boxKey." + error;
            }
            if (message.readKey != null && message.hasOwnProperty("readKey")) {
                var error = $root.api.Cipher.verify(message.readKey);
                if (error)
                    return "readKey." + error;
            }
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            return null;
        };

        /**
         * Creates an IdentityGetKeysResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetKeysResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetKeysResponse} IdentityGetKeysResponse
         */
        IdentityGetKeysResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetKeysResponse)
                return object;
            var message = new $root.api.IdentityGetKeysResponse();
            if (object.sharingKey) {
                if (!Array.isArray(object.sharingKey))
                    throw TypeError(".api.IdentityGetKeysResponse.sharingKey: array expected");
                message.sharingKey = [];
                for (var i = 0; i < object.sharingKey.length; ++i) {
                    if (typeof object.sharingKey[i] !== "object")
                        throw TypeError(".api.IdentityGetKeysResponse.sharingKey: object expected");
                    message.sharingKey[i] = $root.api.Cipher.fromObject(object.sharingKey[i]);
                }
            }
            if (object.signKey != null) {
                if (typeof object.signKey !== "object")
                    throw TypeError(".api.IdentityGetKeysResponse.signKey: object expected");
                message.signKey = $root.api.Cipher.fromObject(object.signKey);
            }
            if (object.boxKey != null) {
                if (typeof object.boxKey !== "object")
                    throw TypeError(".api.IdentityGetKeysResponse.boxKey: object expected");
                message.boxKey = $root.api.Cipher.fromObject(object.boxKey);
            }
            if (object.readKey != null) {
                if (typeof object.readKey !== "object")
                    throw TypeError(".api.IdentityGetKeysResponse.readKey: object expected");
                message.readKey = $root.api.Cipher.fromObject(object.readKey);
            }
            if (object.version != null)
                message.version = object.version >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetKeysResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetKeysResponse
         * @static
         * @param {api.IdentityGetKeysResponse} message IdentityGetKeysResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetKeysResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingKey = [];
            if (options.defaults) {
                object.signKey = null;
                object.boxKey = null;
                object.readKey = null;
                object.version = 0;
            }
            if (message.sharingKey && message.sharingKey.length) {
                object.sharingKey = [];
                for (var j = 0; j < message.sharingKey.length; ++j)
                    object.sharingKey[j] = $root.api.Cipher.toObject(message.sharingKey[j], options);
            }
            if (message.signKey != null && message.hasOwnProperty("signKey"))
                object.signKey = $root.api.Cipher.toObject(message.signKey, options);
            if (message.boxKey != null && message.hasOwnProperty("boxKey"))
                object.boxKey = $root.api.Cipher.toObject(message.boxKey, options);
            if (message.readKey != null && message.hasOwnProperty("readKey"))
                object.readKey = $root.api.Cipher.toObject(message.readKey, options);
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            return object;
        };

        /**
         * Converts this IdentityGetKeysResponse to JSON.
         * @function toJSON
         * @memberof api.IdentityGetKeysResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetKeysResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetKeysResponse;
    })();

    api.IdentityGetPublicKeysRequest = (function() {

        /**
         * Properties of an IdentityGetPublicKeysRequest.
         * @memberof api
         * @interface IIdentityGetPublicKeysRequest
         * @property {Array.<api.IIdentityKeyID>|null} [ids] IdentityGetPublicKeysRequest ids
         */

        /**
         * Constructs a new IdentityGetPublicKeysRequest.
         * @memberof api
         * @classdesc Represents an IdentityGetPublicKeysRequest.
         * @implements IIdentityGetPublicKeysRequest
         * @constructor
         * @param {api.IIdentityGetPublicKeysRequest=} [properties] Properties to set
         */
        function IdentityGetPublicKeysRequest(properties) {
            this.ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetPublicKeysRequest ids.
         * @member {Array.<api.IIdentityKeyID>} ids
         * @memberof api.IdentityGetPublicKeysRequest
         * @instance
         */
        IdentityGetPublicKeysRequest.prototype.ids = $util.emptyArray;

        /**
         * Creates a new IdentityGetPublicKeysRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetPublicKeysRequest
         * @static
         * @param {api.IIdentityGetPublicKeysRequest=} [properties] Properties to set
         * @returns {api.IdentityGetPublicKeysRequest} IdentityGetPublicKeysRequest instance
         */
        IdentityGetPublicKeysRequest.create = function create(properties) {
            return new IdentityGetPublicKeysRequest(properties);
        };

        /**
         * Encodes the specified IdentityGetPublicKeysRequest message. Does not implicitly {@link api.IdentityGetPublicKeysRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetPublicKeysRequest
         * @static
         * @param {api.IIdentityGetPublicKeysRequest} message IdentityGetPublicKeysRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetPublicKeysRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ids != null && message.ids.length)
                for (var i = 0; i < message.ids.length; ++i)
                    $root.api.IdentityKeyID.encode(message.ids[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetPublicKeysRequest message, length delimited. Does not implicitly {@link api.IdentityGetPublicKeysRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetPublicKeysRequest
         * @static
         * @param {api.IIdentityGetPublicKeysRequest} message IdentityGetPublicKeysRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetPublicKeysRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetPublicKeysRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetPublicKeysRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetPublicKeysRequest} IdentityGetPublicKeysRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetPublicKeysRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetPublicKeysRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ids && message.ids.length))
                        message.ids = [];
                    message.ids.push($root.api.IdentityKeyID.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetPublicKeysRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetPublicKeysRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetPublicKeysRequest} IdentityGetPublicKeysRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetPublicKeysRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetPublicKeysRequest message.
         * @function verify
         * @memberof api.IdentityGetPublicKeysRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetPublicKeysRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ids != null && message.hasOwnProperty("ids")) {
                if (!Array.isArray(message.ids))
                    return "ids: array expected";
                for (var i = 0; i < message.ids.length; ++i) {
                    var error = $root.api.IdentityKeyID.verify(message.ids[i]);
                    if (error)
                        return "ids." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetPublicKeysRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetPublicKeysRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetPublicKeysRequest} IdentityGetPublicKeysRequest
         */
        IdentityGetPublicKeysRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetPublicKeysRequest)
                return object;
            var message = new $root.api.IdentityGetPublicKeysRequest();
            if (object.ids) {
                if (!Array.isArray(object.ids))
                    throw TypeError(".api.IdentityGetPublicKeysRequest.ids: array expected");
                message.ids = [];
                for (var i = 0; i < object.ids.length; ++i) {
                    if (typeof object.ids[i] !== "object")
                        throw TypeError(".api.IdentityGetPublicKeysRequest.ids: object expected");
                    message.ids[i] = $root.api.IdentityKeyID.fromObject(object.ids[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetPublicKeysRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetPublicKeysRequest
         * @static
         * @param {api.IdentityGetPublicKeysRequest} message IdentityGetPublicKeysRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetPublicKeysRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.ids = [];
            if (message.ids && message.ids.length) {
                object.ids = [];
                for (var j = 0; j < message.ids.length; ++j)
                    object.ids[j] = $root.api.IdentityKeyID.toObject(message.ids[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetPublicKeysRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityGetPublicKeysRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetPublicKeysRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetPublicKeysRequest;
    })();

    api.IdentityGetPublicKeysResponse = (function() {

        /**
         * Properties of an IdentityGetPublicKeysResponse.
         * @memberof api
         * @interface IIdentityGetPublicKeysResponse
         * @property {Array.<api.IIdentityPublicKey>|null} [publicKeys] IdentityGetPublicKeysResponse publicKeys
         */

        /**
         * Constructs a new IdentityGetPublicKeysResponse.
         * @memberof api
         * @classdesc Represents an IdentityGetPublicKeysResponse.
         * @implements IIdentityGetPublicKeysResponse
         * @constructor
         * @param {api.IIdentityGetPublicKeysResponse=} [properties] Properties to set
         */
        function IdentityGetPublicKeysResponse(properties) {
            this.publicKeys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetPublicKeysResponse publicKeys.
         * @member {Array.<api.IIdentityPublicKey>} publicKeys
         * @memberof api.IdentityGetPublicKeysResponse
         * @instance
         */
        IdentityGetPublicKeysResponse.prototype.publicKeys = $util.emptyArray;

        /**
         * Creates a new IdentityGetPublicKeysResponse instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetPublicKeysResponse
         * @static
         * @param {api.IIdentityGetPublicKeysResponse=} [properties] Properties to set
         * @returns {api.IdentityGetPublicKeysResponse} IdentityGetPublicKeysResponse instance
         */
        IdentityGetPublicKeysResponse.create = function create(properties) {
            return new IdentityGetPublicKeysResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetPublicKeysResponse message. Does not implicitly {@link api.IdentityGetPublicKeysResponse.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetPublicKeysResponse
         * @static
         * @param {api.IIdentityGetPublicKeysResponse} message IdentityGetPublicKeysResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetPublicKeysResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.publicKeys != null && message.publicKeys.length)
                for (var i = 0; i < message.publicKeys.length; ++i)
                    $root.api.IdentityPublicKey.encode(message.publicKeys[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetPublicKeysResponse message, length delimited. Does not implicitly {@link api.IdentityGetPublicKeysResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetPublicKeysResponse
         * @static
         * @param {api.IIdentityGetPublicKeysResponse} message IdentityGetPublicKeysResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetPublicKeysResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetPublicKeysResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetPublicKeysResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetPublicKeysResponse} IdentityGetPublicKeysResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetPublicKeysResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetPublicKeysResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.publicKeys && message.publicKeys.length))
                        message.publicKeys = [];
                    message.publicKeys.push($root.api.IdentityPublicKey.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetPublicKeysResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetPublicKeysResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetPublicKeysResponse} IdentityGetPublicKeysResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetPublicKeysResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetPublicKeysResponse message.
         * @function verify
         * @memberof api.IdentityGetPublicKeysResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetPublicKeysResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.publicKeys != null && message.hasOwnProperty("publicKeys")) {
                if (!Array.isArray(message.publicKeys))
                    return "publicKeys: array expected";
                for (var i = 0; i < message.publicKeys.length; ++i) {
                    var error = $root.api.IdentityPublicKey.verify(message.publicKeys[i]);
                    if (error)
                        return "publicKeys." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetPublicKeysResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetPublicKeysResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetPublicKeysResponse} IdentityGetPublicKeysResponse
         */
        IdentityGetPublicKeysResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetPublicKeysResponse)
                return object;
            var message = new $root.api.IdentityGetPublicKeysResponse();
            if (object.publicKeys) {
                if (!Array.isArray(object.publicKeys))
                    throw TypeError(".api.IdentityGetPublicKeysResponse.publicKeys: array expected");
                message.publicKeys = [];
                for (var i = 0; i < object.publicKeys.length; ++i) {
                    if (typeof object.publicKeys[i] !== "object")
                        throw TypeError(".api.IdentityGetPublicKeysResponse.publicKeys: object expected");
                    message.publicKeys[i] = $root.api.IdentityPublicKey.fromObject(object.publicKeys[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetPublicKeysResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetPublicKeysResponse
         * @static
         * @param {api.IdentityGetPublicKeysResponse} message IdentityGetPublicKeysResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetPublicKeysResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.publicKeys = [];
            if (message.publicKeys && message.publicKeys.length) {
                object.publicKeys = [];
                for (var j = 0; j < message.publicKeys.length; ++j)
                    object.publicKeys[j] = $root.api.IdentityPublicKey.toObject(message.publicKeys[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetPublicKeysResponse to JSON.
         * @function toJSON
         * @memberof api.IdentityGetPublicKeysResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetPublicKeysResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetPublicKeysResponse;
    })();

    api.IdentityGetLatestPublicKeysRequest = (function() {

        /**
         * Properties of an IdentityGetLatestPublicKeysRequest.
         * @memberof api
         * @interface IIdentityGetLatestPublicKeysRequest
         * @property {Array.<string>|null} [logins] IdentityGetLatestPublicKeysRequest logins
         */

        /**
         * Constructs a new IdentityGetLatestPublicKeysRequest.
         * @memberof api
         * @classdesc Represents an IdentityGetLatestPublicKeysRequest.
         * @implements IIdentityGetLatestPublicKeysRequest
         * @constructor
         * @param {api.IIdentityGetLatestPublicKeysRequest=} [properties] Properties to set
         */
        function IdentityGetLatestPublicKeysRequest(properties) {
            this.logins = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetLatestPublicKeysRequest logins.
         * @member {Array.<string>} logins
         * @memberof api.IdentityGetLatestPublicKeysRequest
         * @instance
         */
        IdentityGetLatestPublicKeysRequest.prototype.logins = $util.emptyArray;

        /**
         * Creates a new IdentityGetLatestPublicKeysRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetLatestPublicKeysRequest
         * @static
         * @param {api.IIdentityGetLatestPublicKeysRequest=} [properties] Properties to set
         * @returns {api.IdentityGetLatestPublicKeysRequest} IdentityGetLatestPublicKeysRequest instance
         */
        IdentityGetLatestPublicKeysRequest.create = function create(properties) {
            return new IdentityGetLatestPublicKeysRequest(properties);
        };

        /**
         * Encodes the specified IdentityGetLatestPublicKeysRequest message. Does not implicitly {@link api.IdentityGetLatestPublicKeysRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetLatestPublicKeysRequest
         * @static
         * @param {api.IIdentityGetLatestPublicKeysRequest} message IdentityGetLatestPublicKeysRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLatestPublicKeysRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.logins != null && message.logins.length)
                for (var i = 0; i < message.logins.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.logins[i]);
            return writer;
        };

        /**
         * Encodes the specified IdentityGetLatestPublicKeysRequest message, length delimited. Does not implicitly {@link api.IdentityGetLatestPublicKeysRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetLatestPublicKeysRequest
         * @static
         * @param {api.IIdentityGetLatestPublicKeysRequest} message IdentityGetLatestPublicKeysRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLatestPublicKeysRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetLatestPublicKeysRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetLatestPublicKeysRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetLatestPublicKeysRequest} IdentityGetLatestPublicKeysRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLatestPublicKeysRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetLatestPublicKeysRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.logins && message.logins.length))
                        message.logins = [];
                    message.logins.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetLatestPublicKeysRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetLatestPublicKeysRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetLatestPublicKeysRequest} IdentityGetLatestPublicKeysRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLatestPublicKeysRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetLatestPublicKeysRequest message.
         * @function verify
         * @memberof api.IdentityGetLatestPublicKeysRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetLatestPublicKeysRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.logins != null && message.hasOwnProperty("logins")) {
                if (!Array.isArray(message.logins))
                    return "logins: array expected";
                for (var i = 0; i < message.logins.length; ++i)
                    if (!$util.isString(message.logins[i]))
                        return "logins: string[] expected";
            }
            return null;
        };

        /**
         * Creates an IdentityGetLatestPublicKeysRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetLatestPublicKeysRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetLatestPublicKeysRequest} IdentityGetLatestPublicKeysRequest
         */
        IdentityGetLatestPublicKeysRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetLatestPublicKeysRequest)
                return object;
            var message = new $root.api.IdentityGetLatestPublicKeysRequest();
            if (object.logins) {
                if (!Array.isArray(object.logins))
                    throw TypeError(".api.IdentityGetLatestPublicKeysRequest.logins: array expected");
                message.logins = [];
                for (var i = 0; i < object.logins.length; ++i)
                    message.logins[i] = String(object.logins[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetLatestPublicKeysRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetLatestPublicKeysRequest
         * @static
         * @param {api.IdentityGetLatestPublicKeysRequest} message IdentityGetLatestPublicKeysRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetLatestPublicKeysRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.logins = [];
            if (message.logins && message.logins.length) {
                object.logins = [];
                for (var j = 0; j < message.logins.length; ++j)
                    object.logins[j] = message.logins[j];
            }
            return object;
        };

        /**
         * Converts this IdentityGetLatestPublicKeysRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityGetLatestPublicKeysRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetLatestPublicKeysRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetLatestPublicKeysRequest;
    })();

    api.IdentityGetLatestPublicKeysResponse = (function() {

        /**
         * Properties of an IdentityGetLatestPublicKeysResponse.
         * @memberof api
         * @interface IIdentityGetLatestPublicKeysResponse
         * @property {Array.<api.IIdentityPublicKey>|null} [publicKeys] IdentityGetLatestPublicKeysResponse publicKeys
         */

        /**
         * Constructs a new IdentityGetLatestPublicKeysResponse.
         * @memberof api
         * @classdesc Represents an IdentityGetLatestPublicKeysResponse.
         * @implements IIdentityGetLatestPublicKeysResponse
         * @constructor
         * @param {api.IIdentityGetLatestPublicKeysResponse=} [properties] Properties to set
         */
        function IdentityGetLatestPublicKeysResponse(properties) {
            this.publicKeys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetLatestPublicKeysResponse publicKeys.
         * @member {Array.<api.IIdentityPublicKey>} publicKeys
         * @memberof api.IdentityGetLatestPublicKeysResponse
         * @instance
         */
        IdentityGetLatestPublicKeysResponse.prototype.publicKeys = $util.emptyArray;

        /**
         * Creates a new IdentityGetLatestPublicKeysResponse instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetLatestPublicKeysResponse
         * @static
         * @param {api.IIdentityGetLatestPublicKeysResponse=} [properties] Properties to set
         * @returns {api.IdentityGetLatestPublicKeysResponse} IdentityGetLatestPublicKeysResponse instance
         */
        IdentityGetLatestPublicKeysResponse.create = function create(properties) {
            return new IdentityGetLatestPublicKeysResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetLatestPublicKeysResponse message. Does not implicitly {@link api.IdentityGetLatestPublicKeysResponse.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetLatestPublicKeysResponse
         * @static
         * @param {api.IIdentityGetLatestPublicKeysResponse} message IdentityGetLatestPublicKeysResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLatestPublicKeysResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.publicKeys != null && message.publicKeys.length)
                for (var i = 0; i < message.publicKeys.length; ++i)
                    $root.api.IdentityPublicKey.encode(message.publicKeys[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetLatestPublicKeysResponse message, length delimited. Does not implicitly {@link api.IdentityGetLatestPublicKeysResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetLatestPublicKeysResponse
         * @static
         * @param {api.IIdentityGetLatestPublicKeysResponse} message IdentityGetLatestPublicKeysResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLatestPublicKeysResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetLatestPublicKeysResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetLatestPublicKeysResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetLatestPublicKeysResponse} IdentityGetLatestPublicKeysResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLatestPublicKeysResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetLatestPublicKeysResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.publicKeys && message.publicKeys.length))
                        message.publicKeys = [];
                    message.publicKeys.push($root.api.IdentityPublicKey.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetLatestPublicKeysResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetLatestPublicKeysResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetLatestPublicKeysResponse} IdentityGetLatestPublicKeysResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLatestPublicKeysResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetLatestPublicKeysResponse message.
         * @function verify
         * @memberof api.IdentityGetLatestPublicKeysResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetLatestPublicKeysResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.publicKeys != null && message.hasOwnProperty("publicKeys")) {
                if (!Array.isArray(message.publicKeys))
                    return "publicKeys: array expected";
                for (var i = 0; i < message.publicKeys.length; ++i) {
                    var error = $root.api.IdentityPublicKey.verify(message.publicKeys[i]);
                    if (error)
                        return "publicKeys." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetLatestPublicKeysResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetLatestPublicKeysResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetLatestPublicKeysResponse} IdentityGetLatestPublicKeysResponse
         */
        IdentityGetLatestPublicKeysResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetLatestPublicKeysResponse)
                return object;
            var message = new $root.api.IdentityGetLatestPublicKeysResponse();
            if (object.publicKeys) {
                if (!Array.isArray(object.publicKeys))
                    throw TypeError(".api.IdentityGetLatestPublicKeysResponse.publicKeys: array expected");
                message.publicKeys = [];
                for (var i = 0; i < object.publicKeys.length; ++i) {
                    if (typeof object.publicKeys[i] !== "object")
                        throw TypeError(".api.IdentityGetLatestPublicKeysResponse.publicKeys: object expected");
                    message.publicKeys[i] = $root.api.IdentityPublicKey.fromObject(object.publicKeys[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetLatestPublicKeysResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetLatestPublicKeysResponse
         * @static
         * @param {api.IdentityGetLatestPublicKeysResponse} message IdentityGetLatestPublicKeysResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetLatestPublicKeysResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.publicKeys = [];
            if (message.publicKeys && message.publicKeys.length) {
                object.publicKeys = [];
                for (var j = 0; j < message.publicKeys.length; ++j)
                    object.publicKeys[j] = $root.api.IdentityPublicKey.toObject(message.publicKeys[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetLatestPublicKeysResponse to JSON.
         * @function toJSON
         * @memberof api.IdentityGetLatestPublicKeysResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetLatestPublicKeysResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetLatestPublicKeysResponse;
    })();

    api.IdentityGetPublicChainsRequest = (function() {

        /**
         * Properties of an IdentityGetPublicChainsRequest.
         * @memberof api
         * @interface IIdentityGetPublicChainsRequest
         * @property {Array.<api.IdentityGetPublicChainsRequest.IE>|null} [ids] IdentityGetPublicChainsRequest ids
         */

        /**
         * Constructs a new IdentityGetPublicChainsRequest.
         * @memberof api
         * @classdesc Represents an IdentityGetPublicChainsRequest.
         * @implements IIdentityGetPublicChainsRequest
         * @constructor
         * @param {api.IIdentityGetPublicChainsRequest=} [properties] Properties to set
         */
        function IdentityGetPublicChainsRequest(properties) {
            this.ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetPublicChainsRequest ids.
         * @member {Array.<api.IdentityGetPublicChainsRequest.IE>} ids
         * @memberof api.IdentityGetPublicChainsRequest
         * @instance
         */
        IdentityGetPublicChainsRequest.prototype.ids = $util.emptyArray;

        /**
         * Creates a new IdentityGetPublicChainsRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetPublicChainsRequest
         * @static
         * @param {api.IIdentityGetPublicChainsRequest=} [properties] Properties to set
         * @returns {api.IdentityGetPublicChainsRequest} IdentityGetPublicChainsRequest instance
         */
        IdentityGetPublicChainsRequest.create = function create(properties) {
            return new IdentityGetPublicChainsRequest(properties);
        };

        /**
         * Encodes the specified IdentityGetPublicChainsRequest message. Does not implicitly {@link api.IdentityGetPublicChainsRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetPublicChainsRequest
         * @static
         * @param {api.IIdentityGetPublicChainsRequest} message IdentityGetPublicChainsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetPublicChainsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ids != null && message.ids.length)
                for (var i = 0; i < message.ids.length; ++i)
                    $root.api.IdentityGetPublicChainsRequest.E.encode(message.ids[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetPublicChainsRequest message, length delimited. Does not implicitly {@link api.IdentityGetPublicChainsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetPublicChainsRequest
         * @static
         * @param {api.IIdentityGetPublicChainsRequest} message IdentityGetPublicChainsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetPublicChainsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetPublicChainsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetPublicChainsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetPublicChainsRequest} IdentityGetPublicChainsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetPublicChainsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetPublicChainsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ids && message.ids.length))
                        message.ids = [];
                    message.ids.push($root.api.IdentityGetPublicChainsRequest.E.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetPublicChainsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetPublicChainsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetPublicChainsRequest} IdentityGetPublicChainsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetPublicChainsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetPublicChainsRequest message.
         * @function verify
         * @memberof api.IdentityGetPublicChainsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetPublicChainsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ids != null && message.hasOwnProperty("ids")) {
                if (!Array.isArray(message.ids))
                    return "ids: array expected";
                for (var i = 0; i < message.ids.length; ++i) {
                    var error = $root.api.IdentityGetPublicChainsRequest.E.verify(message.ids[i]);
                    if (error)
                        return "ids." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetPublicChainsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetPublicChainsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetPublicChainsRequest} IdentityGetPublicChainsRequest
         */
        IdentityGetPublicChainsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetPublicChainsRequest)
                return object;
            var message = new $root.api.IdentityGetPublicChainsRequest();
            if (object.ids) {
                if (!Array.isArray(object.ids))
                    throw TypeError(".api.IdentityGetPublicChainsRequest.ids: array expected");
                message.ids = [];
                for (var i = 0; i < object.ids.length; ++i) {
                    if (typeof object.ids[i] !== "object")
                        throw TypeError(".api.IdentityGetPublicChainsRequest.ids: object expected");
                    message.ids[i] = $root.api.IdentityGetPublicChainsRequest.E.fromObject(object.ids[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetPublicChainsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetPublicChainsRequest
         * @static
         * @param {api.IdentityGetPublicChainsRequest} message IdentityGetPublicChainsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetPublicChainsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.ids = [];
            if (message.ids && message.ids.length) {
                object.ids = [];
                for (var j = 0; j < message.ids.length; ++j)
                    object.ids[j] = $root.api.IdentityGetPublicChainsRequest.E.toObject(message.ids[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetPublicChainsRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityGetPublicChainsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetPublicChainsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        IdentityGetPublicChainsRequest.E = (function() {

            /**
             * Properties of a E.
             * @memberof api.IdentityGetPublicChainsRequest
             * @interface IE
             * @property {api.IIdentityKeyID|null} [id] E id
             * @property {number|null} [since] E since
             */

            /**
             * Constructs a new E.
             * @memberof api.IdentityGetPublicChainsRequest
             * @classdesc Represents a E.
             * @implements IE
             * @constructor
             * @param {api.IdentityGetPublicChainsRequest.IE=} [properties] Properties to set
             */
            function E(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * E id.
             * @member {api.IIdentityKeyID|null|undefined} id
             * @memberof api.IdentityGetPublicChainsRequest.E
             * @instance
             */
            E.prototype.id = null;

            /**
             * E since.
             * @member {number} since
             * @memberof api.IdentityGetPublicChainsRequest.E
             * @instance
             */
            E.prototype.since = 0;

            /**
             * Creates a new E instance using the specified properties.
             * @function create
             * @memberof api.IdentityGetPublicChainsRequest.E
             * @static
             * @param {api.IdentityGetPublicChainsRequest.IE=} [properties] Properties to set
             * @returns {api.IdentityGetPublicChainsRequest.E} E instance
             */
            E.create = function create(properties) {
                return new E(properties);
            };

            /**
             * Encodes the specified E message. Does not implicitly {@link api.IdentityGetPublicChainsRequest.E.verify|verify} messages.
             * @function encode
             * @memberof api.IdentityGetPublicChainsRequest.E
             * @static
             * @param {api.IdentityGetPublicChainsRequest.IE} message E message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            E.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.api.IdentityKeyID.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.since != null && message.hasOwnProperty("since"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.since);
                return writer;
            };

            /**
             * Encodes the specified E message, length delimited. Does not implicitly {@link api.IdentityGetPublicChainsRequest.E.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.IdentityGetPublicChainsRequest.E
             * @static
             * @param {api.IdentityGetPublicChainsRequest.IE} message E message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            E.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a E message from the specified reader or buffer.
             * @function decode
             * @memberof api.IdentityGetPublicChainsRequest.E
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.IdentityGetPublicChainsRequest.E} E
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            E.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetPublicChainsRequest.E();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.since = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a E message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.IdentityGetPublicChainsRequest.E
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.IdentityGetPublicChainsRequest.E} E
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            E.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a E message.
             * @function verify
             * @memberof api.IdentityGetPublicChainsRequest.E
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            E.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id")) {
                    var error = $root.api.IdentityKeyID.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                if (message.since != null && message.hasOwnProperty("since"))
                    if (!$util.isInteger(message.since))
                        return "since: integer expected";
                return null;
            };

            /**
             * Creates a E message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.IdentityGetPublicChainsRequest.E
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.IdentityGetPublicChainsRequest.E} E
             */
            E.fromObject = function fromObject(object) {
                if (object instanceof $root.api.IdentityGetPublicChainsRequest.E)
                    return object;
                var message = new $root.api.IdentityGetPublicChainsRequest.E();
                if (object.id != null) {
                    if (typeof object.id !== "object")
                        throw TypeError(".api.IdentityGetPublicChainsRequest.E.id: object expected");
                    message.id = $root.api.IdentityKeyID.fromObject(object.id);
                }
                if (object.since != null)
                    message.since = object.since >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a E message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.IdentityGetPublicChainsRequest.E
             * @static
             * @param {api.IdentityGetPublicChainsRequest.E} message E
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            E.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = null;
                    object.since = 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = $root.api.IdentityKeyID.toObject(message.id, options);
                if (message.since != null && message.hasOwnProperty("since"))
                    object.since = message.since;
                return object;
            };

            /**
             * Converts this E to JSON.
             * @function toJSON
             * @memberof api.IdentityGetPublicChainsRequest.E
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            E.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return E;
        })();

        return IdentityGetPublicChainsRequest;
    })();

    api.IdentityGetPublicChainsResponse = (function() {

        /**
         * Properties of an IdentityGetPublicChainsResponse.
         * @memberof api
         * @interface IIdentityGetPublicChainsResponse
         * @property {Array.<api.IIdentityPublicChain>|null} [chains] IdentityGetPublicChainsResponse chains
         */

        /**
         * Constructs a new IdentityGetPublicChainsResponse.
         * @memberof api
         * @classdesc Represents an IdentityGetPublicChainsResponse.
         * @implements IIdentityGetPublicChainsResponse
         * @constructor
         * @param {api.IIdentityGetPublicChainsResponse=} [properties] Properties to set
         */
        function IdentityGetPublicChainsResponse(properties) {
            this.chains = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetPublicChainsResponse chains.
         * @member {Array.<api.IIdentityPublicChain>} chains
         * @memberof api.IdentityGetPublicChainsResponse
         * @instance
         */
        IdentityGetPublicChainsResponse.prototype.chains = $util.emptyArray;

        /**
         * Creates a new IdentityGetPublicChainsResponse instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetPublicChainsResponse
         * @static
         * @param {api.IIdentityGetPublicChainsResponse=} [properties] Properties to set
         * @returns {api.IdentityGetPublicChainsResponse} IdentityGetPublicChainsResponse instance
         */
        IdentityGetPublicChainsResponse.create = function create(properties) {
            return new IdentityGetPublicChainsResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetPublicChainsResponse message. Does not implicitly {@link api.IdentityGetPublicChainsResponse.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetPublicChainsResponse
         * @static
         * @param {api.IIdentityGetPublicChainsResponse} message IdentityGetPublicChainsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetPublicChainsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chains != null && message.chains.length)
                for (var i = 0; i < message.chains.length; ++i)
                    $root.api.IdentityPublicChain.encode(message.chains[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetPublicChainsResponse message, length delimited. Does not implicitly {@link api.IdentityGetPublicChainsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetPublicChainsResponse
         * @static
         * @param {api.IIdentityGetPublicChainsResponse} message IdentityGetPublicChainsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetPublicChainsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetPublicChainsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetPublicChainsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetPublicChainsResponse} IdentityGetPublicChainsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetPublicChainsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetPublicChainsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.chains && message.chains.length))
                        message.chains = [];
                    message.chains.push($root.api.IdentityPublicChain.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetPublicChainsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetPublicChainsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetPublicChainsResponse} IdentityGetPublicChainsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetPublicChainsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetPublicChainsResponse message.
         * @function verify
         * @memberof api.IdentityGetPublicChainsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetPublicChainsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chains != null && message.hasOwnProperty("chains")) {
                if (!Array.isArray(message.chains))
                    return "chains: array expected";
                for (var i = 0; i < message.chains.length; ++i) {
                    var error = $root.api.IdentityPublicChain.verify(message.chains[i]);
                    if (error)
                        return "chains." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetPublicChainsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetPublicChainsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetPublicChainsResponse} IdentityGetPublicChainsResponse
         */
        IdentityGetPublicChainsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetPublicChainsResponse)
                return object;
            var message = new $root.api.IdentityGetPublicChainsResponse();
            if (object.chains) {
                if (!Array.isArray(object.chains))
                    throw TypeError(".api.IdentityGetPublicChainsResponse.chains: array expected");
                message.chains = [];
                for (var i = 0; i < object.chains.length; ++i) {
                    if (typeof object.chains[i] !== "object")
                        throw TypeError(".api.IdentityGetPublicChainsResponse.chains: object expected");
                    message.chains[i] = $root.api.IdentityPublicChain.fromObject(object.chains[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetPublicChainsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetPublicChainsResponse
         * @static
         * @param {api.IdentityGetPublicChainsResponse} message IdentityGetPublicChainsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetPublicChainsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.chains = [];
            if (message.chains && message.chains.length) {
                object.chains = [];
                for (var j = 0; j < message.chains.length; ++j)
                    object.chains[j] = $root.api.IdentityPublicChain.toObject(message.chains[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetPublicChainsResponse to JSON.
         * @function toJSON
         * @memberof api.IdentityGetPublicChainsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetPublicChainsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetPublicChainsResponse;
    })();

    api.IdentityGetLatestPublicChainsRequest = (function() {

        /**
         * Properties of an IdentityGetLatestPublicChainsRequest.
         * @memberof api
         * @interface IIdentityGetLatestPublicChainsRequest
         * @property {Array.<api.IdentityGetLatestPublicChainsRequest.IE>|null} [ids] IdentityGetLatestPublicChainsRequest ids
         */

        /**
         * Constructs a new IdentityGetLatestPublicChainsRequest.
         * @memberof api
         * @classdesc Represents an IdentityGetLatestPublicChainsRequest.
         * @implements IIdentityGetLatestPublicChainsRequest
         * @constructor
         * @param {api.IIdentityGetLatestPublicChainsRequest=} [properties] Properties to set
         */
        function IdentityGetLatestPublicChainsRequest(properties) {
            this.ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetLatestPublicChainsRequest ids.
         * @member {Array.<api.IdentityGetLatestPublicChainsRequest.IE>} ids
         * @memberof api.IdentityGetLatestPublicChainsRequest
         * @instance
         */
        IdentityGetLatestPublicChainsRequest.prototype.ids = $util.emptyArray;

        /**
         * Creates a new IdentityGetLatestPublicChainsRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetLatestPublicChainsRequest
         * @static
         * @param {api.IIdentityGetLatestPublicChainsRequest=} [properties] Properties to set
         * @returns {api.IdentityGetLatestPublicChainsRequest} IdentityGetLatestPublicChainsRequest instance
         */
        IdentityGetLatestPublicChainsRequest.create = function create(properties) {
            return new IdentityGetLatestPublicChainsRequest(properties);
        };

        /**
         * Encodes the specified IdentityGetLatestPublicChainsRequest message. Does not implicitly {@link api.IdentityGetLatestPublicChainsRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetLatestPublicChainsRequest
         * @static
         * @param {api.IIdentityGetLatestPublicChainsRequest} message IdentityGetLatestPublicChainsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLatestPublicChainsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ids != null && message.ids.length)
                for (var i = 0; i < message.ids.length; ++i)
                    $root.api.IdentityGetLatestPublicChainsRequest.E.encode(message.ids[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetLatestPublicChainsRequest message, length delimited. Does not implicitly {@link api.IdentityGetLatestPublicChainsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetLatestPublicChainsRequest
         * @static
         * @param {api.IIdentityGetLatestPublicChainsRequest} message IdentityGetLatestPublicChainsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLatestPublicChainsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetLatestPublicChainsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetLatestPublicChainsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetLatestPublicChainsRequest} IdentityGetLatestPublicChainsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLatestPublicChainsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetLatestPublicChainsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ids && message.ids.length))
                        message.ids = [];
                    message.ids.push($root.api.IdentityGetLatestPublicChainsRequest.E.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetLatestPublicChainsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetLatestPublicChainsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetLatestPublicChainsRequest} IdentityGetLatestPublicChainsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLatestPublicChainsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetLatestPublicChainsRequest message.
         * @function verify
         * @memberof api.IdentityGetLatestPublicChainsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetLatestPublicChainsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ids != null && message.hasOwnProperty("ids")) {
                if (!Array.isArray(message.ids))
                    return "ids: array expected";
                for (var i = 0; i < message.ids.length; ++i) {
                    var error = $root.api.IdentityGetLatestPublicChainsRequest.E.verify(message.ids[i]);
                    if (error)
                        return "ids." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetLatestPublicChainsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetLatestPublicChainsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetLatestPublicChainsRequest} IdentityGetLatestPublicChainsRequest
         */
        IdentityGetLatestPublicChainsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetLatestPublicChainsRequest)
                return object;
            var message = new $root.api.IdentityGetLatestPublicChainsRequest();
            if (object.ids) {
                if (!Array.isArray(object.ids))
                    throw TypeError(".api.IdentityGetLatestPublicChainsRequest.ids: array expected");
                message.ids = [];
                for (var i = 0; i < object.ids.length; ++i) {
                    if (typeof object.ids[i] !== "object")
                        throw TypeError(".api.IdentityGetLatestPublicChainsRequest.ids: object expected");
                    message.ids[i] = $root.api.IdentityGetLatestPublicChainsRequest.E.fromObject(object.ids[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetLatestPublicChainsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetLatestPublicChainsRequest
         * @static
         * @param {api.IdentityGetLatestPublicChainsRequest} message IdentityGetLatestPublicChainsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetLatestPublicChainsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.ids = [];
            if (message.ids && message.ids.length) {
                object.ids = [];
                for (var j = 0; j < message.ids.length; ++j)
                    object.ids[j] = $root.api.IdentityGetLatestPublicChainsRequest.E.toObject(message.ids[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetLatestPublicChainsRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityGetLatestPublicChainsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetLatestPublicChainsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        IdentityGetLatestPublicChainsRequest.E = (function() {

            /**
             * Properties of a E.
             * @memberof api.IdentityGetLatestPublicChainsRequest
             * @interface IE
             * @property {string|null} [login] E login
             * @property {number|null} [since] E since
             */

            /**
             * Constructs a new E.
             * @memberof api.IdentityGetLatestPublicChainsRequest
             * @classdesc Represents a E.
             * @implements IE
             * @constructor
             * @param {api.IdentityGetLatestPublicChainsRequest.IE=} [properties] Properties to set
             */
            function E(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * E login.
             * @member {string} login
             * @memberof api.IdentityGetLatestPublicChainsRequest.E
             * @instance
             */
            E.prototype.login = "";

            /**
             * E since.
             * @member {number} since
             * @memberof api.IdentityGetLatestPublicChainsRequest.E
             * @instance
             */
            E.prototype.since = 0;

            /**
             * Creates a new E instance using the specified properties.
             * @function create
             * @memberof api.IdentityGetLatestPublicChainsRequest.E
             * @static
             * @param {api.IdentityGetLatestPublicChainsRequest.IE=} [properties] Properties to set
             * @returns {api.IdentityGetLatestPublicChainsRequest.E} E instance
             */
            E.create = function create(properties) {
                return new E(properties);
            };

            /**
             * Encodes the specified E message. Does not implicitly {@link api.IdentityGetLatestPublicChainsRequest.E.verify|verify} messages.
             * @function encode
             * @memberof api.IdentityGetLatestPublicChainsRequest.E
             * @static
             * @param {api.IdentityGetLatestPublicChainsRequest.IE} message E message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            E.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.login != null && message.hasOwnProperty("login"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
                if (message.since != null && message.hasOwnProperty("since"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.since);
                return writer;
            };

            /**
             * Encodes the specified E message, length delimited. Does not implicitly {@link api.IdentityGetLatestPublicChainsRequest.E.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.IdentityGetLatestPublicChainsRequest.E
             * @static
             * @param {api.IdentityGetLatestPublicChainsRequest.IE} message E message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            E.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a E message from the specified reader or buffer.
             * @function decode
             * @memberof api.IdentityGetLatestPublicChainsRequest.E
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.IdentityGetLatestPublicChainsRequest.E} E
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            E.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetLatestPublicChainsRequest.E();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.login = reader.string();
                        break;
                    case 2:
                        message.since = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a E message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.IdentityGetLatestPublicChainsRequest.E
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.IdentityGetLatestPublicChainsRequest.E} E
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            E.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a E message.
             * @function verify
             * @memberof api.IdentityGetLatestPublicChainsRequest.E
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            E.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.login != null && message.hasOwnProperty("login"))
                    if (!$util.isString(message.login))
                        return "login: string expected";
                if (message.since != null && message.hasOwnProperty("since"))
                    if (!$util.isInteger(message.since))
                        return "since: integer expected";
                return null;
            };

            /**
             * Creates a E message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.IdentityGetLatestPublicChainsRequest.E
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.IdentityGetLatestPublicChainsRequest.E} E
             */
            E.fromObject = function fromObject(object) {
                if (object instanceof $root.api.IdentityGetLatestPublicChainsRequest.E)
                    return object;
                var message = new $root.api.IdentityGetLatestPublicChainsRequest.E();
                if (object.login != null)
                    message.login = String(object.login);
                if (object.since != null)
                    message.since = object.since >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a E message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.IdentityGetLatestPublicChainsRequest.E
             * @static
             * @param {api.IdentityGetLatestPublicChainsRequest.E} message E
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            E.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.login = "";
                    object.since = 0;
                }
                if (message.login != null && message.hasOwnProperty("login"))
                    object.login = message.login;
                if (message.since != null && message.hasOwnProperty("since"))
                    object.since = message.since;
                return object;
            };

            /**
             * Converts this E to JSON.
             * @function toJSON
             * @memberof api.IdentityGetLatestPublicChainsRequest.E
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            E.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return E;
        })();

        return IdentityGetLatestPublicChainsRequest;
    })();

    api.IdentityGetLatestPublicChainsResponse = (function() {

        /**
         * Properties of an IdentityGetLatestPublicChainsResponse.
         * @memberof api
         * @interface IIdentityGetLatestPublicChainsResponse
         * @property {Array.<api.IIdentityPublicChain>|null} [chains] IdentityGetLatestPublicChainsResponse chains
         */

        /**
         * Constructs a new IdentityGetLatestPublicChainsResponse.
         * @memberof api
         * @classdesc Represents an IdentityGetLatestPublicChainsResponse.
         * @implements IIdentityGetLatestPublicChainsResponse
         * @constructor
         * @param {api.IIdentityGetLatestPublicChainsResponse=} [properties] Properties to set
         */
        function IdentityGetLatestPublicChainsResponse(properties) {
            this.chains = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetLatestPublicChainsResponse chains.
         * @member {Array.<api.IIdentityPublicChain>} chains
         * @memberof api.IdentityGetLatestPublicChainsResponse
         * @instance
         */
        IdentityGetLatestPublicChainsResponse.prototype.chains = $util.emptyArray;

        /**
         * Creates a new IdentityGetLatestPublicChainsResponse instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetLatestPublicChainsResponse
         * @static
         * @param {api.IIdentityGetLatestPublicChainsResponse=} [properties] Properties to set
         * @returns {api.IdentityGetLatestPublicChainsResponse} IdentityGetLatestPublicChainsResponse instance
         */
        IdentityGetLatestPublicChainsResponse.create = function create(properties) {
            return new IdentityGetLatestPublicChainsResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetLatestPublicChainsResponse message. Does not implicitly {@link api.IdentityGetLatestPublicChainsResponse.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetLatestPublicChainsResponse
         * @static
         * @param {api.IIdentityGetLatestPublicChainsResponse} message IdentityGetLatestPublicChainsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLatestPublicChainsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chains != null && message.chains.length)
                for (var i = 0; i < message.chains.length; ++i)
                    $root.api.IdentityPublicChain.encode(message.chains[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetLatestPublicChainsResponse message, length delimited. Does not implicitly {@link api.IdentityGetLatestPublicChainsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetLatestPublicChainsResponse
         * @static
         * @param {api.IIdentityGetLatestPublicChainsResponse} message IdentityGetLatestPublicChainsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLatestPublicChainsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetLatestPublicChainsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetLatestPublicChainsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetLatestPublicChainsResponse} IdentityGetLatestPublicChainsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLatestPublicChainsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetLatestPublicChainsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.chains && message.chains.length))
                        message.chains = [];
                    message.chains.push($root.api.IdentityPublicChain.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetLatestPublicChainsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetLatestPublicChainsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetLatestPublicChainsResponse} IdentityGetLatestPublicChainsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLatestPublicChainsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetLatestPublicChainsResponse message.
         * @function verify
         * @memberof api.IdentityGetLatestPublicChainsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetLatestPublicChainsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chains != null && message.hasOwnProperty("chains")) {
                if (!Array.isArray(message.chains))
                    return "chains: array expected";
                for (var i = 0; i < message.chains.length; ++i) {
                    var error = $root.api.IdentityPublicChain.verify(message.chains[i]);
                    if (error)
                        return "chains." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetLatestPublicChainsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetLatestPublicChainsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetLatestPublicChainsResponse} IdentityGetLatestPublicChainsResponse
         */
        IdentityGetLatestPublicChainsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetLatestPublicChainsResponse)
                return object;
            var message = new $root.api.IdentityGetLatestPublicChainsResponse();
            if (object.chains) {
                if (!Array.isArray(object.chains))
                    throw TypeError(".api.IdentityGetLatestPublicChainsResponse.chains: array expected");
                message.chains = [];
                for (var i = 0; i < object.chains.length; ++i) {
                    if (typeof object.chains[i] !== "object")
                        throw TypeError(".api.IdentityGetLatestPublicChainsResponse.chains: object expected");
                    message.chains[i] = $root.api.IdentityPublicChain.fromObject(object.chains[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetLatestPublicChainsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetLatestPublicChainsResponse
         * @static
         * @param {api.IdentityGetLatestPublicChainsResponse} message IdentityGetLatestPublicChainsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetLatestPublicChainsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.chains = [];
            if (message.chains && message.chains.length) {
                object.chains = [];
                for (var j = 0; j < message.chains.length; ++j)
                    object.chains[j] = $root.api.IdentityPublicChain.toObject(message.chains[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetLatestPublicChainsResponse to JSON.
         * @function toJSON
         * @memberof api.IdentityGetLatestPublicChainsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetLatestPublicChainsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetLatestPublicChainsResponse;
    })();

    api.IdentityShareLink = (function() {

        /**
         * Properties of an IdentityShareLink.
         * @memberof api
         * @interface IIdentityShareLink
         * @property {api.IIdentityKeyID|null} [id] IdentityShareLink id
         * @property {api.IdentityShareKind|null} [kind] IdentityShareLink kind
         * @property {boolean|null} [locked] IdentityShareLink locked
         */

        /**
         * Constructs a new IdentityShareLink.
         * @memberof api
         * @classdesc Represents an IdentityShareLink.
         * @implements IIdentityShareLink
         * @constructor
         * @param {api.IIdentityShareLink=} [properties] Properties to set
         */
        function IdentityShareLink(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityShareLink id.
         * @member {api.IIdentityKeyID|null|undefined} id
         * @memberof api.IdentityShareLink
         * @instance
         */
        IdentityShareLink.prototype.id = null;

        /**
         * IdentityShareLink kind.
         * @member {api.IdentityShareKind} kind
         * @memberof api.IdentityShareLink
         * @instance
         */
        IdentityShareLink.prototype.kind = 0;

        /**
         * IdentityShareLink locked.
         * @member {boolean} locked
         * @memberof api.IdentityShareLink
         * @instance
         */
        IdentityShareLink.prototype.locked = false;

        /**
         * Creates a new IdentityShareLink instance using the specified properties.
         * @function create
         * @memberof api.IdentityShareLink
         * @static
         * @param {api.IIdentityShareLink=} [properties] Properties to set
         * @returns {api.IdentityShareLink} IdentityShareLink instance
         */
        IdentityShareLink.create = function create(properties) {
            return new IdentityShareLink(properties);
        };

        /**
         * Encodes the specified IdentityShareLink message. Does not implicitly {@link api.IdentityShareLink.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityShareLink
         * @static
         * @param {api.IIdentityShareLink} message IdentityShareLink message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityShareLink.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                $root.api.IdentityKeyID.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.kind != null && message.hasOwnProperty("kind"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.kind);
            if (message.locked != null && message.hasOwnProperty("locked"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.locked);
            return writer;
        };

        /**
         * Encodes the specified IdentityShareLink message, length delimited. Does not implicitly {@link api.IdentityShareLink.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityShareLink
         * @static
         * @param {api.IIdentityShareLink} message IdentityShareLink message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityShareLink.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityShareLink message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityShareLink
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityShareLink} IdentityShareLink
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityShareLink.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityShareLink();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.kind = reader.int32();
                    break;
                case 3:
                    message.locked = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityShareLink message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityShareLink
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityShareLink} IdentityShareLink
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityShareLink.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityShareLink message.
         * @function verify
         * @memberof api.IdentityShareLink
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityShareLink.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
                var error = $root.api.IdentityKeyID.verify(message.id);
                if (error)
                    return "id." + error;
            }
            if (message.kind != null && message.hasOwnProperty("kind"))
                switch (message.kind) {
                default:
                    return "kind: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.locked != null && message.hasOwnProperty("locked"))
                if (typeof message.locked !== "boolean")
                    return "locked: boolean expected";
            return null;
        };

        /**
         * Creates an IdentityShareLink message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityShareLink
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityShareLink} IdentityShareLink
         */
        IdentityShareLink.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityShareLink)
                return object;
            var message = new $root.api.IdentityShareLink();
            if (object.id != null) {
                if (typeof object.id !== "object")
                    throw TypeError(".api.IdentityShareLink.id: object expected");
                message.id = $root.api.IdentityKeyID.fromObject(object.id);
            }
            switch (object.kind) {
            case "BOX":
            case 0:
                message.kind = 0;
                break;
            case "SHARING":
            case 1:
                message.kind = 1;
                break;
            }
            if (object.locked != null)
                message.locked = Boolean(object.locked);
            return message;
        };

        /**
         * Creates a plain object from an IdentityShareLink message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityShareLink
         * @static
         * @param {api.IdentityShareLink} message IdentityShareLink
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityShareLink.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = null;
                object.kind = options.enums === String ? "BOX" : 0;
                object.locked = false;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = $root.api.IdentityKeyID.toObject(message.id, options);
            if (message.kind != null && message.hasOwnProperty("kind"))
                object.kind = options.enums === String ? $root.api.IdentityShareKind[message.kind] : message.kind;
            if (message.locked != null && message.hasOwnProperty("locked"))
                object.locked = message.locked;
            return object;
        };

        /**
         * Converts this IdentityShareLink to JSON.
         * @function toJSON
         * @memberof api.IdentityShareLink
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityShareLink.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityShareLink;
    })();

    api.IdentityGetSharingGroupResponse = (function() {

        /**
         * Properties of an IdentityGetSharingGroupResponse.
         * @memberof api
         * @interface IIdentityGetSharingGroupResponse
         * @property {Array.<api.IIdentityShareLink>|null} [sharingGroup] IdentityGetSharingGroupResponse sharingGroup
         */

        /**
         * Constructs a new IdentityGetSharingGroupResponse.
         * @memberof api
         * @classdesc Represents an IdentityGetSharingGroupResponse.
         * @implements IIdentityGetSharingGroupResponse
         * @constructor
         * @param {api.IIdentityGetSharingGroupResponse=} [properties] Properties to set
         */
        function IdentityGetSharingGroupResponse(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetSharingGroupResponse sharingGroup.
         * @member {Array.<api.IIdentityShareLink>} sharingGroup
         * @memberof api.IdentityGetSharingGroupResponse
         * @instance
         */
        IdentityGetSharingGroupResponse.prototype.sharingGroup = $util.emptyArray;

        /**
         * Creates a new IdentityGetSharingGroupResponse instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetSharingGroupResponse
         * @static
         * @param {api.IIdentityGetSharingGroupResponse=} [properties] Properties to set
         * @returns {api.IdentityGetSharingGroupResponse} IdentityGetSharingGroupResponse instance
         */
        IdentityGetSharingGroupResponse.create = function create(properties) {
            return new IdentityGetSharingGroupResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetSharingGroupResponse message. Does not implicitly {@link api.IdentityGetSharingGroupResponse.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetSharingGroupResponse
         * @static
         * @param {api.IIdentityGetSharingGroupResponse} message IdentityGetSharingGroupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetSharingGroupResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.api.IdentityShareLink.encode(message.sharingGroup[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetSharingGroupResponse message, length delimited. Does not implicitly {@link api.IdentityGetSharingGroupResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetSharingGroupResponse
         * @static
         * @param {api.IIdentityGetSharingGroupResponse} message IdentityGetSharingGroupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetSharingGroupResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetSharingGroupResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetSharingGroupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetSharingGroupResponse} IdentityGetSharingGroupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetSharingGroupResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetSharingGroupResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.api.IdentityShareLink.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetSharingGroupResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetSharingGroupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetSharingGroupResponse} IdentityGetSharingGroupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetSharingGroupResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetSharingGroupResponse message.
         * @function verify
         * @memberof api.IdentityGetSharingGroupResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetSharingGroupResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.api.IdentityShareLink.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetSharingGroupResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetSharingGroupResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetSharingGroupResponse} IdentityGetSharingGroupResponse
         */
        IdentityGetSharingGroupResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetSharingGroupResponse)
                return object;
            var message = new $root.api.IdentityGetSharingGroupResponse();
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".api.IdentityGetSharingGroupResponse.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".api.IdentityGetSharingGroupResponse.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.api.IdentityShareLink.fromObject(object.sharingGroup[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetSharingGroupResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetSharingGroupResponse
         * @static
         * @param {api.IdentityGetSharingGroupResponse} message IdentityGetSharingGroupResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetSharingGroupResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.api.IdentityShareLink.toObject(message.sharingGroup[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetSharingGroupResponse to JSON.
         * @function toJSON
         * @memberof api.IdentityGetSharingGroupResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetSharingGroupResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetSharingGroupResponse;
    })();

    api.IdentityGetAccessGroupResponse = (function() {

        /**
         * Properties of an IdentityGetAccessGroupResponse.
         * @memberof api
         * @interface IIdentityGetAccessGroupResponse
         * @property {Array.<api.IIdentityShareLink>|null} [accessGroup] IdentityGetAccessGroupResponse accessGroup
         */

        /**
         * Constructs a new IdentityGetAccessGroupResponse.
         * @memberof api
         * @classdesc Represents an IdentityGetAccessGroupResponse.
         * @implements IIdentityGetAccessGroupResponse
         * @constructor
         * @param {api.IIdentityGetAccessGroupResponse=} [properties] Properties to set
         */
        function IdentityGetAccessGroupResponse(properties) {
            this.accessGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetAccessGroupResponse accessGroup.
         * @member {Array.<api.IIdentityShareLink>} accessGroup
         * @memberof api.IdentityGetAccessGroupResponse
         * @instance
         */
        IdentityGetAccessGroupResponse.prototype.accessGroup = $util.emptyArray;

        /**
         * Creates a new IdentityGetAccessGroupResponse instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetAccessGroupResponse
         * @static
         * @param {api.IIdentityGetAccessGroupResponse=} [properties] Properties to set
         * @returns {api.IdentityGetAccessGroupResponse} IdentityGetAccessGroupResponse instance
         */
        IdentityGetAccessGroupResponse.create = function create(properties) {
            return new IdentityGetAccessGroupResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetAccessGroupResponse message. Does not implicitly {@link api.IdentityGetAccessGroupResponse.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetAccessGroupResponse
         * @static
         * @param {api.IIdentityGetAccessGroupResponse} message IdentityGetAccessGroupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetAccessGroupResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accessGroup != null && message.accessGroup.length)
                for (var i = 0; i < message.accessGroup.length; ++i)
                    $root.api.IdentityShareLink.encode(message.accessGroup[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetAccessGroupResponse message, length delimited. Does not implicitly {@link api.IdentityGetAccessGroupResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetAccessGroupResponse
         * @static
         * @param {api.IIdentityGetAccessGroupResponse} message IdentityGetAccessGroupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetAccessGroupResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetAccessGroupResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetAccessGroupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetAccessGroupResponse} IdentityGetAccessGroupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetAccessGroupResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetAccessGroupResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.accessGroup && message.accessGroup.length))
                        message.accessGroup = [];
                    message.accessGroup.push($root.api.IdentityShareLink.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetAccessGroupResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetAccessGroupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetAccessGroupResponse} IdentityGetAccessGroupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetAccessGroupResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetAccessGroupResponse message.
         * @function verify
         * @memberof api.IdentityGetAccessGroupResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetAccessGroupResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.accessGroup != null && message.hasOwnProperty("accessGroup")) {
                if (!Array.isArray(message.accessGroup))
                    return "accessGroup: array expected";
                for (var i = 0; i < message.accessGroup.length; ++i) {
                    var error = $root.api.IdentityShareLink.verify(message.accessGroup[i]);
                    if (error)
                        return "accessGroup." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetAccessGroupResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetAccessGroupResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetAccessGroupResponse} IdentityGetAccessGroupResponse
         */
        IdentityGetAccessGroupResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetAccessGroupResponse)
                return object;
            var message = new $root.api.IdentityGetAccessGroupResponse();
            if (object.accessGroup) {
                if (!Array.isArray(object.accessGroup))
                    throw TypeError(".api.IdentityGetAccessGroupResponse.accessGroup: array expected");
                message.accessGroup = [];
                for (var i = 0; i < object.accessGroup.length; ++i) {
                    if (typeof object.accessGroup[i] !== "object")
                        throw TypeError(".api.IdentityGetAccessGroupResponse.accessGroup: object expected");
                    message.accessGroup[i] = $root.api.IdentityShareLink.fromObject(object.accessGroup[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetAccessGroupResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetAccessGroupResponse
         * @static
         * @param {api.IdentityGetAccessGroupResponse} message IdentityGetAccessGroupResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetAccessGroupResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.accessGroup = [];
            if (message.accessGroup && message.accessGroup.length) {
                object.accessGroup = [];
                for (var j = 0; j < message.accessGroup.length; ++j)
                    object.accessGroup[j] = $root.api.IdentityShareLink.toObject(message.accessGroup[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetAccessGroupResponse to JSON.
         * @function toJSON
         * @memberof api.IdentityGetAccessGroupResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetAccessGroupResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetAccessGroupResponse;
    })();

    api.IdentityShareEntry = (function() {

        /**
         * Properties of an IdentityShareEntry.
         * @memberof api
         * @interface IIdentityShareEntry
         * @property {string|null} [login] IdentityShareEntry login
         * @property {number|null} [version] IdentityShareEntry version
         * @property {Uint8Array|null} [nonce] IdentityShareEntry nonce
         * @property {Uint8Array|null} [encryptedKey] IdentityShareEntry encryptedKey
         * @property {api.IdentityShareKind|null} [kind] IdentityShareEntry kind
         */

        /**
         * Constructs a new IdentityShareEntry.
         * @memberof api
         * @classdesc Represents an IdentityShareEntry.
         * @implements IIdentityShareEntry
         * @constructor
         * @param {api.IIdentityShareEntry=} [properties] Properties to set
         */
        function IdentityShareEntry(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityShareEntry login.
         * @member {string} login
         * @memberof api.IdentityShareEntry
         * @instance
         */
        IdentityShareEntry.prototype.login = "";

        /**
         * IdentityShareEntry version.
         * @member {number} version
         * @memberof api.IdentityShareEntry
         * @instance
         */
        IdentityShareEntry.prototype.version = 0;

        /**
         * IdentityShareEntry nonce.
         * @member {Uint8Array} nonce
         * @memberof api.IdentityShareEntry
         * @instance
         */
        IdentityShareEntry.prototype.nonce = $util.newBuffer([]);

        /**
         * IdentityShareEntry encryptedKey.
         * @member {Uint8Array} encryptedKey
         * @memberof api.IdentityShareEntry
         * @instance
         */
        IdentityShareEntry.prototype.encryptedKey = $util.newBuffer([]);

        /**
         * IdentityShareEntry kind.
         * @member {api.IdentityShareKind} kind
         * @memberof api.IdentityShareEntry
         * @instance
         */
        IdentityShareEntry.prototype.kind = 0;

        /**
         * Creates a new IdentityShareEntry instance using the specified properties.
         * @function create
         * @memberof api.IdentityShareEntry
         * @static
         * @param {api.IIdentityShareEntry=} [properties] Properties to set
         * @returns {api.IdentityShareEntry} IdentityShareEntry instance
         */
        IdentityShareEntry.create = function create(properties) {
            return new IdentityShareEntry(properties);
        };

        /**
         * Encodes the specified IdentityShareEntry message. Does not implicitly {@link api.IdentityShareEntry.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityShareEntry
         * @static
         * @param {api.IIdentityShareEntry} message IdentityShareEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityShareEntry.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.nonce);
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.encryptedKey);
            if (message.kind != null && message.hasOwnProperty("kind"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.kind);
            return writer;
        };

        /**
         * Encodes the specified IdentityShareEntry message, length delimited. Does not implicitly {@link api.IdentityShareEntry.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityShareEntry
         * @static
         * @param {api.IIdentityShareEntry} message IdentityShareEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityShareEntry.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityShareEntry message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityShareEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityShareEntry} IdentityShareEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityShareEntry.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityShareEntry();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                case 3:
                    message.nonce = reader.bytes();
                    break;
                case 4:
                    message.encryptedKey = reader.bytes();
                    break;
                case 5:
                    message.kind = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityShareEntry message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityShareEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityShareEntry} IdentityShareEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityShareEntry.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityShareEntry message.
         * @function verify
         * @memberof api.IdentityShareEntry
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityShareEntry.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                    return "nonce: buffer expected";
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                if (!(message.encryptedKey && typeof message.encryptedKey.length === "number" || $util.isString(message.encryptedKey)))
                    return "encryptedKey: buffer expected";
            if (message.kind != null && message.hasOwnProperty("kind"))
                switch (message.kind) {
                default:
                    return "kind: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates an IdentityShareEntry message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityShareEntry
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityShareEntry} IdentityShareEntry
         */
        IdentityShareEntry.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityShareEntry)
                return object;
            var message = new $root.api.IdentityShareEntry();
            if (object.login != null)
                message.login = String(object.login);
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.nonce != null)
                if (typeof object.nonce === "string")
                    $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                else if (object.nonce.length)
                    message.nonce = object.nonce;
            if (object.encryptedKey != null)
                if (typeof object.encryptedKey === "string")
                    $util.base64.decode(object.encryptedKey, message.encryptedKey = $util.newBuffer($util.base64.length(object.encryptedKey)), 0);
                else if (object.encryptedKey.length)
                    message.encryptedKey = object.encryptedKey;
            switch (object.kind) {
            case "BOX":
            case 0:
                message.kind = 0;
                break;
            case "SHARING":
            case 1:
                message.kind = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityShareEntry message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityShareEntry
         * @static
         * @param {api.IdentityShareEntry} message IdentityShareEntry
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityShareEntry.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.version = 0;
                if (options.bytes === String)
                    object.nonce = "";
                else {
                    object.nonce = [];
                    if (options.bytes !== Array)
                        object.nonce = $util.newBuffer(object.nonce);
                }
                if (options.bytes === String)
                    object.encryptedKey = "";
                else {
                    object.encryptedKey = [];
                    if (options.bytes !== Array)
                        object.encryptedKey = $util.newBuffer(object.encryptedKey);
                }
                object.kind = options.enums === String ? "BOX" : 0;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                object.encryptedKey = options.bytes === String ? $util.base64.encode(message.encryptedKey, 0, message.encryptedKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedKey) : message.encryptedKey;
            if (message.kind != null && message.hasOwnProperty("kind"))
                object.kind = options.enums === String ? $root.api.IdentityShareKind[message.kind] : message.kind;
            return object;
        };

        /**
         * Converts this IdentityShareEntry to JSON.
         * @function toJSON
         * @memberof api.IdentityShareEntry
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityShareEntry.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityShareEntry;
    })();

    api.IdentityShareRequest = (function() {

        /**
         * Properties of an IdentityShareRequest.
         * @memberof api
         * @interface IIdentityShareRequest
         * @property {string|null} [login] IdentityShareRequest login
         * @property {number|null} [version] IdentityShareRequest version
         * @property {Array.<api.IIdentityShareEntry>|null} [sharingGroup] IdentityShareRequest sharingGroup
         */

        /**
         * Constructs a new IdentityShareRequest.
         * @memberof api
         * @classdesc Represents an IdentityShareRequest.
         * @implements IIdentityShareRequest
         * @constructor
         * @param {api.IIdentityShareRequest=} [properties] Properties to set
         */
        function IdentityShareRequest(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityShareRequest login.
         * @member {string} login
         * @memberof api.IdentityShareRequest
         * @instance
         */
        IdentityShareRequest.prototype.login = "";

        /**
         * IdentityShareRequest version.
         * @member {number} version
         * @memberof api.IdentityShareRequest
         * @instance
         */
        IdentityShareRequest.prototype.version = 0;

        /**
         * IdentityShareRequest sharingGroup.
         * @member {Array.<api.IIdentityShareEntry>} sharingGroup
         * @memberof api.IdentityShareRequest
         * @instance
         */
        IdentityShareRequest.prototype.sharingGroup = $util.emptyArray;

        /**
         * Creates a new IdentityShareRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityShareRequest
         * @static
         * @param {api.IIdentityShareRequest=} [properties] Properties to set
         * @returns {api.IdentityShareRequest} IdentityShareRequest instance
         */
        IdentityShareRequest.create = function create(properties) {
            return new IdentityShareRequest(properties);
        };

        /**
         * Encodes the specified IdentityShareRequest message. Does not implicitly {@link api.IdentityShareRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityShareRequest
         * @static
         * @param {api.IIdentityShareRequest} message IdentityShareRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityShareRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.api.IdentityShareEntry.encode(message.sharingGroup[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityShareRequest message, length delimited. Does not implicitly {@link api.IdentityShareRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityShareRequest
         * @static
         * @param {api.IIdentityShareRequest} message IdentityShareRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityShareRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityShareRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityShareRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityShareRequest} IdentityShareRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityShareRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityShareRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                case 3:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.api.IdentityShareEntry.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityShareRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityShareRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityShareRequest} IdentityShareRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityShareRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityShareRequest message.
         * @function verify
         * @memberof api.IdentityShareRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityShareRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.api.IdentityShareEntry.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityShareRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityShareRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityShareRequest} IdentityShareRequest
         */
        IdentityShareRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityShareRequest)
                return object;
            var message = new $root.api.IdentityShareRequest();
            if (object.login != null)
                message.login = String(object.login);
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".api.IdentityShareRequest.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".api.IdentityShareRequest.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.api.IdentityShareEntry.fromObject(object.sharingGroup[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityShareRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityShareRequest
         * @static
         * @param {api.IdentityShareRequest} message IdentityShareRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityShareRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults) {
                object.login = "";
                object.version = 0;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.api.IdentityShareEntry.toObject(message.sharingGroup[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityShareRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityShareRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityShareRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityShareRequest;
    })();

    api.IdentityGetEncryptionResponse = (function() {

        /**
         * Properties of an IdentityGetEncryptionResponse.
         * @memberof api
         * @interface IIdentityGetEncryptionResponse
         * @property {api.IIdentityEncryption|null} [encryption] IdentityGetEncryptionResponse encryption
         * @property {api.IIdentityPublicKey|null} [creator] IdentityGetEncryptionResponse creator
         */

        /**
         * Constructs a new IdentityGetEncryptionResponse.
         * @memberof api
         * @classdesc Represents an IdentityGetEncryptionResponse.
         * @implements IIdentityGetEncryptionResponse
         * @constructor
         * @param {api.IIdentityGetEncryptionResponse=} [properties] Properties to set
         */
        function IdentityGetEncryptionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetEncryptionResponse encryption.
         * @member {api.IIdentityEncryption|null|undefined} encryption
         * @memberof api.IdentityGetEncryptionResponse
         * @instance
         */
        IdentityGetEncryptionResponse.prototype.encryption = null;

        /**
         * IdentityGetEncryptionResponse creator.
         * @member {api.IIdentityPublicKey|null|undefined} creator
         * @memberof api.IdentityGetEncryptionResponse
         * @instance
         */
        IdentityGetEncryptionResponse.prototype.creator = null;

        /**
         * Creates a new IdentityGetEncryptionResponse instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetEncryptionResponse
         * @static
         * @param {api.IIdentityGetEncryptionResponse=} [properties] Properties to set
         * @returns {api.IdentityGetEncryptionResponse} IdentityGetEncryptionResponse instance
         */
        IdentityGetEncryptionResponse.create = function create(properties) {
            return new IdentityGetEncryptionResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetEncryptionResponse message. Does not implicitly {@link api.IdentityGetEncryptionResponse.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetEncryptionResponse
         * @static
         * @param {api.IIdentityGetEncryptionResponse} message IdentityGetEncryptionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetEncryptionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.api.IdentityEncryption.encode(message.encryption, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.creator != null && message.hasOwnProperty("creator"))
                $root.api.IdentityPublicKey.encode(message.creator, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetEncryptionResponse message, length delimited. Does not implicitly {@link api.IdentityGetEncryptionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetEncryptionResponse
         * @static
         * @param {api.IIdentityGetEncryptionResponse} message IdentityGetEncryptionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetEncryptionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetEncryptionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetEncryptionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetEncryptionResponse} IdentityGetEncryptionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetEncryptionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetEncryptionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryption = $root.api.IdentityEncryption.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.creator = $root.api.IdentityPublicKey.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetEncryptionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetEncryptionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetEncryptionResponse} IdentityGetEncryptionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetEncryptionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetEncryptionResponse message.
         * @function verify
         * @memberof api.IdentityGetEncryptionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetEncryptionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.api.IdentityEncryption.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            if (message.creator != null && message.hasOwnProperty("creator")) {
                var error = $root.api.IdentityPublicKey.verify(message.creator);
                if (error)
                    return "creator." + error;
            }
            return null;
        };

        /**
         * Creates an IdentityGetEncryptionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetEncryptionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetEncryptionResponse} IdentityGetEncryptionResponse
         */
        IdentityGetEncryptionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetEncryptionResponse)
                return object;
            var message = new $root.api.IdentityGetEncryptionResponse();
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".api.IdentityGetEncryptionResponse.encryption: object expected");
                message.encryption = $root.api.IdentityEncryption.fromObject(object.encryption);
            }
            if (object.creator != null) {
                if (typeof object.creator !== "object")
                    throw TypeError(".api.IdentityGetEncryptionResponse.creator: object expected");
                message.creator = $root.api.IdentityPublicKey.fromObject(object.creator);
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetEncryptionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetEncryptionResponse
         * @static
         * @param {api.IdentityGetEncryptionResponse} message IdentityGetEncryptionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetEncryptionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.encryption = null;
                object.creator = null;
            }
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.api.IdentityEncryption.toObject(message.encryption, options);
            if (message.creator != null && message.hasOwnProperty("creator"))
                object.creator = $root.api.IdentityPublicKey.toObject(message.creator, options);
            return object;
        };

        /**
         * Converts this IdentityGetEncryptionResponse to JSON.
         * @function toJSON
         * @memberof api.IdentityGetEncryptionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetEncryptionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetEncryptionResponse;
    })();

    api.IdentityGetKeysToRenewResponse = (function() {

        /**
         * Properties of an IdentityGetKeysToRenewResponse.
         * @memberof api
         * @interface IIdentityGetKeysToRenewResponse
         * @property {api.IIdentityEncryption|null} [encryption] IdentityGetKeysToRenewResponse encryption
         * @property {api.IIdentityPublicKey|null} [creator] IdentityGetKeysToRenewResponse creator
         * @property {Array.<api.IIdentityPublicKey>|null} [sharingGroup] IdentityGetKeysToRenewResponse sharingGroup
         */

        /**
         * Constructs a new IdentityGetKeysToRenewResponse.
         * @memberof api
         * @classdesc Represents an IdentityGetKeysToRenewResponse.
         * @implements IIdentityGetKeysToRenewResponse
         * @constructor
         * @param {api.IIdentityGetKeysToRenewResponse=} [properties] Properties to set
         */
        function IdentityGetKeysToRenewResponse(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetKeysToRenewResponse encryption.
         * @member {api.IIdentityEncryption|null|undefined} encryption
         * @memberof api.IdentityGetKeysToRenewResponse
         * @instance
         */
        IdentityGetKeysToRenewResponse.prototype.encryption = null;

        /**
         * IdentityGetKeysToRenewResponse creator.
         * @member {api.IIdentityPublicKey|null|undefined} creator
         * @memberof api.IdentityGetKeysToRenewResponse
         * @instance
         */
        IdentityGetKeysToRenewResponse.prototype.creator = null;

        /**
         * IdentityGetKeysToRenewResponse sharingGroup.
         * @member {Array.<api.IIdentityPublicKey>} sharingGroup
         * @memberof api.IdentityGetKeysToRenewResponse
         * @instance
         */
        IdentityGetKeysToRenewResponse.prototype.sharingGroup = $util.emptyArray;

        /**
         * Creates a new IdentityGetKeysToRenewResponse instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetKeysToRenewResponse
         * @static
         * @param {api.IIdentityGetKeysToRenewResponse=} [properties] Properties to set
         * @returns {api.IdentityGetKeysToRenewResponse} IdentityGetKeysToRenewResponse instance
         */
        IdentityGetKeysToRenewResponse.create = function create(properties) {
            return new IdentityGetKeysToRenewResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetKeysToRenewResponse message. Does not implicitly {@link api.IdentityGetKeysToRenewResponse.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetKeysToRenewResponse
         * @static
         * @param {api.IIdentityGetKeysToRenewResponse} message IdentityGetKeysToRenewResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetKeysToRenewResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.api.IdentityEncryption.encode(message.encryption, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.creator != null && message.hasOwnProperty("creator"))
                $root.api.IdentityPublicKey.encode(message.creator, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.api.IdentityPublicKey.encode(message.sharingGroup[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetKeysToRenewResponse message, length delimited. Does not implicitly {@link api.IdentityGetKeysToRenewResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetKeysToRenewResponse
         * @static
         * @param {api.IIdentityGetKeysToRenewResponse} message IdentityGetKeysToRenewResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetKeysToRenewResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetKeysToRenewResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetKeysToRenewResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetKeysToRenewResponse} IdentityGetKeysToRenewResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetKeysToRenewResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetKeysToRenewResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryption = $root.api.IdentityEncryption.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.creator = $root.api.IdentityPublicKey.decode(reader, reader.uint32());
                    break;
                case 3:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.api.IdentityPublicKey.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetKeysToRenewResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetKeysToRenewResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetKeysToRenewResponse} IdentityGetKeysToRenewResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetKeysToRenewResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetKeysToRenewResponse message.
         * @function verify
         * @memberof api.IdentityGetKeysToRenewResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetKeysToRenewResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.api.IdentityEncryption.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            if (message.creator != null && message.hasOwnProperty("creator")) {
                var error = $root.api.IdentityPublicKey.verify(message.creator);
                if (error)
                    return "creator." + error;
            }
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.api.IdentityPublicKey.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetKeysToRenewResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetKeysToRenewResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetKeysToRenewResponse} IdentityGetKeysToRenewResponse
         */
        IdentityGetKeysToRenewResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetKeysToRenewResponse)
                return object;
            var message = new $root.api.IdentityGetKeysToRenewResponse();
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".api.IdentityGetKeysToRenewResponse.encryption: object expected");
                message.encryption = $root.api.IdentityEncryption.fromObject(object.encryption);
            }
            if (object.creator != null) {
                if (typeof object.creator !== "object")
                    throw TypeError(".api.IdentityGetKeysToRenewResponse.creator: object expected");
                message.creator = $root.api.IdentityPublicKey.fromObject(object.creator);
            }
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".api.IdentityGetKeysToRenewResponse.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".api.IdentityGetKeysToRenewResponse.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.api.IdentityPublicKey.fromObject(object.sharingGroup[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetKeysToRenewResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetKeysToRenewResponse
         * @static
         * @param {api.IdentityGetKeysToRenewResponse} message IdentityGetKeysToRenewResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetKeysToRenewResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults) {
                object.encryption = null;
                object.creator = null;
            }
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.api.IdentityEncryption.toObject(message.encryption, options);
            if (message.creator != null && message.hasOwnProperty("creator"))
                object.creator = $root.api.IdentityPublicKey.toObject(message.creator, options);
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.api.IdentityPublicKey.toObject(message.sharingGroup[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetKeysToRenewResponse to JSON.
         * @function toJSON
         * @memberof api.IdentityGetKeysToRenewResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetKeysToRenewResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetKeysToRenewResponse;
    })();

    api.IdentityBackwardKey = (function() {

        /**
         * Properties of an IdentityBackwardKey.
         * @memberof api
         * @interface IIdentityBackwardKey
         * @property {Uint8Array|null} [nonce] IdentityBackwardKey nonce
         * @property {Uint8Array|null} [encryptedKey] IdentityBackwardKey encryptedKey
         */

        /**
         * Constructs a new IdentityBackwardKey.
         * @memberof api
         * @classdesc Represents an IdentityBackwardKey.
         * @implements IIdentityBackwardKey
         * @constructor
         * @param {api.IIdentityBackwardKey=} [properties] Properties to set
         */
        function IdentityBackwardKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityBackwardKey nonce.
         * @member {Uint8Array} nonce
         * @memberof api.IdentityBackwardKey
         * @instance
         */
        IdentityBackwardKey.prototype.nonce = $util.newBuffer([]);

        /**
         * IdentityBackwardKey encryptedKey.
         * @member {Uint8Array} encryptedKey
         * @memberof api.IdentityBackwardKey
         * @instance
         */
        IdentityBackwardKey.prototype.encryptedKey = $util.newBuffer([]);

        /**
         * Creates a new IdentityBackwardKey instance using the specified properties.
         * @function create
         * @memberof api.IdentityBackwardKey
         * @static
         * @param {api.IIdentityBackwardKey=} [properties] Properties to set
         * @returns {api.IdentityBackwardKey} IdentityBackwardKey instance
         */
        IdentityBackwardKey.create = function create(properties) {
            return new IdentityBackwardKey(properties);
        };

        /**
         * Encodes the specified IdentityBackwardKey message. Does not implicitly {@link api.IdentityBackwardKey.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityBackwardKey
         * @static
         * @param {api.IIdentityBackwardKey} message IdentityBackwardKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityBackwardKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.nonce);
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedKey);
            return writer;
        };

        /**
         * Encodes the specified IdentityBackwardKey message, length delimited. Does not implicitly {@link api.IdentityBackwardKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityBackwardKey
         * @static
         * @param {api.IIdentityBackwardKey} message IdentityBackwardKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityBackwardKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityBackwardKey message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityBackwardKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityBackwardKey} IdentityBackwardKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityBackwardKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityBackwardKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nonce = reader.bytes();
                    break;
                case 2:
                    message.encryptedKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityBackwardKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityBackwardKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityBackwardKey} IdentityBackwardKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityBackwardKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityBackwardKey message.
         * @function verify
         * @memberof api.IdentityBackwardKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityBackwardKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                    return "nonce: buffer expected";
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                if (!(message.encryptedKey && typeof message.encryptedKey.length === "number" || $util.isString(message.encryptedKey)))
                    return "encryptedKey: buffer expected";
            return null;
        };

        /**
         * Creates an IdentityBackwardKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityBackwardKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityBackwardKey} IdentityBackwardKey
         */
        IdentityBackwardKey.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityBackwardKey)
                return object;
            var message = new $root.api.IdentityBackwardKey();
            if (object.nonce != null)
                if (typeof object.nonce === "string")
                    $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                else if (object.nonce.length)
                    message.nonce = object.nonce;
            if (object.encryptedKey != null)
                if (typeof object.encryptedKey === "string")
                    $util.base64.decode(object.encryptedKey, message.encryptedKey = $util.newBuffer($util.base64.length(object.encryptedKey)), 0);
                else if (object.encryptedKey.length)
                    message.encryptedKey = object.encryptedKey;
            return message;
        };

        /**
         * Creates a plain object from an IdentityBackwardKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityBackwardKey
         * @static
         * @param {api.IdentityBackwardKey} message IdentityBackwardKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityBackwardKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.nonce = "";
                else {
                    object.nonce = [];
                    if (options.bytes !== Array)
                        object.nonce = $util.newBuffer(object.nonce);
                }
                if (options.bytes === String)
                    object.encryptedKey = "";
                else {
                    object.encryptedKey = [];
                    if (options.bytes !== Array)
                        object.encryptedKey = $util.newBuffer(object.encryptedKey);
                }
            }
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                object.encryptedKey = options.bytes === String ? $util.base64.encode(message.encryptedKey, 0, message.encryptedKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedKey) : message.encryptedKey;
            return object;
        };

        /**
         * Converts this IdentityBackwardKey to JSON.
         * @function toJSON
         * @memberof api.IdentityBackwardKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityBackwardKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityBackwardKey;
    })();

    api.IdentityPostKeysToRenewRequest = (function() {

        /**
         * Properties of an IdentityPostKeysToRenewRequest.
         * @memberof api
         * @interface IIdentityPostKeysToRenewRequest
         * @property {string|null} [login] IdentityPostKeysToRenewRequest login
         * @property {api.IIdentityEncryption|null} [encryption] IdentityPostKeysToRenewRequest encryption
         * @property {Uint8Array|null} [signChain] IdentityPostKeysToRenewRequest signChain
         * @property {Array.<api.IIdentityShareEntry>|null} [sharingGroup] IdentityPostKeysToRenewRequest sharingGroup
         * @property {api.IIdentityBackwardKey|null} [backward] IdentityPostKeysToRenewRequest backward
         */

        /**
         * Constructs a new IdentityPostKeysToRenewRequest.
         * @memberof api
         * @classdesc Represents an IdentityPostKeysToRenewRequest.
         * @implements IIdentityPostKeysToRenewRequest
         * @constructor
         * @param {api.IIdentityPostKeysToRenewRequest=} [properties] Properties to set
         */
        function IdentityPostKeysToRenewRequest(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityPostKeysToRenewRequest login.
         * @member {string} login
         * @memberof api.IdentityPostKeysToRenewRequest
         * @instance
         */
        IdentityPostKeysToRenewRequest.prototype.login = "";

        /**
         * IdentityPostKeysToRenewRequest encryption.
         * @member {api.IIdentityEncryption|null|undefined} encryption
         * @memberof api.IdentityPostKeysToRenewRequest
         * @instance
         */
        IdentityPostKeysToRenewRequest.prototype.encryption = null;

        /**
         * IdentityPostKeysToRenewRequest signChain.
         * @member {Uint8Array} signChain
         * @memberof api.IdentityPostKeysToRenewRequest
         * @instance
         */
        IdentityPostKeysToRenewRequest.prototype.signChain = $util.newBuffer([]);

        /**
         * IdentityPostKeysToRenewRequest sharingGroup.
         * @member {Array.<api.IIdentityShareEntry>} sharingGroup
         * @memberof api.IdentityPostKeysToRenewRequest
         * @instance
         */
        IdentityPostKeysToRenewRequest.prototype.sharingGroup = $util.emptyArray;

        /**
         * IdentityPostKeysToRenewRequest backward.
         * @member {api.IIdentityBackwardKey|null|undefined} backward
         * @memberof api.IdentityPostKeysToRenewRequest
         * @instance
         */
        IdentityPostKeysToRenewRequest.prototype.backward = null;

        /**
         * Creates a new IdentityPostKeysToRenewRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityPostKeysToRenewRequest
         * @static
         * @param {api.IIdentityPostKeysToRenewRequest=} [properties] Properties to set
         * @returns {api.IdentityPostKeysToRenewRequest} IdentityPostKeysToRenewRequest instance
         */
        IdentityPostKeysToRenewRequest.create = function create(properties) {
            return new IdentityPostKeysToRenewRequest(properties);
        };

        /**
         * Encodes the specified IdentityPostKeysToRenewRequest message. Does not implicitly {@link api.IdentityPostKeysToRenewRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityPostKeysToRenewRequest
         * @static
         * @param {api.IIdentityPostKeysToRenewRequest} message IdentityPostKeysToRenewRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPostKeysToRenewRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.api.IdentityEncryption.encode(message.encryption, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signChain);
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.api.IdentityShareEntry.encode(message.sharingGroup[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.backward != null && message.hasOwnProperty("backward"))
                $root.api.IdentityBackwardKey.encode(message.backward, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityPostKeysToRenewRequest message, length delimited. Does not implicitly {@link api.IdentityPostKeysToRenewRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityPostKeysToRenewRequest
         * @static
         * @param {api.IIdentityPostKeysToRenewRequest} message IdentityPostKeysToRenewRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPostKeysToRenewRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityPostKeysToRenewRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityPostKeysToRenewRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityPostKeysToRenewRequest} IdentityPostKeysToRenewRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPostKeysToRenewRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityPostKeysToRenewRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.encryption = $root.api.IdentityEncryption.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.signChain = reader.bytes();
                    break;
                case 4:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.api.IdentityShareEntry.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.backward = $root.api.IdentityBackwardKey.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityPostKeysToRenewRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityPostKeysToRenewRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityPostKeysToRenewRequest} IdentityPostKeysToRenewRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPostKeysToRenewRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityPostKeysToRenewRequest message.
         * @function verify
         * @memberof api.IdentityPostKeysToRenewRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityPostKeysToRenewRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.api.IdentityEncryption.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                if (!(message.signChain && typeof message.signChain.length === "number" || $util.isString(message.signChain)))
                    return "signChain: buffer expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.api.IdentityShareEntry.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            if (message.backward != null && message.hasOwnProperty("backward")) {
                var error = $root.api.IdentityBackwardKey.verify(message.backward);
                if (error)
                    return "backward." + error;
            }
            return null;
        };

        /**
         * Creates an IdentityPostKeysToRenewRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityPostKeysToRenewRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityPostKeysToRenewRequest} IdentityPostKeysToRenewRequest
         */
        IdentityPostKeysToRenewRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityPostKeysToRenewRequest)
                return object;
            var message = new $root.api.IdentityPostKeysToRenewRequest();
            if (object.login != null)
                message.login = String(object.login);
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".api.IdentityPostKeysToRenewRequest.encryption: object expected");
                message.encryption = $root.api.IdentityEncryption.fromObject(object.encryption);
            }
            if (object.signChain != null)
                if (typeof object.signChain === "string")
                    $util.base64.decode(object.signChain, message.signChain = $util.newBuffer($util.base64.length(object.signChain)), 0);
                else if (object.signChain.length)
                    message.signChain = object.signChain;
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".api.IdentityPostKeysToRenewRequest.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".api.IdentityPostKeysToRenewRequest.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.api.IdentityShareEntry.fromObject(object.sharingGroup[i]);
                }
            }
            if (object.backward != null) {
                if (typeof object.backward !== "object")
                    throw TypeError(".api.IdentityPostKeysToRenewRequest.backward: object expected");
                message.backward = $root.api.IdentityBackwardKey.fromObject(object.backward);
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityPostKeysToRenewRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityPostKeysToRenewRequest
         * @static
         * @param {api.IdentityPostKeysToRenewRequest} message IdentityPostKeysToRenewRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityPostKeysToRenewRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults) {
                object.login = "";
                object.encryption = null;
                if (options.bytes === String)
                    object.signChain = "";
                else {
                    object.signChain = [];
                    if (options.bytes !== Array)
                        object.signChain = $util.newBuffer(object.signChain);
                }
                object.backward = null;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.api.IdentityEncryption.toObject(message.encryption, options);
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                object.signChain = options.bytes === String ? $util.base64.encode(message.signChain, 0, message.signChain.length) : options.bytes === Array ? Array.prototype.slice.call(message.signChain) : message.signChain;
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.api.IdentityShareEntry.toObject(message.sharingGroup[j], options);
            }
            if (message.backward != null && message.hasOwnProperty("backward"))
                object.backward = $root.api.IdentityBackwardKey.toObject(message.backward, options);
            return object;
        };

        /**
         * Converts this IdentityPostKeysToRenewRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityPostKeysToRenewRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityPostKeysToRenewRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityPostKeysToRenewRequest;
    })();

    api.IdentityGetSharingGraphElement = (function() {

        /**
         * Properties of an IdentityGetSharingGraphElement.
         * @memberof api
         * @interface IIdentityGetSharingGraphElement
         * @property {string|null} [login] IdentityGetSharingGraphElement login
         * @property {number|null} [version] IdentityGetSharingGraphElement version
         * @property {Uint8Array|null} [masterPublicKey] IdentityGetSharingGraphElement masterPublicKey
         * @property {api.ICipher|null} [sharingKey] IdentityGetSharingGraphElement sharingKey
         * @property {api.ICipher|null} [boxKey] IdentityGetSharingGraphElement boxKey
         * @property {api.ICipher|null} [signKey] IdentityGetSharingGraphElement signKey
         * @property {Array.<api.IIdentityPublicKey>|null} [sharingGroup] IdentityGetSharingGraphElement sharingGroup
         * @property {api.IIdentityKeyID|null} [sharedFrom] IdentityGetSharingGraphElement sharedFrom
         * @property {boolean|null} [latest] IdentityGetSharingGraphElement latest
         */

        /**
         * Constructs a new IdentityGetSharingGraphElement.
         * @memberof api
         * @classdesc Represents an IdentityGetSharingGraphElement.
         * @implements IIdentityGetSharingGraphElement
         * @constructor
         * @param {api.IIdentityGetSharingGraphElement=} [properties] Properties to set
         */
        function IdentityGetSharingGraphElement(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetSharingGraphElement login.
         * @member {string} login
         * @memberof api.IdentityGetSharingGraphElement
         * @instance
         */
        IdentityGetSharingGraphElement.prototype.login = "";

        /**
         * IdentityGetSharingGraphElement version.
         * @member {number} version
         * @memberof api.IdentityGetSharingGraphElement
         * @instance
         */
        IdentityGetSharingGraphElement.prototype.version = 0;

        /**
         * IdentityGetSharingGraphElement masterPublicKey.
         * @member {Uint8Array} masterPublicKey
         * @memberof api.IdentityGetSharingGraphElement
         * @instance
         */
        IdentityGetSharingGraphElement.prototype.masterPublicKey = $util.newBuffer([]);

        /**
         * IdentityGetSharingGraphElement sharingKey.
         * @member {api.ICipher|null|undefined} sharingKey
         * @memberof api.IdentityGetSharingGraphElement
         * @instance
         */
        IdentityGetSharingGraphElement.prototype.sharingKey = null;

        /**
         * IdentityGetSharingGraphElement boxKey.
         * @member {api.ICipher|null|undefined} boxKey
         * @memberof api.IdentityGetSharingGraphElement
         * @instance
         */
        IdentityGetSharingGraphElement.prototype.boxKey = null;

        /**
         * IdentityGetSharingGraphElement signKey.
         * @member {api.ICipher|null|undefined} signKey
         * @memberof api.IdentityGetSharingGraphElement
         * @instance
         */
        IdentityGetSharingGraphElement.prototype.signKey = null;

        /**
         * IdentityGetSharingGraphElement sharingGroup.
         * @member {Array.<api.IIdentityPublicKey>} sharingGroup
         * @memberof api.IdentityGetSharingGraphElement
         * @instance
         */
        IdentityGetSharingGraphElement.prototype.sharingGroup = $util.emptyArray;

        /**
         * IdentityGetSharingGraphElement sharedFrom.
         * @member {api.IIdentityKeyID|null|undefined} sharedFrom
         * @memberof api.IdentityGetSharingGraphElement
         * @instance
         */
        IdentityGetSharingGraphElement.prototype.sharedFrom = null;

        /**
         * IdentityGetSharingGraphElement latest.
         * @member {boolean} latest
         * @memberof api.IdentityGetSharingGraphElement
         * @instance
         */
        IdentityGetSharingGraphElement.prototype.latest = false;

        /**
         * Creates a new IdentityGetSharingGraphElement instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetSharingGraphElement
         * @static
         * @param {api.IIdentityGetSharingGraphElement=} [properties] Properties to set
         * @returns {api.IdentityGetSharingGraphElement} IdentityGetSharingGraphElement instance
         */
        IdentityGetSharingGraphElement.create = function create(properties) {
            return new IdentityGetSharingGraphElement(properties);
        };

        /**
         * Encodes the specified IdentityGetSharingGraphElement message. Does not implicitly {@link api.IdentityGetSharingGraphElement.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetSharingGraphElement
         * @static
         * @param {api.IIdentityGetSharingGraphElement} message IdentityGetSharingGraphElement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetSharingGraphElement.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            if (message.masterPublicKey != null && message.hasOwnProperty("masterPublicKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.masterPublicKey);
            if (message.sharingKey != null && message.hasOwnProperty("sharingKey"))
                $root.api.Cipher.encode(message.sharingKey, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.boxKey != null && message.hasOwnProperty("boxKey"))
                $root.api.Cipher.encode(message.boxKey, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.signKey != null && message.hasOwnProperty("signKey"))
                $root.api.Cipher.encode(message.signKey, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.api.IdentityPublicKey.encode(message.sharingGroup[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.sharedFrom != null && message.hasOwnProperty("sharedFrom"))
                $root.api.IdentityKeyID.encode(message.sharedFrom, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.latest != null && message.hasOwnProperty("latest"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.latest);
            return writer;
        };

        /**
         * Encodes the specified IdentityGetSharingGraphElement message, length delimited. Does not implicitly {@link api.IdentityGetSharingGraphElement.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetSharingGraphElement
         * @static
         * @param {api.IIdentityGetSharingGraphElement} message IdentityGetSharingGraphElement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetSharingGraphElement.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetSharingGraphElement message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetSharingGraphElement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetSharingGraphElement} IdentityGetSharingGraphElement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetSharingGraphElement.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetSharingGraphElement();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                case 3:
                    message.masterPublicKey = reader.bytes();
                    break;
                case 4:
                    message.sharingKey = $root.api.Cipher.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.boxKey = $root.api.Cipher.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.signKey = $root.api.Cipher.decode(reader, reader.uint32());
                    break;
                case 8:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.api.IdentityPublicKey.decode(reader, reader.uint32()));
                    break;
                case 9:
                    message.sharedFrom = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.latest = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetSharingGraphElement message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetSharingGraphElement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetSharingGraphElement} IdentityGetSharingGraphElement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetSharingGraphElement.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetSharingGraphElement message.
         * @function verify
         * @memberof api.IdentityGetSharingGraphElement
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetSharingGraphElement.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.masterPublicKey != null && message.hasOwnProperty("masterPublicKey"))
                if (!(message.masterPublicKey && typeof message.masterPublicKey.length === "number" || $util.isString(message.masterPublicKey)))
                    return "masterPublicKey: buffer expected";
            if (message.sharingKey != null && message.hasOwnProperty("sharingKey")) {
                var error = $root.api.Cipher.verify(message.sharingKey);
                if (error)
                    return "sharingKey." + error;
            }
            if (message.boxKey != null && message.hasOwnProperty("boxKey")) {
                var error = $root.api.Cipher.verify(message.boxKey);
                if (error)
                    return "boxKey." + error;
            }
            if (message.signKey != null && message.hasOwnProperty("signKey")) {
                var error = $root.api.Cipher.verify(message.signKey);
                if (error)
                    return "signKey." + error;
            }
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.api.IdentityPublicKey.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            if (message.sharedFrom != null && message.hasOwnProperty("sharedFrom")) {
                var error = $root.api.IdentityKeyID.verify(message.sharedFrom);
                if (error)
                    return "sharedFrom." + error;
            }
            if (message.latest != null && message.hasOwnProperty("latest"))
                if (typeof message.latest !== "boolean")
                    return "latest: boolean expected";
            return null;
        };

        /**
         * Creates an IdentityGetSharingGraphElement message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetSharingGraphElement
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetSharingGraphElement} IdentityGetSharingGraphElement
         */
        IdentityGetSharingGraphElement.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetSharingGraphElement)
                return object;
            var message = new $root.api.IdentityGetSharingGraphElement();
            if (object.login != null)
                message.login = String(object.login);
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.masterPublicKey != null)
                if (typeof object.masterPublicKey === "string")
                    $util.base64.decode(object.masterPublicKey, message.masterPublicKey = $util.newBuffer($util.base64.length(object.masterPublicKey)), 0);
                else if (object.masterPublicKey.length)
                    message.masterPublicKey = object.masterPublicKey;
            if (object.sharingKey != null) {
                if (typeof object.sharingKey !== "object")
                    throw TypeError(".api.IdentityGetSharingGraphElement.sharingKey: object expected");
                message.sharingKey = $root.api.Cipher.fromObject(object.sharingKey);
            }
            if (object.boxKey != null) {
                if (typeof object.boxKey !== "object")
                    throw TypeError(".api.IdentityGetSharingGraphElement.boxKey: object expected");
                message.boxKey = $root.api.Cipher.fromObject(object.boxKey);
            }
            if (object.signKey != null) {
                if (typeof object.signKey !== "object")
                    throw TypeError(".api.IdentityGetSharingGraphElement.signKey: object expected");
                message.signKey = $root.api.Cipher.fromObject(object.signKey);
            }
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".api.IdentityGetSharingGraphElement.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".api.IdentityGetSharingGraphElement.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.api.IdentityPublicKey.fromObject(object.sharingGroup[i]);
                }
            }
            if (object.sharedFrom != null) {
                if (typeof object.sharedFrom !== "object")
                    throw TypeError(".api.IdentityGetSharingGraphElement.sharedFrom: object expected");
                message.sharedFrom = $root.api.IdentityKeyID.fromObject(object.sharedFrom);
            }
            if (object.latest != null)
                message.latest = Boolean(object.latest);
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetSharingGraphElement message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetSharingGraphElement
         * @static
         * @param {api.IdentityGetSharingGraphElement} message IdentityGetSharingGraphElement
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetSharingGraphElement.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults) {
                object.login = "";
                object.version = 0;
                if (options.bytes === String)
                    object.masterPublicKey = "";
                else {
                    object.masterPublicKey = [];
                    if (options.bytes !== Array)
                        object.masterPublicKey = $util.newBuffer(object.masterPublicKey);
                }
                object.sharingKey = null;
                object.boxKey = null;
                object.signKey = null;
                object.sharedFrom = null;
                object.latest = false;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.masterPublicKey != null && message.hasOwnProperty("masterPublicKey"))
                object.masterPublicKey = options.bytes === String ? $util.base64.encode(message.masterPublicKey, 0, message.masterPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.masterPublicKey) : message.masterPublicKey;
            if (message.sharingKey != null && message.hasOwnProperty("sharingKey"))
                object.sharingKey = $root.api.Cipher.toObject(message.sharingKey, options);
            if (message.boxKey != null && message.hasOwnProperty("boxKey"))
                object.boxKey = $root.api.Cipher.toObject(message.boxKey, options);
            if (message.signKey != null && message.hasOwnProperty("signKey"))
                object.signKey = $root.api.Cipher.toObject(message.signKey, options);
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.api.IdentityPublicKey.toObject(message.sharingGroup[j], options);
            }
            if (message.sharedFrom != null && message.hasOwnProperty("sharedFrom"))
                object.sharedFrom = $root.api.IdentityKeyID.toObject(message.sharedFrom, options);
            if (message.latest != null && message.hasOwnProperty("latest"))
                object.latest = message.latest;
            return object;
        };

        /**
         * Converts this IdentityGetSharingGraphElement to JSON.
         * @function toJSON
         * @memberof api.IdentityGetSharingGraphElement
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetSharingGraphElement.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetSharingGraphElement;
    })();

    api.IdentityGetSharingGraphResponse = (function() {

        /**
         * Properties of an IdentityGetSharingGraphResponse.
         * @memberof api
         * @interface IIdentityGetSharingGraphResponse
         * @property {Array.<api.IIdentityGetSharingGraphElement>|null} [graph] IdentityGetSharingGraphResponse graph
         */

        /**
         * Constructs a new IdentityGetSharingGraphResponse.
         * @memberof api
         * @classdesc Represents an IdentityGetSharingGraphResponse.
         * @implements IIdentityGetSharingGraphResponse
         * @constructor
         * @param {api.IIdentityGetSharingGraphResponse=} [properties] Properties to set
         */
        function IdentityGetSharingGraphResponse(properties) {
            this.graph = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetSharingGraphResponse graph.
         * @member {Array.<api.IIdentityGetSharingGraphElement>} graph
         * @memberof api.IdentityGetSharingGraphResponse
         * @instance
         */
        IdentityGetSharingGraphResponse.prototype.graph = $util.emptyArray;

        /**
         * Creates a new IdentityGetSharingGraphResponse instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetSharingGraphResponse
         * @static
         * @param {api.IIdentityGetSharingGraphResponse=} [properties] Properties to set
         * @returns {api.IdentityGetSharingGraphResponse} IdentityGetSharingGraphResponse instance
         */
        IdentityGetSharingGraphResponse.create = function create(properties) {
            return new IdentityGetSharingGraphResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetSharingGraphResponse message. Does not implicitly {@link api.IdentityGetSharingGraphResponse.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetSharingGraphResponse
         * @static
         * @param {api.IIdentityGetSharingGraphResponse} message IdentityGetSharingGraphResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetSharingGraphResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.graph != null && message.graph.length)
                for (var i = 0; i < message.graph.length; ++i)
                    $root.api.IdentityGetSharingGraphElement.encode(message.graph[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetSharingGraphResponse message, length delimited. Does not implicitly {@link api.IdentityGetSharingGraphResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetSharingGraphResponse
         * @static
         * @param {api.IIdentityGetSharingGraphResponse} message IdentityGetSharingGraphResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetSharingGraphResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetSharingGraphResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetSharingGraphResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetSharingGraphResponse} IdentityGetSharingGraphResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetSharingGraphResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetSharingGraphResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.graph && message.graph.length))
                        message.graph = [];
                    message.graph.push($root.api.IdentityGetSharingGraphElement.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetSharingGraphResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetSharingGraphResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetSharingGraphResponse} IdentityGetSharingGraphResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetSharingGraphResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetSharingGraphResponse message.
         * @function verify
         * @memberof api.IdentityGetSharingGraphResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetSharingGraphResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.graph != null && message.hasOwnProperty("graph")) {
                if (!Array.isArray(message.graph))
                    return "graph: array expected";
                for (var i = 0; i < message.graph.length; ++i) {
                    var error = $root.api.IdentityGetSharingGraphElement.verify(message.graph[i]);
                    if (error)
                        return "graph." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetSharingGraphResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetSharingGraphResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetSharingGraphResponse} IdentityGetSharingGraphResponse
         */
        IdentityGetSharingGraphResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetSharingGraphResponse)
                return object;
            var message = new $root.api.IdentityGetSharingGraphResponse();
            if (object.graph) {
                if (!Array.isArray(object.graph))
                    throw TypeError(".api.IdentityGetSharingGraphResponse.graph: array expected");
                message.graph = [];
                for (var i = 0; i < object.graph.length; ++i) {
                    if (typeof object.graph[i] !== "object")
                        throw TypeError(".api.IdentityGetSharingGraphResponse.graph: object expected");
                    message.graph[i] = $root.api.IdentityGetSharingGraphElement.fromObject(object.graph[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetSharingGraphResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetSharingGraphResponse
         * @static
         * @param {api.IdentityGetSharingGraphResponse} message IdentityGetSharingGraphResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetSharingGraphResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.graph = [];
            if (message.graph && message.graph.length) {
                object.graph = [];
                for (var j = 0; j < message.graph.length; ++j)
                    object.graph[j] = $root.api.IdentityGetSharingGraphElement.toObject(message.graph[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetSharingGraphResponse to JSON.
         * @function toJSON
         * @memberof api.IdentityGetSharingGraphResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetSharingGraphResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetSharingGraphResponse;
    })();

    api.IdentityPostSharingGraphElement = (function() {

        /**
         * Properties of an IdentityPostSharingGraphElement.
         * @memberof api
         * @interface IIdentityPostSharingGraphElement
         * @property {string|null} [login] IdentityPostSharingGraphElement login
         * @property {number|null} [version] IdentityPostSharingGraphElement version
         * @property {Uint8Array|null} [signChain] IdentityPostSharingGraphElement signChain
         * @property {Array.<api.IIdentityShareEntry>|null} [sharingGroup] IdentityPostSharingGraphElement sharingGroup
         * @property {api.IIdentityBackwardKey|null} [backward] IdentityPostSharingGraphElement backward
         * @property {api.IIdentityEncryption|null} [encryption] IdentityPostSharingGraphElement encryption
         */

        /**
         * Constructs a new IdentityPostSharingGraphElement.
         * @memberof api
         * @classdesc Represents an IdentityPostSharingGraphElement.
         * @implements IIdentityPostSharingGraphElement
         * @constructor
         * @param {api.IIdentityPostSharingGraphElement=} [properties] Properties to set
         */
        function IdentityPostSharingGraphElement(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityPostSharingGraphElement login.
         * @member {string} login
         * @memberof api.IdentityPostSharingGraphElement
         * @instance
         */
        IdentityPostSharingGraphElement.prototype.login = "";

        /**
         * IdentityPostSharingGraphElement version.
         * @member {number} version
         * @memberof api.IdentityPostSharingGraphElement
         * @instance
         */
        IdentityPostSharingGraphElement.prototype.version = 0;

        /**
         * IdentityPostSharingGraphElement signChain.
         * @member {Uint8Array} signChain
         * @memberof api.IdentityPostSharingGraphElement
         * @instance
         */
        IdentityPostSharingGraphElement.prototype.signChain = $util.newBuffer([]);

        /**
         * IdentityPostSharingGraphElement sharingGroup.
         * @member {Array.<api.IIdentityShareEntry>} sharingGroup
         * @memberof api.IdentityPostSharingGraphElement
         * @instance
         */
        IdentityPostSharingGraphElement.prototype.sharingGroup = $util.emptyArray;

        /**
         * IdentityPostSharingGraphElement backward.
         * @member {api.IIdentityBackwardKey|null|undefined} backward
         * @memberof api.IdentityPostSharingGraphElement
         * @instance
         */
        IdentityPostSharingGraphElement.prototype.backward = null;

        /**
         * IdentityPostSharingGraphElement encryption.
         * @member {api.IIdentityEncryption|null|undefined} encryption
         * @memberof api.IdentityPostSharingGraphElement
         * @instance
         */
        IdentityPostSharingGraphElement.prototype.encryption = null;

        /**
         * Creates a new IdentityPostSharingGraphElement instance using the specified properties.
         * @function create
         * @memberof api.IdentityPostSharingGraphElement
         * @static
         * @param {api.IIdentityPostSharingGraphElement=} [properties] Properties to set
         * @returns {api.IdentityPostSharingGraphElement} IdentityPostSharingGraphElement instance
         */
        IdentityPostSharingGraphElement.create = function create(properties) {
            return new IdentityPostSharingGraphElement(properties);
        };

        /**
         * Encodes the specified IdentityPostSharingGraphElement message. Does not implicitly {@link api.IdentityPostSharingGraphElement.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityPostSharingGraphElement
         * @static
         * @param {api.IIdentityPostSharingGraphElement} message IdentityPostSharingGraphElement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPostSharingGraphElement.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.signChain);
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.api.IdentityShareEntry.encode(message.sharingGroup[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.backward != null && message.hasOwnProperty("backward"))
                $root.api.IdentityBackwardKey.encode(message.backward, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.api.IdentityEncryption.encode(message.encryption, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityPostSharingGraphElement message, length delimited. Does not implicitly {@link api.IdentityPostSharingGraphElement.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityPostSharingGraphElement
         * @static
         * @param {api.IIdentityPostSharingGraphElement} message IdentityPostSharingGraphElement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPostSharingGraphElement.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityPostSharingGraphElement message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityPostSharingGraphElement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityPostSharingGraphElement} IdentityPostSharingGraphElement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPostSharingGraphElement.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityPostSharingGraphElement();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                case 7:
                    message.signChain = reader.bytes();
                    break;
                case 8:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.api.IdentityShareEntry.decode(reader, reader.uint32()));
                    break;
                case 9:
                    message.backward = $root.api.IdentityBackwardKey.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.encryption = $root.api.IdentityEncryption.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityPostSharingGraphElement message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityPostSharingGraphElement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityPostSharingGraphElement} IdentityPostSharingGraphElement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPostSharingGraphElement.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityPostSharingGraphElement message.
         * @function verify
         * @memberof api.IdentityPostSharingGraphElement
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityPostSharingGraphElement.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                if (!(message.signChain && typeof message.signChain.length === "number" || $util.isString(message.signChain)))
                    return "signChain: buffer expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.api.IdentityShareEntry.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            if (message.backward != null && message.hasOwnProperty("backward")) {
                var error = $root.api.IdentityBackwardKey.verify(message.backward);
                if (error)
                    return "backward." + error;
            }
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.api.IdentityEncryption.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            return null;
        };

        /**
         * Creates an IdentityPostSharingGraphElement message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityPostSharingGraphElement
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityPostSharingGraphElement} IdentityPostSharingGraphElement
         */
        IdentityPostSharingGraphElement.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityPostSharingGraphElement)
                return object;
            var message = new $root.api.IdentityPostSharingGraphElement();
            if (object.login != null)
                message.login = String(object.login);
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.signChain != null)
                if (typeof object.signChain === "string")
                    $util.base64.decode(object.signChain, message.signChain = $util.newBuffer($util.base64.length(object.signChain)), 0);
                else if (object.signChain.length)
                    message.signChain = object.signChain;
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".api.IdentityPostSharingGraphElement.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".api.IdentityPostSharingGraphElement.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.api.IdentityShareEntry.fromObject(object.sharingGroup[i]);
                }
            }
            if (object.backward != null) {
                if (typeof object.backward !== "object")
                    throw TypeError(".api.IdentityPostSharingGraphElement.backward: object expected");
                message.backward = $root.api.IdentityBackwardKey.fromObject(object.backward);
            }
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".api.IdentityPostSharingGraphElement.encryption: object expected");
                message.encryption = $root.api.IdentityEncryption.fromObject(object.encryption);
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityPostSharingGraphElement message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityPostSharingGraphElement
         * @static
         * @param {api.IdentityPostSharingGraphElement} message IdentityPostSharingGraphElement
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityPostSharingGraphElement.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults) {
                object.login = "";
                object.version = 0;
                if (options.bytes === String)
                    object.signChain = "";
                else {
                    object.signChain = [];
                    if (options.bytes !== Array)
                        object.signChain = $util.newBuffer(object.signChain);
                }
                object.backward = null;
                object.encryption = null;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                object.signChain = options.bytes === String ? $util.base64.encode(message.signChain, 0, message.signChain.length) : options.bytes === Array ? Array.prototype.slice.call(message.signChain) : message.signChain;
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.api.IdentityShareEntry.toObject(message.sharingGroup[j], options);
            }
            if (message.backward != null && message.hasOwnProperty("backward"))
                object.backward = $root.api.IdentityBackwardKey.toObject(message.backward, options);
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.api.IdentityEncryption.toObject(message.encryption, options);
            return object;
        };

        /**
         * Converts this IdentityPostSharingGraphElement to JSON.
         * @function toJSON
         * @memberof api.IdentityPostSharingGraphElement
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityPostSharingGraphElement.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityPostSharingGraphElement;
    })();

    api.IdentityPostSharingGraphRequest = (function() {

        /**
         * Properties of an IdentityPostSharingGraphRequest.
         * @memberof api
         * @interface IIdentityPostSharingGraphRequest
         * @property {string|null} [login] IdentityPostSharingGraphRequest login
         * @property {Array.<api.IIdentityPostSharingGraphElement>|null} [graph] IdentityPostSharingGraphRequest graph
         */

        /**
         * Constructs a new IdentityPostSharingGraphRequest.
         * @memberof api
         * @classdesc Represents an IdentityPostSharingGraphRequest.
         * @implements IIdentityPostSharingGraphRequest
         * @constructor
         * @param {api.IIdentityPostSharingGraphRequest=} [properties] Properties to set
         */
        function IdentityPostSharingGraphRequest(properties) {
            this.graph = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityPostSharingGraphRequest login.
         * @member {string} login
         * @memberof api.IdentityPostSharingGraphRequest
         * @instance
         */
        IdentityPostSharingGraphRequest.prototype.login = "";

        /**
         * IdentityPostSharingGraphRequest graph.
         * @member {Array.<api.IIdentityPostSharingGraphElement>} graph
         * @memberof api.IdentityPostSharingGraphRequest
         * @instance
         */
        IdentityPostSharingGraphRequest.prototype.graph = $util.emptyArray;

        /**
         * Creates a new IdentityPostSharingGraphRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityPostSharingGraphRequest
         * @static
         * @param {api.IIdentityPostSharingGraphRequest=} [properties] Properties to set
         * @returns {api.IdentityPostSharingGraphRequest} IdentityPostSharingGraphRequest instance
         */
        IdentityPostSharingGraphRequest.create = function create(properties) {
            return new IdentityPostSharingGraphRequest(properties);
        };

        /**
         * Encodes the specified IdentityPostSharingGraphRequest message. Does not implicitly {@link api.IdentityPostSharingGraphRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityPostSharingGraphRequest
         * @static
         * @param {api.IIdentityPostSharingGraphRequest} message IdentityPostSharingGraphRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPostSharingGraphRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.graph != null && message.graph.length)
                for (var i = 0; i < message.graph.length; ++i)
                    $root.api.IdentityPostSharingGraphElement.encode(message.graph[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityPostSharingGraphRequest message, length delimited. Does not implicitly {@link api.IdentityPostSharingGraphRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityPostSharingGraphRequest
         * @static
         * @param {api.IIdentityPostSharingGraphRequest} message IdentityPostSharingGraphRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPostSharingGraphRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityPostSharingGraphRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityPostSharingGraphRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityPostSharingGraphRequest} IdentityPostSharingGraphRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPostSharingGraphRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityPostSharingGraphRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    if (!(message.graph && message.graph.length))
                        message.graph = [];
                    message.graph.push($root.api.IdentityPostSharingGraphElement.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityPostSharingGraphRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityPostSharingGraphRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityPostSharingGraphRequest} IdentityPostSharingGraphRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPostSharingGraphRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityPostSharingGraphRequest message.
         * @function verify
         * @memberof api.IdentityPostSharingGraphRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityPostSharingGraphRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.graph != null && message.hasOwnProperty("graph")) {
                if (!Array.isArray(message.graph))
                    return "graph: array expected";
                for (var i = 0; i < message.graph.length; ++i) {
                    var error = $root.api.IdentityPostSharingGraphElement.verify(message.graph[i]);
                    if (error)
                        return "graph." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityPostSharingGraphRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityPostSharingGraphRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityPostSharingGraphRequest} IdentityPostSharingGraphRequest
         */
        IdentityPostSharingGraphRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityPostSharingGraphRequest)
                return object;
            var message = new $root.api.IdentityPostSharingGraphRequest();
            if (object.login != null)
                message.login = String(object.login);
            if (object.graph) {
                if (!Array.isArray(object.graph))
                    throw TypeError(".api.IdentityPostSharingGraphRequest.graph: array expected");
                message.graph = [];
                for (var i = 0; i < object.graph.length; ++i) {
                    if (typeof object.graph[i] !== "object")
                        throw TypeError(".api.IdentityPostSharingGraphRequest.graph: object expected");
                    message.graph[i] = $root.api.IdentityPostSharingGraphElement.fromObject(object.graph[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityPostSharingGraphRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityPostSharingGraphRequest
         * @static
         * @param {api.IdentityPostSharingGraphRequest} message IdentityPostSharingGraphRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityPostSharingGraphRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.graph = [];
            if (options.defaults)
                object.login = "";
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.graph && message.graph.length) {
                object.graph = [];
                for (var j = 0; j < message.graph.length; ++j)
                    object.graph[j] = $root.api.IdentityPostSharingGraphElement.toObject(message.graph[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityPostSharingGraphRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityPostSharingGraphRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityPostSharingGraphRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityPostSharingGraphRequest;
    })();

    api.IdentityToggleActiveStatusRequest = (function() {

        /**
         * Properties of an IdentityToggleActiveStatusRequest.
         * @memberof api
         * @interface IIdentityToggleActiveStatusRequest
         * @property {string|null} [login] IdentityToggleActiveStatusRequest login
         * @property {boolean|null} [active] IdentityToggleActiveStatusRequest active
         */

        /**
         * Constructs a new IdentityToggleActiveStatusRequest.
         * @memberof api
         * @classdesc Represents an IdentityToggleActiveStatusRequest.
         * @implements IIdentityToggleActiveStatusRequest
         * @constructor
         * @param {api.IIdentityToggleActiveStatusRequest=} [properties] Properties to set
         */
        function IdentityToggleActiveStatusRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityToggleActiveStatusRequest login.
         * @member {string} login
         * @memberof api.IdentityToggleActiveStatusRequest
         * @instance
         */
        IdentityToggleActiveStatusRequest.prototype.login = "";

        /**
         * IdentityToggleActiveStatusRequest active.
         * @member {boolean} active
         * @memberof api.IdentityToggleActiveStatusRequest
         * @instance
         */
        IdentityToggleActiveStatusRequest.prototype.active = false;

        /**
         * Creates a new IdentityToggleActiveStatusRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityToggleActiveStatusRequest
         * @static
         * @param {api.IIdentityToggleActiveStatusRequest=} [properties] Properties to set
         * @returns {api.IdentityToggleActiveStatusRequest} IdentityToggleActiveStatusRequest instance
         */
        IdentityToggleActiveStatusRequest.create = function create(properties) {
            return new IdentityToggleActiveStatusRequest(properties);
        };

        /**
         * Encodes the specified IdentityToggleActiveStatusRequest message. Does not implicitly {@link api.IdentityToggleActiveStatusRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityToggleActiveStatusRequest
         * @static
         * @param {api.IIdentityToggleActiveStatusRequest} message IdentityToggleActiveStatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityToggleActiveStatusRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.active != null && message.hasOwnProperty("active"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.active);
            return writer;
        };

        /**
         * Encodes the specified IdentityToggleActiveStatusRequest message, length delimited. Does not implicitly {@link api.IdentityToggleActiveStatusRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityToggleActiveStatusRequest
         * @static
         * @param {api.IIdentityToggleActiveStatusRequest} message IdentityToggleActiveStatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityToggleActiveStatusRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityToggleActiveStatusRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityToggleActiveStatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityToggleActiveStatusRequest} IdentityToggleActiveStatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityToggleActiveStatusRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityToggleActiveStatusRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.active = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityToggleActiveStatusRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityToggleActiveStatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityToggleActiveStatusRequest} IdentityToggleActiveStatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityToggleActiveStatusRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityToggleActiveStatusRequest message.
         * @function verify
         * @memberof api.IdentityToggleActiveStatusRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityToggleActiveStatusRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.active != null && message.hasOwnProperty("active"))
                if (typeof message.active !== "boolean")
                    return "active: boolean expected";
            return null;
        };

        /**
         * Creates an IdentityToggleActiveStatusRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityToggleActiveStatusRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityToggleActiveStatusRequest} IdentityToggleActiveStatusRequest
         */
        IdentityToggleActiveStatusRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityToggleActiveStatusRequest)
                return object;
            var message = new $root.api.IdentityToggleActiveStatusRequest();
            if (object.login != null)
                message.login = String(object.login);
            if (object.active != null)
                message.active = Boolean(object.active);
            return message;
        };

        /**
         * Creates a plain object from an IdentityToggleActiveStatusRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityToggleActiveStatusRequest
         * @static
         * @param {api.IdentityToggleActiveStatusRequest} message IdentityToggleActiveStatusRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityToggleActiveStatusRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.active = false;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.active != null && message.hasOwnProperty("active"))
                object.active = message.active;
            return object;
        };

        /**
         * Converts this IdentityToggleActiveStatusRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityToggleActiveStatusRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityToggleActiveStatusRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityToggleActiveStatusRequest;
    })();

    api.IdentityGetLockedVersionsResponse = (function() {

        /**
         * Properties of an IdentityGetLockedVersionsResponse.
         * @memberof api
         * @interface IIdentityGetLockedVersionsResponse
         * @property {Array.<api.IdentityGetLockedVersionsResponse.ILockedVersion>|null} [lockedVersions] IdentityGetLockedVersionsResponse lockedVersions
         */

        /**
         * Constructs a new IdentityGetLockedVersionsResponse.
         * @memberof api
         * @classdesc Represents an IdentityGetLockedVersionsResponse.
         * @implements IIdentityGetLockedVersionsResponse
         * @constructor
         * @param {api.IIdentityGetLockedVersionsResponse=} [properties] Properties to set
         */
        function IdentityGetLockedVersionsResponse(properties) {
            this.lockedVersions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetLockedVersionsResponse lockedVersions.
         * @member {Array.<api.IdentityGetLockedVersionsResponse.ILockedVersion>} lockedVersions
         * @memberof api.IdentityGetLockedVersionsResponse
         * @instance
         */
        IdentityGetLockedVersionsResponse.prototype.lockedVersions = $util.emptyArray;

        /**
         * Creates a new IdentityGetLockedVersionsResponse instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetLockedVersionsResponse
         * @static
         * @param {api.IIdentityGetLockedVersionsResponse=} [properties] Properties to set
         * @returns {api.IdentityGetLockedVersionsResponse} IdentityGetLockedVersionsResponse instance
         */
        IdentityGetLockedVersionsResponse.create = function create(properties) {
            return new IdentityGetLockedVersionsResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetLockedVersionsResponse message. Does not implicitly {@link api.IdentityGetLockedVersionsResponse.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetLockedVersionsResponse
         * @static
         * @param {api.IIdentityGetLockedVersionsResponse} message IdentityGetLockedVersionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLockedVersionsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lockedVersions != null && message.lockedVersions.length)
                for (var i = 0; i < message.lockedVersions.length; ++i)
                    $root.api.IdentityGetLockedVersionsResponse.LockedVersion.encode(message.lockedVersions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetLockedVersionsResponse message, length delimited. Does not implicitly {@link api.IdentityGetLockedVersionsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetLockedVersionsResponse
         * @static
         * @param {api.IIdentityGetLockedVersionsResponse} message IdentityGetLockedVersionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLockedVersionsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetLockedVersionsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetLockedVersionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetLockedVersionsResponse} IdentityGetLockedVersionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLockedVersionsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetLockedVersionsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.lockedVersions && message.lockedVersions.length))
                        message.lockedVersions = [];
                    message.lockedVersions.push($root.api.IdentityGetLockedVersionsResponse.LockedVersion.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetLockedVersionsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetLockedVersionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetLockedVersionsResponse} IdentityGetLockedVersionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLockedVersionsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetLockedVersionsResponse message.
         * @function verify
         * @memberof api.IdentityGetLockedVersionsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetLockedVersionsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.lockedVersions != null && message.hasOwnProperty("lockedVersions")) {
                if (!Array.isArray(message.lockedVersions))
                    return "lockedVersions: array expected";
                for (var i = 0; i < message.lockedVersions.length; ++i) {
                    var error = $root.api.IdentityGetLockedVersionsResponse.LockedVersion.verify(message.lockedVersions[i]);
                    if (error)
                        return "lockedVersions." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetLockedVersionsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetLockedVersionsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetLockedVersionsResponse} IdentityGetLockedVersionsResponse
         */
        IdentityGetLockedVersionsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetLockedVersionsResponse)
                return object;
            var message = new $root.api.IdentityGetLockedVersionsResponse();
            if (object.lockedVersions) {
                if (!Array.isArray(object.lockedVersions))
                    throw TypeError(".api.IdentityGetLockedVersionsResponse.lockedVersions: array expected");
                message.lockedVersions = [];
                for (var i = 0; i < object.lockedVersions.length; ++i) {
                    if (typeof object.lockedVersions[i] !== "object")
                        throw TypeError(".api.IdentityGetLockedVersionsResponse.lockedVersions: object expected");
                    message.lockedVersions[i] = $root.api.IdentityGetLockedVersionsResponse.LockedVersion.fromObject(object.lockedVersions[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetLockedVersionsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetLockedVersionsResponse
         * @static
         * @param {api.IdentityGetLockedVersionsResponse} message IdentityGetLockedVersionsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetLockedVersionsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.lockedVersions = [];
            if (message.lockedVersions && message.lockedVersions.length) {
                object.lockedVersions = [];
                for (var j = 0; j < message.lockedVersions.length; ++j)
                    object.lockedVersions[j] = $root.api.IdentityGetLockedVersionsResponse.LockedVersion.toObject(message.lockedVersions[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetLockedVersionsResponse to JSON.
         * @function toJSON
         * @memberof api.IdentityGetLockedVersionsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetLockedVersionsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        IdentityGetLockedVersionsResponse.IdentityChallenge = (function() {

            /**
             * Properties of an IdentityChallenge.
             * @memberof api.IdentityGetLockedVersionsResponse
             * @interface IIdentityChallenge
             * @property {Uint8Array|null} [salt] IdentityChallenge salt
             * @property {Uint8Array|null} [token] IdentityChallenge token
             * @property {api.IIdentityEncryption|null} [encryption] IdentityChallenge encryption
             * @property {api.IIdentityPublicKey|null} [creator] IdentityChallenge creator
             */

            /**
             * Constructs a new IdentityChallenge.
             * @memberof api.IdentityGetLockedVersionsResponse
             * @classdesc Represents an IdentityChallenge.
             * @implements IIdentityChallenge
             * @constructor
             * @param {api.IdentityGetLockedVersionsResponse.IIdentityChallenge=} [properties] Properties to set
             */
            function IdentityChallenge(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IdentityChallenge salt.
             * @member {Uint8Array} salt
             * @memberof api.IdentityGetLockedVersionsResponse.IdentityChallenge
             * @instance
             */
            IdentityChallenge.prototype.salt = $util.newBuffer([]);

            /**
             * IdentityChallenge token.
             * @member {Uint8Array} token
             * @memberof api.IdentityGetLockedVersionsResponse.IdentityChallenge
             * @instance
             */
            IdentityChallenge.prototype.token = $util.newBuffer([]);

            /**
             * IdentityChallenge encryption.
             * @member {api.IIdentityEncryption|null|undefined} encryption
             * @memberof api.IdentityGetLockedVersionsResponse.IdentityChallenge
             * @instance
             */
            IdentityChallenge.prototype.encryption = null;

            /**
             * IdentityChallenge creator.
             * @member {api.IIdentityPublicKey|null|undefined} creator
             * @memberof api.IdentityGetLockedVersionsResponse.IdentityChallenge
             * @instance
             */
            IdentityChallenge.prototype.creator = null;

            /**
             * Creates a new IdentityChallenge instance using the specified properties.
             * @function create
             * @memberof api.IdentityGetLockedVersionsResponse.IdentityChallenge
             * @static
             * @param {api.IdentityGetLockedVersionsResponse.IIdentityChallenge=} [properties] Properties to set
             * @returns {api.IdentityGetLockedVersionsResponse.IdentityChallenge} IdentityChallenge instance
             */
            IdentityChallenge.create = function create(properties) {
                return new IdentityChallenge(properties);
            };

            /**
             * Encodes the specified IdentityChallenge message. Does not implicitly {@link api.IdentityGetLockedVersionsResponse.IdentityChallenge.verify|verify} messages.
             * @function encode
             * @memberof api.IdentityGetLockedVersionsResponse.IdentityChallenge
             * @static
             * @param {api.IdentityGetLockedVersionsResponse.IIdentityChallenge} message IdentityChallenge message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IdentityChallenge.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.salt != null && message.hasOwnProperty("salt"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.salt);
                if (message.token != null && message.hasOwnProperty("token"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.token);
                if (message.encryption != null && message.hasOwnProperty("encryption"))
                    $root.api.IdentityEncryption.encode(message.encryption, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.creator != null && message.hasOwnProperty("creator"))
                    $root.api.IdentityPublicKey.encode(message.creator, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified IdentityChallenge message, length delimited. Does not implicitly {@link api.IdentityGetLockedVersionsResponse.IdentityChallenge.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.IdentityGetLockedVersionsResponse.IdentityChallenge
             * @static
             * @param {api.IdentityGetLockedVersionsResponse.IIdentityChallenge} message IdentityChallenge message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IdentityChallenge.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an IdentityChallenge message from the specified reader or buffer.
             * @function decode
             * @memberof api.IdentityGetLockedVersionsResponse.IdentityChallenge
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.IdentityGetLockedVersionsResponse.IdentityChallenge} IdentityChallenge
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IdentityChallenge.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetLockedVersionsResponse.IdentityChallenge();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.salt = reader.bytes();
                        break;
                    case 2:
                        message.token = reader.bytes();
                        break;
                    case 3:
                        message.encryption = $root.api.IdentityEncryption.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.creator = $root.api.IdentityPublicKey.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an IdentityChallenge message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.IdentityGetLockedVersionsResponse.IdentityChallenge
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.IdentityGetLockedVersionsResponse.IdentityChallenge} IdentityChallenge
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IdentityChallenge.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an IdentityChallenge message.
             * @function verify
             * @memberof api.IdentityGetLockedVersionsResponse.IdentityChallenge
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IdentityChallenge.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.salt != null && message.hasOwnProperty("salt"))
                    if (!(message.salt && typeof message.salt.length === "number" || $util.isString(message.salt)))
                        return "salt: buffer expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                        return "token: buffer expected";
                if (message.encryption != null && message.hasOwnProperty("encryption")) {
                    var error = $root.api.IdentityEncryption.verify(message.encryption);
                    if (error)
                        return "encryption." + error;
                }
                if (message.creator != null && message.hasOwnProperty("creator")) {
                    var error = $root.api.IdentityPublicKey.verify(message.creator);
                    if (error)
                        return "creator." + error;
                }
                return null;
            };

            /**
             * Creates an IdentityChallenge message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.IdentityGetLockedVersionsResponse.IdentityChallenge
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.IdentityGetLockedVersionsResponse.IdentityChallenge} IdentityChallenge
             */
            IdentityChallenge.fromObject = function fromObject(object) {
                if (object instanceof $root.api.IdentityGetLockedVersionsResponse.IdentityChallenge)
                    return object;
                var message = new $root.api.IdentityGetLockedVersionsResponse.IdentityChallenge();
                if (object.salt != null)
                    if (typeof object.salt === "string")
                        $util.base64.decode(object.salt, message.salt = $util.newBuffer($util.base64.length(object.salt)), 0);
                    else if (object.salt.length)
                        message.salt = object.salt;
                if (object.token != null)
                    if (typeof object.token === "string")
                        $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                    else if (object.token.length)
                        message.token = object.token;
                if (object.encryption != null) {
                    if (typeof object.encryption !== "object")
                        throw TypeError(".api.IdentityGetLockedVersionsResponse.IdentityChallenge.encryption: object expected");
                    message.encryption = $root.api.IdentityEncryption.fromObject(object.encryption);
                }
                if (object.creator != null) {
                    if (typeof object.creator !== "object")
                        throw TypeError(".api.IdentityGetLockedVersionsResponse.IdentityChallenge.creator: object expected");
                    message.creator = $root.api.IdentityPublicKey.fromObject(object.creator);
                }
                return message;
            };

            /**
             * Creates a plain object from an IdentityChallenge message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.IdentityGetLockedVersionsResponse.IdentityChallenge
             * @static
             * @param {api.IdentityGetLockedVersionsResponse.IdentityChallenge} message IdentityChallenge
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IdentityChallenge.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.salt = "";
                    else {
                        object.salt = [];
                        if (options.bytes !== Array)
                            object.salt = $util.newBuffer(object.salt);
                    }
                    if (options.bytes === String)
                        object.token = "";
                    else {
                        object.token = [];
                        if (options.bytes !== Array)
                            object.token = $util.newBuffer(object.token);
                    }
                    object.encryption = null;
                    object.creator = null;
                }
                if (message.salt != null && message.hasOwnProperty("salt"))
                    object.salt = options.bytes === String ? $util.base64.encode(message.salt, 0, message.salt.length) : options.bytes === Array ? Array.prototype.slice.call(message.salt) : message.salt;
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
                if (message.encryption != null && message.hasOwnProperty("encryption"))
                    object.encryption = $root.api.IdentityEncryption.toObject(message.encryption, options);
                if (message.creator != null && message.hasOwnProperty("creator"))
                    object.creator = $root.api.IdentityPublicKey.toObject(message.creator, options);
                return object;
            };

            /**
             * Converts this IdentityChallenge to JSON.
             * @function toJSON
             * @memberof api.IdentityGetLockedVersionsResponse.IdentityChallenge
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IdentityChallenge.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return IdentityChallenge;
        })();

        IdentityGetLockedVersionsResponse.LockedVersion = (function() {

            /**
             * Properties of a LockedVersion.
             * @memberof api.IdentityGetLockedVersionsResponse
             * @interface ILockedVersion
             * @property {api.IIdentityPublicKeyWithMetadata|null} [publicKey] LockedVersion publicKey
             * @property {api.IdentityGetLockedVersionsResponse.IIdentityChallenge|null} [challenge] LockedVersion challenge
             */

            /**
             * Constructs a new LockedVersion.
             * @memberof api.IdentityGetLockedVersionsResponse
             * @classdesc Represents a LockedVersion.
             * @implements ILockedVersion
             * @constructor
             * @param {api.IdentityGetLockedVersionsResponse.ILockedVersion=} [properties] Properties to set
             */
            function LockedVersion(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LockedVersion publicKey.
             * @member {api.IIdentityPublicKeyWithMetadata|null|undefined} publicKey
             * @memberof api.IdentityGetLockedVersionsResponse.LockedVersion
             * @instance
             */
            LockedVersion.prototype.publicKey = null;

            /**
             * LockedVersion challenge.
             * @member {api.IdentityGetLockedVersionsResponse.IIdentityChallenge|null|undefined} challenge
             * @memberof api.IdentityGetLockedVersionsResponse.LockedVersion
             * @instance
             */
            LockedVersion.prototype.challenge = null;

            /**
             * Creates a new LockedVersion instance using the specified properties.
             * @function create
             * @memberof api.IdentityGetLockedVersionsResponse.LockedVersion
             * @static
             * @param {api.IdentityGetLockedVersionsResponse.ILockedVersion=} [properties] Properties to set
             * @returns {api.IdentityGetLockedVersionsResponse.LockedVersion} LockedVersion instance
             */
            LockedVersion.create = function create(properties) {
                return new LockedVersion(properties);
            };

            /**
             * Encodes the specified LockedVersion message. Does not implicitly {@link api.IdentityGetLockedVersionsResponse.LockedVersion.verify|verify} messages.
             * @function encode
             * @memberof api.IdentityGetLockedVersionsResponse.LockedVersion
             * @static
             * @param {api.IdentityGetLockedVersionsResponse.ILockedVersion} message LockedVersion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LockedVersion.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                    $root.api.IdentityPublicKeyWithMetadata.encode(message.publicKey, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.challenge != null && message.hasOwnProperty("challenge"))
                    $root.api.IdentityGetLockedVersionsResponse.IdentityChallenge.encode(message.challenge, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified LockedVersion message, length delimited. Does not implicitly {@link api.IdentityGetLockedVersionsResponse.LockedVersion.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.IdentityGetLockedVersionsResponse.LockedVersion
             * @static
             * @param {api.IdentityGetLockedVersionsResponse.ILockedVersion} message LockedVersion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LockedVersion.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LockedVersion message from the specified reader or buffer.
             * @function decode
             * @memberof api.IdentityGetLockedVersionsResponse.LockedVersion
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.IdentityGetLockedVersionsResponse.LockedVersion} LockedVersion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LockedVersion.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetLockedVersionsResponse.LockedVersion();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.publicKey = $root.api.IdentityPublicKeyWithMetadata.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.challenge = $root.api.IdentityGetLockedVersionsResponse.IdentityChallenge.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LockedVersion message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.IdentityGetLockedVersionsResponse.LockedVersion
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.IdentityGetLockedVersionsResponse.LockedVersion} LockedVersion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LockedVersion.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LockedVersion message.
             * @function verify
             * @memberof api.IdentityGetLockedVersionsResponse.LockedVersion
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LockedVersion.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.publicKey != null && message.hasOwnProperty("publicKey")) {
                    var error = $root.api.IdentityPublicKeyWithMetadata.verify(message.publicKey);
                    if (error)
                        return "publicKey." + error;
                }
                if (message.challenge != null && message.hasOwnProperty("challenge")) {
                    var error = $root.api.IdentityGetLockedVersionsResponse.IdentityChallenge.verify(message.challenge);
                    if (error)
                        return "challenge." + error;
                }
                return null;
            };

            /**
             * Creates a LockedVersion message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.IdentityGetLockedVersionsResponse.LockedVersion
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.IdentityGetLockedVersionsResponse.LockedVersion} LockedVersion
             */
            LockedVersion.fromObject = function fromObject(object) {
                if (object instanceof $root.api.IdentityGetLockedVersionsResponse.LockedVersion)
                    return object;
                var message = new $root.api.IdentityGetLockedVersionsResponse.LockedVersion();
                if (object.publicKey != null) {
                    if (typeof object.publicKey !== "object")
                        throw TypeError(".api.IdentityGetLockedVersionsResponse.LockedVersion.publicKey: object expected");
                    message.publicKey = $root.api.IdentityPublicKeyWithMetadata.fromObject(object.publicKey);
                }
                if (object.challenge != null) {
                    if (typeof object.challenge !== "object")
                        throw TypeError(".api.IdentityGetLockedVersionsResponse.LockedVersion.challenge: object expected");
                    message.challenge = $root.api.IdentityGetLockedVersionsResponse.IdentityChallenge.fromObject(object.challenge);
                }
                return message;
            };

            /**
             * Creates a plain object from a LockedVersion message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.IdentityGetLockedVersionsResponse.LockedVersion
             * @static
             * @param {api.IdentityGetLockedVersionsResponse.LockedVersion} message LockedVersion
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LockedVersion.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.publicKey = null;
                    object.challenge = null;
                }
                if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                    object.publicKey = $root.api.IdentityPublicKeyWithMetadata.toObject(message.publicKey, options);
                if (message.challenge != null && message.hasOwnProperty("challenge"))
                    object.challenge = $root.api.IdentityGetLockedVersionsResponse.IdentityChallenge.toObject(message.challenge, options);
                return object;
            };

            /**
             * Converts this LockedVersion to JSON.
             * @function toJSON
             * @memberof api.IdentityGetLockedVersionsResponse.LockedVersion
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LockedVersion.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LockedVersion;
        })();

        return IdentityGetLockedVersionsResponse;
    })();

    api.IdentityAssociateEmailRequest = (function() {

        /**
         * Properties of an IdentityAssociateEmailRequest.
         * @memberof api
         * @interface IIdentityAssociateEmailRequest
         * @property {string|null} [login] IdentityAssociateEmailRequest login
         * @property {string|null} [email] IdentityAssociateEmailRequest email
         */

        /**
         * Constructs a new IdentityAssociateEmailRequest.
         * @memberof api
         * @classdesc Represents an IdentityAssociateEmailRequest.
         * @implements IIdentityAssociateEmailRequest
         * @constructor
         * @param {api.IIdentityAssociateEmailRequest=} [properties] Properties to set
         */
        function IdentityAssociateEmailRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityAssociateEmailRequest login.
         * @member {string} login
         * @memberof api.IdentityAssociateEmailRequest
         * @instance
         */
        IdentityAssociateEmailRequest.prototype.login = "";

        /**
         * IdentityAssociateEmailRequest email.
         * @member {string} email
         * @memberof api.IdentityAssociateEmailRequest
         * @instance
         */
        IdentityAssociateEmailRequest.prototype.email = "";

        /**
         * Creates a new IdentityAssociateEmailRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityAssociateEmailRequest
         * @static
         * @param {api.IIdentityAssociateEmailRequest=} [properties] Properties to set
         * @returns {api.IdentityAssociateEmailRequest} IdentityAssociateEmailRequest instance
         */
        IdentityAssociateEmailRequest.create = function create(properties) {
            return new IdentityAssociateEmailRequest(properties);
        };

        /**
         * Encodes the specified IdentityAssociateEmailRequest message. Does not implicitly {@link api.IdentityAssociateEmailRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityAssociateEmailRequest
         * @static
         * @param {api.IIdentityAssociateEmailRequest} message IdentityAssociateEmailRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityAssociateEmailRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.email);
            return writer;
        };

        /**
         * Encodes the specified IdentityAssociateEmailRequest message, length delimited. Does not implicitly {@link api.IdentityAssociateEmailRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityAssociateEmailRequest
         * @static
         * @param {api.IIdentityAssociateEmailRequest} message IdentityAssociateEmailRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityAssociateEmailRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityAssociateEmailRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityAssociateEmailRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityAssociateEmailRequest} IdentityAssociateEmailRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityAssociateEmailRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityAssociateEmailRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.email = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityAssociateEmailRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityAssociateEmailRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityAssociateEmailRequest} IdentityAssociateEmailRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityAssociateEmailRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityAssociateEmailRequest message.
         * @function verify
         * @memberof api.IdentityAssociateEmailRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityAssociateEmailRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            return null;
        };

        /**
         * Creates an IdentityAssociateEmailRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityAssociateEmailRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityAssociateEmailRequest} IdentityAssociateEmailRequest
         */
        IdentityAssociateEmailRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityAssociateEmailRequest)
                return object;
            var message = new $root.api.IdentityAssociateEmailRequest();
            if (object.login != null)
                message.login = String(object.login);
            if (object.email != null)
                message.email = String(object.email);
            return message;
        };

        /**
         * Creates a plain object from an IdentityAssociateEmailRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityAssociateEmailRequest
         * @static
         * @param {api.IdentityAssociateEmailRequest} message IdentityAssociateEmailRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityAssociateEmailRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.email = "";
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            return object;
        };

        /**
         * Converts this IdentityAssociateEmailRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityAssociateEmailRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityAssociateEmailRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityAssociateEmailRequest;
    })();

    api.IdentitiyGetPrincipalEmailRequest = (function() {

        /**
         * Properties of an IdentitiyGetPrincipalEmailRequest.
         * @memberof api
         * @interface IIdentitiyGetPrincipalEmailRequest
         * @property {string|null} [login] IdentitiyGetPrincipalEmailRequest login
         */

        /**
         * Constructs a new IdentitiyGetPrincipalEmailRequest.
         * @memberof api
         * @classdesc Represents an IdentitiyGetPrincipalEmailRequest.
         * @implements IIdentitiyGetPrincipalEmailRequest
         * @constructor
         * @param {api.IIdentitiyGetPrincipalEmailRequest=} [properties] Properties to set
         */
        function IdentitiyGetPrincipalEmailRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentitiyGetPrincipalEmailRequest login.
         * @member {string} login
         * @memberof api.IdentitiyGetPrincipalEmailRequest
         * @instance
         */
        IdentitiyGetPrincipalEmailRequest.prototype.login = "";

        /**
         * Creates a new IdentitiyGetPrincipalEmailRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentitiyGetPrincipalEmailRequest
         * @static
         * @param {api.IIdentitiyGetPrincipalEmailRequest=} [properties] Properties to set
         * @returns {api.IdentitiyGetPrincipalEmailRequest} IdentitiyGetPrincipalEmailRequest instance
         */
        IdentitiyGetPrincipalEmailRequest.create = function create(properties) {
            return new IdentitiyGetPrincipalEmailRequest(properties);
        };

        /**
         * Encodes the specified IdentitiyGetPrincipalEmailRequest message. Does not implicitly {@link api.IdentitiyGetPrincipalEmailRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentitiyGetPrincipalEmailRequest
         * @static
         * @param {api.IIdentitiyGetPrincipalEmailRequest} message IdentitiyGetPrincipalEmailRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentitiyGetPrincipalEmailRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            return writer;
        };

        /**
         * Encodes the specified IdentitiyGetPrincipalEmailRequest message, length delimited. Does not implicitly {@link api.IdentitiyGetPrincipalEmailRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentitiyGetPrincipalEmailRequest
         * @static
         * @param {api.IIdentitiyGetPrincipalEmailRequest} message IdentitiyGetPrincipalEmailRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentitiyGetPrincipalEmailRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentitiyGetPrincipalEmailRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentitiyGetPrincipalEmailRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentitiyGetPrincipalEmailRequest} IdentitiyGetPrincipalEmailRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentitiyGetPrincipalEmailRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentitiyGetPrincipalEmailRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentitiyGetPrincipalEmailRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentitiyGetPrincipalEmailRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentitiyGetPrincipalEmailRequest} IdentitiyGetPrincipalEmailRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentitiyGetPrincipalEmailRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentitiyGetPrincipalEmailRequest message.
         * @function verify
         * @memberof api.IdentitiyGetPrincipalEmailRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentitiyGetPrincipalEmailRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            return null;
        };

        /**
         * Creates an IdentitiyGetPrincipalEmailRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentitiyGetPrincipalEmailRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentitiyGetPrincipalEmailRequest} IdentitiyGetPrincipalEmailRequest
         */
        IdentitiyGetPrincipalEmailRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentitiyGetPrincipalEmailRequest)
                return object;
            var message = new $root.api.IdentitiyGetPrincipalEmailRequest();
            if (object.login != null)
                message.login = String(object.login);
            return message;
        };

        /**
         * Creates a plain object from an IdentitiyGetPrincipalEmailRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentitiyGetPrincipalEmailRequest
         * @static
         * @param {api.IdentitiyGetPrincipalEmailRequest} message IdentitiyGetPrincipalEmailRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentitiyGetPrincipalEmailRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.login = "";
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            return object;
        };

        /**
         * Converts this IdentitiyGetPrincipalEmailRequest to JSON.
         * @function toJSON
         * @memberof api.IdentitiyGetPrincipalEmailRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentitiyGetPrincipalEmailRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentitiyGetPrincipalEmailRequest;
    })();

    api.IdentityGetPrincipalEmailResponse = (function() {

        /**
         * Properties of an IdentityGetPrincipalEmailResponse.
         * @memberof api
         * @interface IIdentityGetPrincipalEmailResponse
         * @property {string|null} [login] IdentityGetPrincipalEmailResponse login
         * @property {string|null} [email] IdentityGetPrincipalEmailResponse email
         */

        /**
         * Constructs a new IdentityGetPrincipalEmailResponse.
         * @memberof api
         * @classdesc Represents an IdentityGetPrincipalEmailResponse.
         * @implements IIdentityGetPrincipalEmailResponse
         * @constructor
         * @param {api.IIdentityGetPrincipalEmailResponse=} [properties] Properties to set
         */
        function IdentityGetPrincipalEmailResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetPrincipalEmailResponse login.
         * @member {string} login
         * @memberof api.IdentityGetPrincipalEmailResponse
         * @instance
         */
        IdentityGetPrincipalEmailResponse.prototype.login = "";

        /**
         * IdentityGetPrincipalEmailResponse email.
         * @member {string} email
         * @memberof api.IdentityGetPrincipalEmailResponse
         * @instance
         */
        IdentityGetPrincipalEmailResponse.prototype.email = "";

        /**
         * Creates a new IdentityGetPrincipalEmailResponse instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetPrincipalEmailResponse
         * @static
         * @param {api.IIdentityGetPrincipalEmailResponse=} [properties] Properties to set
         * @returns {api.IdentityGetPrincipalEmailResponse} IdentityGetPrincipalEmailResponse instance
         */
        IdentityGetPrincipalEmailResponse.create = function create(properties) {
            return new IdentityGetPrincipalEmailResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetPrincipalEmailResponse message. Does not implicitly {@link api.IdentityGetPrincipalEmailResponse.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetPrincipalEmailResponse
         * @static
         * @param {api.IIdentityGetPrincipalEmailResponse} message IdentityGetPrincipalEmailResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetPrincipalEmailResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.email);
            return writer;
        };

        /**
         * Encodes the specified IdentityGetPrincipalEmailResponse message, length delimited. Does not implicitly {@link api.IdentityGetPrincipalEmailResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetPrincipalEmailResponse
         * @static
         * @param {api.IIdentityGetPrincipalEmailResponse} message IdentityGetPrincipalEmailResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetPrincipalEmailResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetPrincipalEmailResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetPrincipalEmailResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetPrincipalEmailResponse} IdentityGetPrincipalEmailResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetPrincipalEmailResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetPrincipalEmailResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.email = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetPrincipalEmailResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetPrincipalEmailResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetPrincipalEmailResponse} IdentityGetPrincipalEmailResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetPrincipalEmailResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetPrincipalEmailResponse message.
         * @function verify
         * @memberof api.IdentityGetPrincipalEmailResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetPrincipalEmailResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            return null;
        };

        /**
         * Creates an IdentityGetPrincipalEmailResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetPrincipalEmailResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetPrincipalEmailResponse} IdentityGetPrincipalEmailResponse
         */
        IdentityGetPrincipalEmailResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetPrincipalEmailResponse)
                return object;
            var message = new $root.api.IdentityGetPrincipalEmailResponse();
            if (object.login != null)
                message.login = String(object.login);
            if (object.email != null)
                message.email = String(object.email);
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetPrincipalEmailResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetPrincipalEmailResponse
         * @static
         * @param {api.IdentityGetPrincipalEmailResponse} message IdentityGetPrincipalEmailResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetPrincipalEmailResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.email = "";
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            return object;
        };

        /**
         * Converts this IdentityGetPrincipalEmailResponse to JSON.
         * @function toJSON
         * @memberof api.IdentityGetPrincipalEmailResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetPrincipalEmailResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetPrincipalEmailResponse;
    })();

    api.IdentitySetPrincipalEmailRequest = (function() {

        /**
         * Properties of an IdentitySetPrincipalEmailRequest.
         * @memberof api
         * @interface IIdentitySetPrincipalEmailRequest
         * @property {string|null} [login] IdentitySetPrincipalEmailRequest login
         * @property {string|null} [email] IdentitySetPrincipalEmailRequest email
         */

        /**
         * Constructs a new IdentitySetPrincipalEmailRequest.
         * @memberof api
         * @classdesc Represents an IdentitySetPrincipalEmailRequest.
         * @implements IIdentitySetPrincipalEmailRequest
         * @constructor
         * @param {api.IIdentitySetPrincipalEmailRequest=} [properties] Properties to set
         */
        function IdentitySetPrincipalEmailRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentitySetPrincipalEmailRequest login.
         * @member {string} login
         * @memberof api.IdentitySetPrincipalEmailRequest
         * @instance
         */
        IdentitySetPrincipalEmailRequest.prototype.login = "";

        /**
         * IdentitySetPrincipalEmailRequest email.
         * @member {string} email
         * @memberof api.IdentitySetPrincipalEmailRequest
         * @instance
         */
        IdentitySetPrincipalEmailRequest.prototype.email = "";

        /**
         * Creates a new IdentitySetPrincipalEmailRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentitySetPrincipalEmailRequest
         * @static
         * @param {api.IIdentitySetPrincipalEmailRequest=} [properties] Properties to set
         * @returns {api.IdentitySetPrincipalEmailRequest} IdentitySetPrincipalEmailRequest instance
         */
        IdentitySetPrincipalEmailRequest.create = function create(properties) {
            return new IdentitySetPrincipalEmailRequest(properties);
        };

        /**
         * Encodes the specified IdentitySetPrincipalEmailRequest message. Does not implicitly {@link api.IdentitySetPrincipalEmailRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentitySetPrincipalEmailRequest
         * @static
         * @param {api.IIdentitySetPrincipalEmailRequest} message IdentitySetPrincipalEmailRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentitySetPrincipalEmailRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.email);
            return writer;
        };

        /**
         * Encodes the specified IdentitySetPrincipalEmailRequest message, length delimited. Does not implicitly {@link api.IdentitySetPrincipalEmailRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentitySetPrincipalEmailRequest
         * @static
         * @param {api.IIdentitySetPrincipalEmailRequest} message IdentitySetPrincipalEmailRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentitySetPrincipalEmailRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentitySetPrincipalEmailRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentitySetPrincipalEmailRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentitySetPrincipalEmailRequest} IdentitySetPrincipalEmailRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentitySetPrincipalEmailRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentitySetPrincipalEmailRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.email = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentitySetPrincipalEmailRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentitySetPrincipalEmailRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentitySetPrincipalEmailRequest} IdentitySetPrincipalEmailRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentitySetPrincipalEmailRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentitySetPrincipalEmailRequest message.
         * @function verify
         * @memberof api.IdentitySetPrincipalEmailRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentitySetPrincipalEmailRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            return null;
        };

        /**
         * Creates an IdentitySetPrincipalEmailRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentitySetPrincipalEmailRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentitySetPrincipalEmailRequest} IdentitySetPrincipalEmailRequest
         */
        IdentitySetPrincipalEmailRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentitySetPrincipalEmailRequest)
                return object;
            var message = new $root.api.IdentitySetPrincipalEmailRequest();
            if (object.login != null)
                message.login = String(object.login);
            if (object.email != null)
                message.email = String(object.email);
            return message;
        };

        /**
         * Creates a plain object from an IdentitySetPrincipalEmailRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentitySetPrincipalEmailRequest
         * @static
         * @param {api.IdentitySetPrincipalEmailRequest} message IdentitySetPrincipalEmailRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentitySetPrincipalEmailRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.email = "";
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            return object;
        };

        /**
         * Converts this IdentitySetPrincipalEmailRequest to JSON.
         * @function toJSON
         * @memberof api.IdentitySetPrincipalEmailRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentitySetPrincipalEmailRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentitySetPrincipalEmailRequest;
    })();

    api.IdentitySetNamedResourceRequest = (function() {

        /**
         * Properties of an IdentitySetNamedResourceRequest.
         * @memberof api
         * @interface IIdentitySetNamedResourceRequest
         * @property {string|null} [login] IdentitySetNamedResourceRequest login
         * @property {string|null} [resourceName] IdentitySetNamedResourceRequest resourceName
         * @property {number|Long|null} [resourceID] IdentitySetNamedResourceRequest resourceID
         */

        /**
         * Constructs a new IdentitySetNamedResourceRequest.
         * @memberof api
         * @classdesc Represents an IdentitySetNamedResourceRequest.
         * @implements IIdentitySetNamedResourceRequest
         * @constructor
         * @param {api.IIdentitySetNamedResourceRequest=} [properties] Properties to set
         */
        function IdentitySetNamedResourceRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentitySetNamedResourceRequest login.
         * @member {string} login
         * @memberof api.IdentitySetNamedResourceRequest
         * @instance
         */
        IdentitySetNamedResourceRequest.prototype.login = "";

        /**
         * IdentitySetNamedResourceRequest resourceName.
         * @member {string} resourceName
         * @memberof api.IdentitySetNamedResourceRequest
         * @instance
         */
        IdentitySetNamedResourceRequest.prototype.resourceName = "";

        /**
         * IdentitySetNamedResourceRequest resourceID.
         * @member {number|Long} resourceID
         * @memberof api.IdentitySetNamedResourceRequest
         * @instance
         */
        IdentitySetNamedResourceRequest.prototype.resourceID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new IdentitySetNamedResourceRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentitySetNamedResourceRequest
         * @static
         * @param {api.IIdentitySetNamedResourceRequest=} [properties] Properties to set
         * @returns {api.IdentitySetNamedResourceRequest} IdentitySetNamedResourceRequest instance
         */
        IdentitySetNamedResourceRequest.create = function create(properties) {
            return new IdentitySetNamedResourceRequest(properties);
        };

        /**
         * Encodes the specified IdentitySetNamedResourceRequest message. Does not implicitly {@link api.IdentitySetNamedResourceRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentitySetNamedResourceRequest
         * @static
         * @param {api.IIdentitySetNamedResourceRequest} message IdentitySetNamedResourceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentitySetNamedResourceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.resourceName != null && message.hasOwnProperty("resourceName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.resourceName);
            if (message.resourceID != null && message.hasOwnProperty("resourceID"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.resourceID);
            return writer;
        };

        /**
         * Encodes the specified IdentitySetNamedResourceRequest message, length delimited. Does not implicitly {@link api.IdentitySetNamedResourceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentitySetNamedResourceRequest
         * @static
         * @param {api.IIdentitySetNamedResourceRequest} message IdentitySetNamedResourceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentitySetNamedResourceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentitySetNamedResourceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentitySetNamedResourceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentitySetNamedResourceRequest} IdentitySetNamedResourceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentitySetNamedResourceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentitySetNamedResourceRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.resourceName = reader.string();
                    break;
                case 3:
                    message.resourceID = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentitySetNamedResourceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentitySetNamedResourceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentitySetNamedResourceRequest} IdentitySetNamedResourceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentitySetNamedResourceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentitySetNamedResourceRequest message.
         * @function verify
         * @memberof api.IdentitySetNamedResourceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentitySetNamedResourceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.resourceName != null && message.hasOwnProperty("resourceName"))
                if (!$util.isString(message.resourceName))
                    return "resourceName: string expected";
            if (message.resourceID != null && message.hasOwnProperty("resourceID"))
                if (!$util.isInteger(message.resourceID) && !(message.resourceID && $util.isInteger(message.resourceID.low) && $util.isInteger(message.resourceID.high)))
                    return "resourceID: integer|Long expected";
            return null;
        };

        /**
         * Creates an IdentitySetNamedResourceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentitySetNamedResourceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentitySetNamedResourceRequest} IdentitySetNamedResourceRequest
         */
        IdentitySetNamedResourceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentitySetNamedResourceRequest)
                return object;
            var message = new $root.api.IdentitySetNamedResourceRequest();
            if (object.login != null)
                message.login = String(object.login);
            if (object.resourceName != null)
                message.resourceName = String(object.resourceName);
            if (object.resourceID != null)
                if ($util.Long)
                    (message.resourceID = $util.Long.fromValue(object.resourceID)).unsigned = true;
                else if (typeof object.resourceID === "string")
                    message.resourceID = parseInt(object.resourceID, 10);
                else if (typeof object.resourceID === "number")
                    message.resourceID = object.resourceID;
                else if (typeof object.resourceID === "object")
                    message.resourceID = new $util.LongBits(object.resourceID.low >>> 0, object.resourceID.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from an IdentitySetNamedResourceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentitySetNamedResourceRequest
         * @static
         * @param {api.IdentitySetNamedResourceRequest} message IdentitySetNamedResourceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentitySetNamedResourceRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.resourceName = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.resourceID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.resourceID = options.longs === String ? "0" : 0;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.resourceName != null && message.hasOwnProperty("resourceName"))
                object.resourceName = message.resourceName;
            if (message.resourceID != null && message.hasOwnProperty("resourceID"))
                if (typeof message.resourceID === "number")
                    object.resourceID = options.longs === String ? String(message.resourceID) : message.resourceID;
                else
                    object.resourceID = options.longs === String ? $util.Long.prototype.toString.call(message.resourceID) : options.longs === Number ? new $util.LongBits(message.resourceID.low >>> 0, message.resourceID.high >>> 0).toNumber(true) : message.resourceID;
            return object;
        };

        /**
         * Converts this IdentitySetNamedResourceRequest to JSON.
         * @function toJSON
         * @memberof api.IdentitySetNamedResourceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentitySetNamedResourceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentitySetNamedResourceRequest;
    })();

    api.IdentityGetNamedResourceRequest = (function() {

        /**
         * Properties of an IdentityGetNamedResourceRequest.
         * @memberof api
         * @interface IIdentityGetNamedResourceRequest
         * @property {string|null} [login] IdentityGetNamedResourceRequest login
         * @property {string|null} [resourceName] IdentityGetNamedResourceRequest resourceName
         */

        /**
         * Constructs a new IdentityGetNamedResourceRequest.
         * @memberof api
         * @classdesc Represents an IdentityGetNamedResourceRequest.
         * @implements IIdentityGetNamedResourceRequest
         * @constructor
         * @param {api.IIdentityGetNamedResourceRequest=} [properties] Properties to set
         */
        function IdentityGetNamedResourceRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetNamedResourceRequest login.
         * @member {string} login
         * @memberof api.IdentityGetNamedResourceRequest
         * @instance
         */
        IdentityGetNamedResourceRequest.prototype.login = "";

        /**
         * IdentityGetNamedResourceRequest resourceName.
         * @member {string} resourceName
         * @memberof api.IdentityGetNamedResourceRequest
         * @instance
         */
        IdentityGetNamedResourceRequest.prototype.resourceName = "";

        /**
         * Creates a new IdentityGetNamedResourceRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetNamedResourceRequest
         * @static
         * @param {api.IIdentityGetNamedResourceRequest=} [properties] Properties to set
         * @returns {api.IdentityGetNamedResourceRequest} IdentityGetNamedResourceRequest instance
         */
        IdentityGetNamedResourceRequest.create = function create(properties) {
            return new IdentityGetNamedResourceRequest(properties);
        };

        /**
         * Encodes the specified IdentityGetNamedResourceRequest message. Does not implicitly {@link api.IdentityGetNamedResourceRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetNamedResourceRequest
         * @static
         * @param {api.IIdentityGetNamedResourceRequest} message IdentityGetNamedResourceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetNamedResourceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.resourceName != null && message.hasOwnProperty("resourceName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.resourceName);
            return writer;
        };

        /**
         * Encodes the specified IdentityGetNamedResourceRequest message, length delimited. Does not implicitly {@link api.IdentityGetNamedResourceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetNamedResourceRequest
         * @static
         * @param {api.IIdentityGetNamedResourceRequest} message IdentityGetNamedResourceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetNamedResourceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetNamedResourceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetNamedResourceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetNamedResourceRequest} IdentityGetNamedResourceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetNamedResourceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetNamedResourceRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.resourceName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetNamedResourceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetNamedResourceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetNamedResourceRequest} IdentityGetNamedResourceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetNamedResourceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetNamedResourceRequest message.
         * @function verify
         * @memberof api.IdentityGetNamedResourceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetNamedResourceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.resourceName != null && message.hasOwnProperty("resourceName"))
                if (!$util.isString(message.resourceName))
                    return "resourceName: string expected";
            return null;
        };

        /**
         * Creates an IdentityGetNamedResourceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetNamedResourceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetNamedResourceRequest} IdentityGetNamedResourceRequest
         */
        IdentityGetNamedResourceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetNamedResourceRequest)
                return object;
            var message = new $root.api.IdentityGetNamedResourceRequest();
            if (object.login != null)
                message.login = String(object.login);
            if (object.resourceName != null)
                message.resourceName = String(object.resourceName);
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetNamedResourceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetNamedResourceRequest
         * @static
         * @param {api.IdentityGetNamedResourceRequest} message IdentityGetNamedResourceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetNamedResourceRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.resourceName = "";
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.resourceName != null && message.hasOwnProperty("resourceName"))
                object.resourceName = message.resourceName;
            return object;
        };

        /**
         * Converts this IdentityGetNamedResourceRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityGetNamedResourceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetNamedResourceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetNamedResourceRequest;
    })();

    api.IdentityGetNamedResourceResponse = (function() {

        /**
         * Properties of an IdentityGetNamedResourceResponse.
         * @memberof api
         * @interface IIdentityGetNamedResourceResponse
         * @property {api.IResourceGetResponse|null} [resource] IdentityGetNamedResourceResponse resource
         */

        /**
         * Constructs a new IdentityGetNamedResourceResponse.
         * @memberof api
         * @classdesc Represents an IdentityGetNamedResourceResponse.
         * @implements IIdentityGetNamedResourceResponse
         * @constructor
         * @param {api.IIdentityGetNamedResourceResponse=} [properties] Properties to set
         */
        function IdentityGetNamedResourceResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetNamedResourceResponse resource.
         * @member {api.IResourceGetResponse|null|undefined} resource
         * @memberof api.IdentityGetNamedResourceResponse
         * @instance
         */
        IdentityGetNamedResourceResponse.prototype.resource = null;

        /**
         * Creates a new IdentityGetNamedResourceResponse instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetNamedResourceResponse
         * @static
         * @param {api.IIdentityGetNamedResourceResponse=} [properties] Properties to set
         * @returns {api.IdentityGetNamedResourceResponse} IdentityGetNamedResourceResponse instance
         */
        IdentityGetNamedResourceResponse.create = function create(properties) {
            return new IdentityGetNamedResourceResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetNamedResourceResponse message. Does not implicitly {@link api.IdentityGetNamedResourceResponse.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetNamedResourceResponse
         * @static
         * @param {api.IIdentityGetNamedResourceResponse} message IdentityGetNamedResourceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetNamedResourceResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resource != null && message.hasOwnProperty("resource"))
                $root.api.ResourceGetResponse.encode(message.resource, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetNamedResourceResponse message, length delimited. Does not implicitly {@link api.IdentityGetNamedResourceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetNamedResourceResponse
         * @static
         * @param {api.IIdentityGetNamedResourceResponse} message IdentityGetNamedResourceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetNamedResourceResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetNamedResourceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetNamedResourceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetNamedResourceResponse} IdentityGetNamedResourceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetNamedResourceResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetNamedResourceResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.resource = $root.api.ResourceGetResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetNamedResourceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetNamedResourceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetNamedResourceResponse} IdentityGetNamedResourceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetNamedResourceResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetNamedResourceResponse message.
         * @function verify
         * @memberof api.IdentityGetNamedResourceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetNamedResourceResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.resource != null && message.hasOwnProperty("resource")) {
                var error = $root.api.ResourceGetResponse.verify(message.resource);
                if (error)
                    return "resource." + error;
            }
            return null;
        };

        /**
         * Creates an IdentityGetNamedResourceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetNamedResourceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetNamedResourceResponse} IdentityGetNamedResourceResponse
         */
        IdentityGetNamedResourceResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetNamedResourceResponse)
                return object;
            var message = new $root.api.IdentityGetNamedResourceResponse();
            if (object.resource != null) {
                if (typeof object.resource !== "object")
                    throw TypeError(".api.IdentityGetNamedResourceResponse.resource: object expected");
                message.resource = $root.api.ResourceGetResponse.fromObject(object.resource);
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetNamedResourceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetNamedResourceResponse
         * @static
         * @param {api.IdentityGetNamedResourceResponse} message IdentityGetNamedResourceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetNamedResourceResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.resource = null;
            if (message.resource != null && message.hasOwnProperty("resource"))
                object.resource = $root.api.ResourceGetResponse.toObject(message.resource, options);
            return object;
        };

        /**
         * Converts this IdentityGetNamedResourceResponse to JSON.
         * @function toJSON
         * @memberof api.IdentityGetNamedResourceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetNamedResourceResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetNamedResourceResponse;
    })();

    /**
     * IdentitySortingField enum.
     * @name api.IdentitySortingField
     * @enum {string}
     * @property {number} LOGIN=0 LOGIN value
     * @property {number} CREATED=1 CREATED value
     * @property {number} KIND=2 KIND value
     */
    api.IdentitySortingField = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LOGIN"] = 0;
        values[valuesById[1] = "CREATED"] = 1;
        values[valuesById[2] = "KIND"] = 2;
        return values;
    })();

    /**
     * SortingOrder enum.
     * @name api.SortingOrder
     * @enum {string}
     * @property {number} DESC=0 DESC value
     * @property {number} ASC=1 ASC value
     */
    api.SortingOrder = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DESC"] = 0;
        values[valuesById[1] = "ASC"] = 1;
        return values;
    })();

    /**
     * SessionSaltKind enum.
     * @name api.SessionSaltKind
     * @enum {string}
     * @property {number} TIME=0 TIME value
     * @property {number} RAND=1 RAND value
     */
    api.SessionSaltKind = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TIME"] = 0;
        values[valuesById[1] = "RAND"] = 1;
        return values;
    })();

    api.SessionCreateChallengeRequest = (function() {

        /**
         * Properties of a SessionCreateChallengeRequest.
         * @memberof api
         * @interface ISessionCreateChallengeRequest
         * @property {string|null} [login] SessionCreateChallengeRequest login
         * @property {api.SessionSaltKind|null} [saltKind] SessionCreateChallengeRequest saltKind
         * @property {number|null} [duration] SessionCreateChallengeRequest duration
         */

        /**
         * Constructs a new SessionCreateChallengeRequest.
         * @memberof api
         * @classdesc Represents a SessionCreateChallengeRequest.
         * @implements ISessionCreateChallengeRequest
         * @constructor
         * @param {api.ISessionCreateChallengeRequest=} [properties] Properties to set
         */
        function SessionCreateChallengeRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SessionCreateChallengeRequest login.
         * @member {string} login
         * @memberof api.SessionCreateChallengeRequest
         * @instance
         */
        SessionCreateChallengeRequest.prototype.login = "";

        /**
         * SessionCreateChallengeRequest saltKind.
         * @member {api.SessionSaltKind} saltKind
         * @memberof api.SessionCreateChallengeRequest
         * @instance
         */
        SessionCreateChallengeRequest.prototype.saltKind = 0;

        /**
         * SessionCreateChallengeRequest duration.
         * @member {number} duration
         * @memberof api.SessionCreateChallengeRequest
         * @instance
         */
        SessionCreateChallengeRequest.prototype.duration = 0;

        /**
         * Creates a new SessionCreateChallengeRequest instance using the specified properties.
         * @function create
         * @memberof api.SessionCreateChallengeRequest
         * @static
         * @param {api.ISessionCreateChallengeRequest=} [properties] Properties to set
         * @returns {api.SessionCreateChallengeRequest} SessionCreateChallengeRequest instance
         */
        SessionCreateChallengeRequest.create = function create(properties) {
            return new SessionCreateChallengeRequest(properties);
        };

        /**
         * Encodes the specified SessionCreateChallengeRequest message. Does not implicitly {@link api.SessionCreateChallengeRequest.verify|verify} messages.
         * @function encode
         * @memberof api.SessionCreateChallengeRequest
         * @static
         * @param {api.ISessionCreateChallengeRequest} message SessionCreateChallengeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionCreateChallengeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.saltKind != null && message.hasOwnProperty("saltKind"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.saltKind);
            if (message.duration != null && message.hasOwnProperty("duration"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.duration);
            return writer;
        };

        /**
         * Encodes the specified SessionCreateChallengeRequest message, length delimited. Does not implicitly {@link api.SessionCreateChallengeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.SessionCreateChallengeRequest
         * @static
         * @param {api.ISessionCreateChallengeRequest} message SessionCreateChallengeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionCreateChallengeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SessionCreateChallengeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.SessionCreateChallengeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.SessionCreateChallengeRequest} SessionCreateChallengeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionCreateChallengeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.SessionCreateChallengeRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.saltKind = reader.int32();
                    break;
                case 3:
                    message.duration = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SessionCreateChallengeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.SessionCreateChallengeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.SessionCreateChallengeRequest} SessionCreateChallengeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionCreateChallengeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SessionCreateChallengeRequest message.
         * @function verify
         * @memberof api.SessionCreateChallengeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SessionCreateChallengeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.saltKind != null && message.hasOwnProperty("saltKind"))
                switch (message.saltKind) {
                default:
                    return "saltKind: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (!$util.isInteger(message.duration))
                    return "duration: integer expected";
            return null;
        };

        /**
         * Creates a SessionCreateChallengeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.SessionCreateChallengeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.SessionCreateChallengeRequest} SessionCreateChallengeRequest
         */
        SessionCreateChallengeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.SessionCreateChallengeRequest)
                return object;
            var message = new $root.api.SessionCreateChallengeRequest();
            if (object.login != null)
                message.login = String(object.login);
            switch (object.saltKind) {
            case "TIME":
            case 0:
                message.saltKind = 0;
                break;
            case "RAND":
            case 1:
                message.saltKind = 1;
                break;
            }
            if (object.duration != null)
                message.duration = object.duration >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a SessionCreateChallengeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.SessionCreateChallengeRequest
         * @static
         * @param {api.SessionCreateChallengeRequest} message SessionCreateChallengeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionCreateChallengeRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.saltKind = options.enums === String ? "TIME" : 0;
                object.duration = 0;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.saltKind != null && message.hasOwnProperty("saltKind"))
                object.saltKind = options.enums === String ? $root.api.SessionSaltKind[message.saltKind] : message.saltKind;
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = message.duration;
            return object;
        };

        /**
         * Converts this SessionCreateChallengeRequest to JSON.
         * @function toJSON
         * @memberof api.SessionCreateChallengeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionCreateChallengeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SessionCreateChallengeRequest;
    })();

    api.SessionCreateChallengeResponse = (function() {

        /**
         * Properties of a SessionCreateChallengeResponse.
         * @memberof api
         * @interface ISessionCreateChallengeResponse
         * @property {Uint8Array|null} [salt] SessionCreateChallengeResponse salt
         * @property {Uint8Array|null} [token] SessionCreateChallengeResponse token
         * @property {api.IIdentityEncryption|null} [encryption] SessionCreateChallengeResponse encryption
         * @property {api.IIdentityPublicKey|null} [creator] SessionCreateChallengeResponse creator
         * @property {api.SessionSaltKind|null} [saltKind] SessionCreateChallengeResponse saltKind
         */

        /**
         * Constructs a new SessionCreateChallengeResponse.
         * @memberof api
         * @classdesc Represents a SessionCreateChallengeResponse.
         * @implements ISessionCreateChallengeResponse
         * @constructor
         * @param {api.ISessionCreateChallengeResponse=} [properties] Properties to set
         */
        function SessionCreateChallengeResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SessionCreateChallengeResponse salt.
         * @member {Uint8Array} salt
         * @memberof api.SessionCreateChallengeResponse
         * @instance
         */
        SessionCreateChallengeResponse.prototype.salt = $util.newBuffer([]);

        /**
         * SessionCreateChallengeResponse token.
         * @member {Uint8Array} token
         * @memberof api.SessionCreateChallengeResponse
         * @instance
         */
        SessionCreateChallengeResponse.prototype.token = $util.newBuffer([]);

        /**
         * SessionCreateChallengeResponse encryption.
         * @member {api.IIdentityEncryption|null|undefined} encryption
         * @memberof api.SessionCreateChallengeResponse
         * @instance
         */
        SessionCreateChallengeResponse.prototype.encryption = null;

        /**
         * SessionCreateChallengeResponse creator.
         * @member {api.IIdentityPublicKey|null|undefined} creator
         * @memberof api.SessionCreateChallengeResponse
         * @instance
         */
        SessionCreateChallengeResponse.prototype.creator = null;

        /**
         * SessionCreateChallengeResponse saltKind.
         * @member {api.SessionSaltKind} saltKind
         * @memberof api.SessionCreateChallengeResponse
         * @instance
         */
        SessionCreateChallengeResponse.prototype.saltKind = 0;

        /**
         * Creates a new SessionCreateChallengeResponse instance using the specified properties.
         * @function create
         * @memberof api.SessionCreateChallengeResponse
         * @static
         * @param {api.ISessionCreateChallengeResponse=} [properties] Properties to set
         * @returns {api.SessionCreateChallengeResponse} SessionCreateChallengeResponse instance
         */
        SessionCreateChallengeResponse.create = function create(properties) {
            return new SessionCreateChallengeResponse(properties);
        };

        /**
         * Encodes the specified SessionCreateChallengeResponse message. Does not implicitly {@link api.SessionCreateChallengeResponse.verify|verify} messages.
         * @function encode
         * @memberof api.SessionCreateChallengeResponse
         * @static
         * @param {api.ISessionCreateChallengeResponse} message SessionCreateChallengeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionCreateChallengeResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.salt != null && message.hasOwnProperty("salt"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.salt);
            if (message.token != null && message.hasOwnProperty("token"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.token);
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.api.IdentityEncryption.encode(message.encryption, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.creator != null && message.hasOwnProperty("creator"))
                $root.api.IdentityPublicKey.encode(message.creator, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.saltKind != null && message.hasOwnProperty("saltKind"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.saltKind);
            return writer;
        };

        /**
         * Encodes the specified SessionCreateChallengeResponse message, length delimited. Does not implicitly {@link api.SessionCreateChallengeResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.SessionCreateChallengeResponse
         * @static
         * @param {api.ISessionCreateChallengeResponse} message SessionCreateChallengeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionCreateChallengeResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SessionCreateChallengeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.SessionCreateChallengeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.SessionCreateChallengeResponse} SessionCreateChallengeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionCreateChallengeResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.SessionCreateChallengeResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.salt = reader.bytes();
                    break;
                case 2:
                    message.token = reader.bytes();
                    break;
                case 3:
                    message.encryption = $root.api.IdentityEncryption.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.creator = $root.api.IdentityPublicKey.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.saltKind = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SessionCreateChallengeResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.SessionCreateChallengeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.SessionCreateChallengeResponse} SessionCreateChallengeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionCreateChallengeResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SessionCreateChallengeResponse message.
         * @function verify
         * @memberof api.SessionCreateChallengeResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SessionCreateChallengeResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.salt != null && message.hasOwnProperty("salt"))
                if (!(message.salt && typeof message.salt.length === "number" || $util.isString(message.salt)))
                    return "salt: buffer expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                    return "token: buffer expected";
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.api.IdentityEncryption.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            if (message.creator != null && message.hasOwnProperty("creator")) {
                var error = $root.api.IdentityPublicKey.verify(message.creator);
                if (error)
                    return "creator." + error;
            }
            if (message.saltKind != null && message.hasOwnProperty("saltKind"))
                switch (message.saltKind) {
                default:
                    return "saltKind: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a SessionCreateChallengeResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.SessionCreateChallengeResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.SessionCreateChallengeResponse} SessionCreateChallengeResponse
         */
        SessionCreateChallengeResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.SessionCreateChallengeResponse)
                return object;
            var message = new $root.api.SessionCreateChallengeResponse();
            if (object.salt != null)
                if (typeof object.salt === "string")
                    $util.base64.decode(object.salt, message.salt = $util.newBuffer($util.base64.length(object.salt)), 0);
                else if (object.salt.length)
                    message.salt = object.salt;
            if (object.token != null)
                if (typeof object.token === "string")
                    $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                else if (object.token.length)
                    message.token = object.token;
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".api.SessionCreateChallengeResponse.encryption: object expected");
                message.encryption = $root.api.IdentityEncryption.fromObject(object.encryption);
            }
            if (object.creator != null) {
                if (typeof object.creator !== "object")
                    throw TypeError(".api.SessionCreateChallengeResponse.creator: object expected");
                message.creator = $root.api.IdentityPublicKey.fromObject(object.creator);
            }
            switch (object.saltKind) {
            case "TIME":
            case 0:
                message.saltKind = 0;
                break;
            case "RAND":
            case 1:
                message.saltKind = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a SessionCreateChallengeResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.SessionCreateChallengeResponse
         * @static
         * @param {api.SessionCreateChallengeResponse} message SessionCreateChallengeResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionCreateChallengeResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.salt = "";
                else {
                    object.salt = [];
                    if (options.bytes !== Array)
                        object.salt = $util.newBuffer(object.salt);
                }
                if (options.bytes === String)
                    object.token = "";
                else {
                    object.token = [];
                    if (options.bytes !== Array)
                        object.token = $util.newBuffer(object.token);
                }
                object.encryption = null;
                object.creator = null;
                object.saltKind = options.enums === String ? "TIME" : 0;
            }
            if (message.salt != null && message.hasOwnProperty("salt"))
                object.salt = options.bytes === String ? $util.base64.encode(message.salt, 0, message.salt.length) : options.bytes === Array ? Array.prototype.slice.call(message.salt) : message.salt;
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.api.IdentityEncryption.toObject(message.encryption, options);
            if (message.creator != null && message.hasOwnProperty("creator"))
                object.creator = $root.api.IdentityPublicKey.toObject(message.creator, options);
            if (message.saltKind != null && message.hasOwnProperty("saltKind"))
                object.saltKind = options.enums === String ? $root.api.SessionSaltKind[message.saltKind] : message.saltKind;
            return object;
        };

        /**
         * Converts this SessionCreateChallengeResponse to JSON.
         * @function toJSON
         * @memberof api.SessionCreateChallengeResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionCreateChallengeResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SessionCreateChallengeResponse;
    })();

    api.SessionResolveChallengeRequest = (function() {

        /**
         * Properties of a SessionResolveChallengeRequest.
         * @memberof api
         * @interface ISessionResolveChallengeRequest
         * @property {Uint8Array|null} [token] SessionResolveChallengeRequest token
         * @property {Uint8Array|null} [signature] SessionResolveChallengeRequest signature
         * @property {Uint8Array|null} [salt] SessionResolveChallengeRequest salt
         */

        /**
         * Constructs a new SessionResolveChallengeRequest.
         * @memberof api
         * @classdesc Represents a SessionResolveChallengeRequest.
         * @implements ISessionResolveChallengeRequest
         * @constructor
         * @param {api.ISessionResolveChallengeRequest=} [properties] Properties to set
         */
        function SessionResolveChallengeRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SessionResolveChallengeRequest token.
         * @member {Uint8Array} token
         * @memberof api.SessionResolveChallengeRequest
         * @instance
         */
        SessionResolveChallengeRequest.prototype.token = $util.newBuffer([]);

        /**
         * SessionResolveChallengeRequest signature.
         * @member {Uint8Array} signature
         * @memberof api.SessionResolveChallengeRequest
         * @instance
         */
        SessionResolveChallengeRequest.prototype.signature = $util.newBuffer([]);

        /**
         * SessionResolveChallengeRequest salt.
         * @member {Uint8Array} salt
         * @memberof api.SessionResolveChallengeRequest
         * @instance
         */
        SessionResolveChallengeRequest.prototype.salt = $util.newBuffer([]);

        /**
         * Creates a new SessionResolveChallengeRequest instance using the specified properties.
         * @function create
         * @memberof api.SessionResolveChallengeRequest
         * @static
         * @param {api.ISessionResolveChallengeRequest=} [properties] Properties to set
         * @returns {api.SessionResolveChallengeRequest} SessionResolveChallengeRequest instance
         */
        SessionResolveChallengeRequest.create = function create(properties) {
            return new SessionResolveChallengeRequest(properties);
        };

        /**
         * Encodes the specified SessionResolveChallengeRequest message. Does not implicitly {@link api.SessionResolveChallengeRequest.verify|verify} messages.
         * @function encode
         * @memberof api.SessionResolveChallengeRequest
         * @static
         * @param {api.ISessionResolveChallengeRequest} message SessionResolveChallengeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionResolveChallengeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.token != null && message.hasOwnProperty("token"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.token);
            if (message.signature != null && message.hasOwnProperty("signature"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
            if (message.salt != null && message.hasOwnProperty("salt"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.salt);
            return writer;
        };

        /**
         * Encodes the specified SessionResolveChallengeRequest message, length delimited. Does not implicitly {@link api.SessionResolveChallengeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.SessionResolveChallengeRequest
         * @static
         * @param {api.ISessionResolveChallengeRequest} message SessionResolveChallengeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionResolveChallengeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SessionResolveChallengeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.SessionResolveChallengeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.SessionResolveChallengeRequest} SessionResolveChallengeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionResolveChallengeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.SessionResolveChallengeRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.token = reader.bytes();
                    break;
                case 2:
                    message.signature = reader.bytes();
                    break;
                case 3:
                    message.salt = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SessionResolveChallengeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.SessionResolveChallengeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.SessionResolveChallengeRequest} SessionResolveChallengeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionResolveChallengeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SessionResolveChallengeRequest message.
         * @function verify
         * @memberof api.SessionResolveChallengeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SessionResolveChallengeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                    return "token: buffer expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            if (message.salt != null && message.hasOwnProperty("salt"))
                if (!(message.salt && typeof message.salt.length === "number" || $util.isString(message.salt)))
                    return "salt: buffer expected";
            return null;
        };

        /**
         * Creates a SessionResolveChallengeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.SessionResolveChallengeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.SessionResolveChallengeRequest} SessionResolveChallengeRequest
         */
        SessionResolveChallengeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.SessionResolveChallengeRequest)
                return object;
            var message = new $root.api.SessionResolveChallengeRequest();
            if (object.token != null)
                if (typeof object.token === "string")
                    $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                else if (object.token.length)
                    message.token = object.token;
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length)
                    message.signature = object.signature;
            if (object.salt != null)
                if (typeof object.salt === "string")
                    $util.base64.decode(object.salt, message.salt = $util.newBuffer($util.base64.length(object.salt)), 0);
                else if (object.salt.length)
                    message.salt = object.salt;
            return message;
        };

        /**
         * Creates a plain object from a SessionResolveChallengeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.SessionResolveChallengeRequest
         * @static
         * @param {api.SessionResolveChallengeRequest} message SessionResolveChallengeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionResolveChallengeRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.token = "";
                else {
                    object.token = [];
                    if (options.bytes !== Array)
                        object.token = $util.newBuffer(object.token);
                }
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
                if (options.bytes === String)
                    object.salt = "";
                else {
                    object.salt = [];
                    if (options.bytes !== Array)
                        object.salt = $util.newBuffer(object.salt);
                }
            }
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            if (message.salt != null && message.hasOwnProperty("salt"))
                object.salt = options.bytes === String ? $util.base64.encode(message.salt, 0, message.salt.length) : options.bytes === Array ? Array.prototype.slice.call(message.salt) : message.salt;
            return object;
        };

        /**
         * Converts this SessionResolveChallengeRequest to JSON.
         * @function toJSON
         * @memberof api.SessionResolveChallengeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionResolveChallengeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SessionResolveChallengeRequest;
    })();

    api.SessionResolveChallengeResponse = (function() {

        /**
         * Properties of a SessionResolveChallengeResponse.
         * @memberof api
         * @interface ISessionResolveChallengeResponse
         * @property {Uint8Array|null} [salt] SessionResolveChallengeResponse salt
         * @property {string|null} [login] SessionResolveChallengeResponse login
         */

        /**
         * Constructs a new SessionResolveChallengeResponse.
         * @memberof api
         * @classdesc Represents a SessionResolveChallengeResponse.
         * @implements ISessionResolveChallengeResponse
         * @constructor
         * @param {api.ISessionResolveChallengeResponse=} [properties] Properties to set
         */
        function SessionResolveChallengeResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SessionResolveChallengeResponse salt.
         * @member {Uint8Array} salt
         * @memberof api.SessionResolveChallengeResponse
         * @instance
         */
        SessionResolveChallengeResponse.prototype.salt = $util.newBuffer([]);

        /**
         * SessionResolveChallengeResponse login.
         * @member {string} login
         * @memberof api.SessionResolveChallengeResponse
         * @instance
         */
        SessionResolveChallengeResponse.prototype.login = "";

        /**
         * Creates a new SessionResolveChallengeResponse instance using the specified properties.
         * @function create
         * @memberof api.SessionResolveChallengeResponse
         * @static
         * @param {api.ISessionResolveChallengeResponse=} [properties] Properties to set
         * @returns {api.SessionResolveChallengeResponse} SessionResolveChallengeResponse instance
         */
        SessionResolveChallengeResponse.create = function create(properties) {
            return new SessionResolveChallengeResponse(properties);
        };

        /**
         * Encodes the specified SessionResolveChallengeResponse message. Does not implicitly {@link api.SessionResolveChallengeResponse.verify|verify} messages.
         * @function encode
         * @memberof api.SessionResolveChallengeResponse
         * @static
         * @param {api.ISessionResolveChallengeResponse} message SessionResolveChallengeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionResolveChallengeResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.salt != null && message.hasOwnProperty("salt"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.salt);
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.login);
            return writer;
        };

        /**
         * Encodes the specified SessionResolveChallengeResponse message, length delimited. Does not implicitly {@link api.SessionResolveChallengeResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.SessionResolveChallengeResponse
         * @static
         * @param {api.ISessionResolveChallengeResponse} message SessionResolveChallengeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionResolveChallengeResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SessionResolveChallengeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.SessionResolveChallengeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.SessionResolveChallengeResponse} SessionResolveChallengeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionResolveChallengeResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.SessionResolveChallengeResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.salt = reader.bytes();
                    break;
                case 2:
                    message.login = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SessionResolveChallengeResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.SessionResolveChallengeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.SessionResolveChallengeResponse} SessionResolveChallengeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionResolveChallengeResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SessionResolveChallengeResponse message.
         * @function verify
         * @memberof api.SessionResolveChallengeResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SessionResolveChallengeResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.salt != null && message.hasOwnProperty("salt"))
                if (!(message.salt && typeof message.salt.length === "number" || $util.isString(message.salt)))
                    return "salt: buffer expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            return null;
        };

        /**
         * Creates a SessionResolveChallengeResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.SessionResolveChallengeResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.SessionResolveChallengeResponse} SessionResolveChallengeResponse
         */
        SessionResolveChallengeResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.SessionResolveChallengeResponse)
                return object;
            var message = new $root.api.SessionResolveChallengeResponse();
            if (object.salt != null)
                if (typeof object.salt === "string")
                    $util.base64.decode(object.salt, message.salt = $util.newBuffer($util.base64.length(object.salt)), 0);
                else if (object.salt.length)
                    message.salt = object.salt;
            if (object.login != null)
                message.login = String(object.login);
            return message;
        };

        /**
         * Creates a plain object from a SessionResolveChallengeResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.SessionResolveChallengeResponse
         * @static
         * @param {api.SessionResolveChallengeResponse} message SessionResolveChallengeResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionResolveChallengeResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.salt = "";
                else {
                    object.salt = [];
                    if (options.bytes !== Array)
                        object.salt = $util.newBuffer(object.salt);
                }
                object.login = "";
            }
            if (message.salt != null && message.hasOwnProperty("salt"))
                object.salt = options.bytes === String ? $util.base64.encode(message.salt, 0, message.salt.length) : options.bytes === Array ? Array.prototype.slice.call(message.salt) : message.salt;
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            return object;
        };

        /**
         * Converts this SessionResolveChallengeResponse to JSON.
         * @function toJSON
         * @memberof api.SessionResolveChallengeResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionResolveChallengeResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SessionResolveChallengeResponse;
    })();

    /**
     * JwtAlgorithm enum.
     * @name api.JwtAlgorithm
     * @enum {string}
     * @property {number} HS256=0 HS256 value
     * @property {number} HS384=1 HS384 value
     * @property {number} HS512=2 HS512 value
     * @property {number} RS256=3 RS256 value
     * @property {number} RS384=4 RS384 value
     * @property {number} RS512=5 RS512 value
     * @property {number} ES256=6 ES256 value
     * @property {number} ES384=7 ES384 value
     * @property {number} ES512=8 ES512 value
     */
    api.JwtAlgorithm = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "HS256"] = 0;
        values[valuesById[1] = "HS384"] = 1;
        values[valuesById[2] = "HS512"] = 2;
        values[valuesById[3] = "RS256"] = 3;
        values[valuesById[4] = "RS384"] = 4;
        values[valuesById[5] = "RS512"] = 5;
        values[valuesById[6] = "ES256"] = 6;
        values[valuesById[7] = "ES384"] = 7;
        values[valuesById[8] = "ES512"] = 8;
        return values;
    })();

    api.IdentityConfigurationAsApplication = (function() {

        /**
         * Properties of an IdentityConfigurationAsApplication.
         * @memberof api
         * @interface IIdentityConfigurationAsApplication
         * @property {api.IdentityConfigurationAsApplication.IJWT|null} [jwt] IdentityConfigurationAsApplication jwt
         */

        /**
         * Constructs a new IdentityConfigurationAsApplication.
         * @memberof api
         * @classdesc Represents an IdentityConfigurationAsApplication.
         * @implements IIdentityConfigurationAsApplication
         * @constructor
         * @param {api.IIdentityConfigurationAsApplication=} [properties] Properties to set
         */
        function IdentityConfigurationAsApplication(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityConfigurationAsApplication jwt.
         * @member {api.IdentityConfigurationAsApplication.IJWT|null|undefined} jwt
         * @memberof api.IdentityConfigurationAsApplication
         * @instance
         */
        IdentityConfigurationAsApplication.prototype.jwt = null;

        /**
         * Creates a new IdentityConfigurationAsApplication instance using the specified properties.
         * @function create
         * @memberof api.IdentityConfigurationAsApplication
         * @static
         * @param {api.IIdentityConfigurationAsApplication=} [properties] Properties to set
         * @returns {api.IdentityConfigurationAsApplication} IdentityConfigurationAsApplication instance
         */
        IdentityConfigurationAsApplication.create = function create(properties) {
            return new IdentityConfigurationAsApplication(properties);
        };

        /**
         * Encodes the specified IdentityConfigurationAsApplication message. Does not implicitly {@link api.IdentityConfigurationAsApplication.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityConfigurationAsApplication
         * @static
         * @param {api.IIdentityConfigurationAsApplication} message IdentityConfigurationAsApplication message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityConfigurationAsApplication.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.jwt != null && message.hasOwnProperty("jwt"))
                $root.api.IdentityConfigurationAsApplication.JWT.encode(message.jwt, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityConfigurationAsApplication message, length delimited. Does not implicitly {@link api.IdentityConfigurationAsApplication.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityConfigurationAsApplication
         * @static
         * @param {api.IIdentityConfigurationAsApplication} message IdentityConfigurationAsApplication message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityConfigurationAsApplication.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityConfigurationAsApplication message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityConfigurationAsApplication
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityConfigurationAsApplication} IdentityConfigurationAsApplication
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityConfigurationAsApplication.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityConfigurationAsApplication();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.jwt = $root.api.IdentityConfigurationAsApplication.JWT.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityConfigurationAsApplication message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityConfigurationAsApplication
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityConfigurationAsApplication} IdentityConfigurationAsApplication
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityConfigurationAsApplication.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityConfigurationAsApplication message.
         * @function verify
         * @memberof api.IdentityConfigurationAsApplication
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityConfigurationAsApplication.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.jwt != null && message.hasOwnProperty("jwt")) {
                var error = $root.api.IdentityConfigurationAsApplication.JWT.verify(message.jwt);
                if (error)
                    return "jwt." + error;
            }
            return null;
        };

        /**
         * Creates an IdentityConfigurationAsApplication message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityConfigurationAsApplication
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityConfigurationAsApplication} IdentityConfigurationAsApplication
         */
        IdentityConfigurationAsApplication.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityConfigurationAsApplication)
                return object;
            var message = new $root.api.IdentityConfigurationAsApplication();
            if (object.jwt != null) {
                if (typeof object.jwt !== "object")
                    throw TypeError(".api.IdentityConfigurationAsApplication.jwt: object expected");
                message.jwt = $root.api.IdentityConfigurationAsApplication.JWT.fromObject(object.jwt);
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityConfigurationAsApplication message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityConfigurationAsApplication
         * @static
         * @param {api.IdentityConfigurationAsApplication} message IdentityConfigurationAsApplication
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityConfigurationAsApplication.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.jwt = null;
            if (message.jwt != null && message.hasOwnProperty("jwt"))
                object.jwt = $root.api.IdentityConfigurationAsApplication.JWT.toObject(message.jwt, options);
            return object;
        };

        /**
         * Converts this IdentityConfigurationAsApplication to JSON.
         * @function toJSON
         * @memberof api.IdentityConfigurationAsApplication
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityConfigurationAsApplication.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        IdentityConfigurationAsApplication.JWT = (function() {

            /**
             * Properties of a JWT.
             * @memberof api.IdentityConfigurationAsApplication
             * @interface IJWT
             * @property {Uint8Array|null} [key] JWT key
             * @property {api.JwtAlgorithm|null} [signAlgorithm] JWT signAlgorithm
             * @property {string|null} [claimForLogin] JWT claimForLogin
             */

            /**
             * Constructs a new JWT.
             * @memberof api.IdentityConfigurationAsApplication
             * @classdesc Represents a JWT.
             * @implements IJWT
             * @constructor
             * @param {api.IdentityConfigurationAsApplication.IJWT=} [properties] Properties to set
             */
            function JWT(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * JWT key.
             * @member {Uint8Array} key
             * @memberof api.IdentityConfigurationAsApplication.JWT
             * @instance
             */
            JWT.prototype.key = $util.newBuffer([]);

            /**
             * JWT signAlgorithm.
             * @member {api.JwtAlgorithm} signAlgorithm
             * @memberof api.IdentityConfigurationAsApplication.JWT
             * @instance
             */
            JWT.prototype.signAlgorithm = 0;

            /**
             * JWT claimForLogin.
             * @member {string} claimForLogin
             * @memberof api.IdentityConfigurationAsApplication.JWT
             * @instance
             */
            JWT.prototype.claimForLogin = "";

            /**
             * Creates a new JWT instance using the specified properties.
             * @function create
             * @memberof api.IdentityConfigurationAsApplication.JWT
             * @static
             * @param {api.IdentityConfigurationAsApplication.IJWT=} [properties] Properties to set
             * @returns {api.IdentityConfigurationAsApplication.JWT} JWT instance
             */
            JWT.create = function create(properties) {
                return new JWT(properties);
            };

            /**
             * Encodes the specified JWT message. Does not implicitly {@link api.IdentityConfigurationAsApplication.JWT.verify|verify} messages.
             * @function encode
             * @memberof api.IdentityConfigurationAsApplication.JWT
             * @static
             * @param {api.IdentityConfigurationAsApplication.IJWT} message JWT message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JWT.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && message.hasOwnProperty("key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
                if (message.signAlgorithm != null && message.hasOwnProperty("signAlgorithm"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.signAlgorithm);
                if (message.claimForLogin != null && message.hasOwnProperty("claimForLogin"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.claimForLogin);
                return writer;
            };

            /**
             * Encodes the specified JWT message, length delimited. Does not implicitly {@link api.IdentityConfigurationAsApplication.JWT.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.IdentityConfigurationAsApplication.JWT
             * @static
             * @param {api.IdentityConfigurationAsApplication.IJWT} message JWT message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JWT.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a JWT message from the specified reader or buffer.
             * @function decode
             * @memberof api.IdentityConfigurationAsApplication.JWT
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.IdentityConfigurationAsApplication.JWT} JWT
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JWT.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityConfigurationAsApplication.JWT();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.bytes();
                        break;
                    case 2:
                        message.signAlgorithm = reader.int32();
                        break;
                    case 3:
                        message.claimForLogin = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a JWT message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.IdentityConfigurationAsApplication.JWT
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.IdentityConfigurationAsApplication.JWT} JWT
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JWT.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a JWT message.
             * @function verify
             * @memberof api.IdentityConfigurationAsApplication.JWT
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            JWT.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                        return "key: buffer expected";
                if (message.signAlgorithm != null && message.hasOwnProperty("signAlgorithm"))
                    switch (message.signAlgorithm) {
                    default:
                        return "signAlgorithm: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                    }
                if (message.claimForLogin != null && message.hasOwnProperty("claimForLogin"))
                    if (!$util.isString(message.claimForLogin))
                        return "claimForLogin: string expected";
                return null;
            };

            /**
             * Creates a JWT message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.IdentityConfigurationAsApplication.JWT
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.IdentityConfigurationAsApplication.JWT} JWT
             */
            JWT.fromObject = function fromObject(object) {
                if (object instanceof $root.api.IdentityConfigurationAsApplication.JWT)
                    return object;
                var message = new $root.api.IdentityConfigurationAsApplication.JWT();
                if (object.key != null)
                    if (typeof object.key === "string")
                        $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                    else if (object.key.length)
                        message.key = object.key;
                switch (object.signAlgorithm) {
                case "HS256":
                case 0:
                    message.signAlgorithm = 0;
                    break;
                case "HS384":
                case 1:
                    message.signAlgorithm = 1;
                    break;
                case "HS512":
                case 2:
                    message.signAlgorithm = 2;
                    break;
                case "RS256":
                case 3:
                    message.signAlgorithm = 3;
                    break;
                case "RS384":
                case 4:
                    message.signAlgorithm = 4;
                    break;
                case "RS512":
                case 5:
                    message.signAlgorithm = 5;
                    break;
                case "ES256":
                case 6:
                    message.signAlgorithm = 6;
                    break;
                case "ES384":
                case 7:
                    message.signAlgorithm = 7;
                    break;
                case "ES512":
                case 8:
                    message.signAlgorithm = 8;
                    break;
                }
                if (object.claimForLogin != null)
                    message.claimForLogin = String(object.claimForLogin);
                return message;
            };

            /**
             * Creates a plain object from a JWT message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.IdentityConfigurationAsApplication.JWT
             * @static
             * @param {api.IdentityConfigurationAsApplication.JWT} message JWT
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            JWT.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.key = "";
                    else {
                        object.key = [];
                        if (options.bytes !== Array)
                            object.key = $util.newBuffer(object.key);
                    }
                    object.signAlgorithm = options.enums === String ? "HS256" : 0;
                    object.claimForLogin = "";
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                if (message.signAlgorithm != null && message.hasOwnProperty("signAlgorithm"))
                    object.signAlgorithm = options.enums === String ? $root.api.JwtAlgorithm[message.signAlgorithm] : message.signAlgorithm;
                if (message.claimForLogin != null && message.hasOwnProperty("claimForLogin"))
                    object.claimForLogin = message.claimForLogin;
                return object;
            };

            /**
             * Converts this JWT to JSON.
             * @function toJSON
             * @memberof api.IdentityConfigurationAsApplication.JWT
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            JWT.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return JWT;
        })();

        return IdentityConfigurationAsApplication;
    })();

    api.IdentityConfigurationAsApplicationRequest = (function() {

        /**
         * Properties of an IdentityConfigurationAsApplicationRequest.
         * @memberof api
         * @interface IIdentityConfigurationAsApplicationRequest
         * @property {string|null} [Login] IdentityConfigurationAsApplicationRequest Login
         * @property {api.IIdentityConfigurationAsApplication|null} [config] IdentityConfigurationAsApplicationRequest config
         */

        /**
         * Constructs a new IdentityConfigurationAsApplicationRequest.
         * @memberof api
         * @classdesc Represents an IdentityConfigurationAsApplicationRequest.
         * @implements IIdentityConfigurationAsApplicationRequest
         * @constructor
         * @param {api.IIdentityConfigurationAsApplicationRequest=} [properties] Properties to set
         */
        function IdentityConfigurationAsApplicationRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityConfigurationAsApplicationRequest Login.
         * @member {string} Login
         * @memberof api.IdentityConfigurationAsApplicationRequest
         * @instance
         */
        IdentityConfigurationAsApplicationRequest.prototype.Login = "";

        /**
         * IdentityConfigurationAsApplicationRequest config.
         * @member {api.IIdentityConfigurationAsApplication|null|undefined} config
         * @memberof api.IdentityConfigurationAsApplicationRequest
         * @instance
         */
        IdentityConfigurationAsApplicationRequest.prototype.config = null;

        /**
         * Creates a new IdentityConfigurationAsApplicationRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityConfigurationAsApplicationRequest
         * @static
         * @param {api.IIdentityConfigurationAsApplicationRequest=} [properties] Properties to set
         * @returns {api.IdentityConfigurationAsApplicationRequest} IdentityConfigurationAsApplicationRequest instance
         */
        IdentityConfigurationAsApplicationRequest.create = function create(properties) {
            return new IdentityConfigurationAsApplicationRequest(properties);
        };

        /**
         * Encodes the specified IdentityConfigurationAsApplicationRequest message. Does not implicitly {@link api.IdentityConfigurationAsApplicationRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityConfigurationAsApplicationRequest
         * @static
         * @param {api.IIdentityConfigurationAsApplicationRequest} message IdentityConfigurationAsApplicationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityConfigurationAsApplicationRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Login != null && message.hasOwnProperty("Login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Login);
            if (message.config != null && message.hasOwnProperty("config"))
                $root.api.IdentityConfigurationAsApplication.encode(message.config, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityConfigurationAsApplicationRequest message, length delimited. Does not implicitly {@link api.IdentityConfigurationAsApplicationRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityConfigurationAsApplicationRequest
         * @static
         * @param {api.IIdentityConfigurationAsApplicationRequest} message IdentityConfigurationAsApplicationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityConfigurationAsApplicationRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityConfigurationAsApplicationRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityConfigurationAsApplicationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityConfigurationAsApplicationRequest} IdentityConfigurationAsApplicationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityConfigurationAsApplicationRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityConfigurationAsApplicationRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Login = reader.string();
                    break;
                case 2:
                    message.config = $root.api.IdentityConfigurationAsApplication.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityConfigurationAsApplicationRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityConfigurationAsApplicationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityConfigurationAsApplicationRequest} IdentityConfigurationAsApplicationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityConfigurationAsApplicationRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityConfigurationAsApplicationRequest message.
         * @function verify
         * @memberof api.IdentityConfigurationAsApplicationRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityConfigurationAsApplicationRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Login != null && message.hasOwnProperty("Login"))
                if (!$util.isString(message.Login))
                    return "Login: string expected";
            if (message.config != null && message.hasOwnProperty("config")) {
                var error = $root.api.IdentityConfigurationAsApplication.verify(message.config);
                if (error)
                    return "config." + error;
            }
            return null;
        };

        /**
         * Creates an IdentityConfigurationAsApplicationRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityConfigurationAsApplicationRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityConfigurationAsApplicationRequest} IdentityConfigurationAsApplicationRequest
         */
        IdentityConfigurationAsApplicationRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityConfigurationAsApplicationRequest)
                return object;
            var message = new $root.api.IdentityConfigurationAsApplicationRequest();
            if (object.Login != null)
                message.Login = String(object.Login);
            if (object.config != null) {
                if (typeof object.config !== "object")
                    throw TypeError(".api.IdentityConfigurationAsApplicationRequest.config: object expected");
                message.config = $root.api.IdentityConfigurationAsApplication.fromObject(object.config);
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityConfigurationAsApplicationRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityConfigurationAsApplicationRequest
         * @static
         * @param {api.IdentityConfigurationAsApplicationRequest} message IdentityConfigurationAsApplicationRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityConfigurationAsApplicationRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.Login = "";
                object.config = null;
            }
            if (message.Login != null && message.hasOwnProperty("Login"))
                object.Login = message.Login;
            if (message.config != null && message.hasOwnProperty("config"))
                object.config = $root.api.IdentityConfigurationAsApplication.toObject(message.config, options);
            return object;
        };

        /**
         * Converts this IdentityConfigurationAsApplicationRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityConfigurationAsApplicationRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityConfigurationAsApplicationRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityConfigurationAsApplicationRequest;
    })();

    api.IdentityConfigurationAsApplicationResponse = (function() {

        /**
         * Properties of an IdentityConfigurationAsApplicationResponse.
         * @memberof api
         * @interface IIdentityConfigurationAsApplicationResponse
         * @property {api.IIdentityConfigurationAsApplication|null} [config] IdentityConfigurationAsApplicationResponse config
         */

        /**
         * Constructs a new IdentityConfigurationAsApplicationResponse.
         * @memberof api
         * @classdesc Represents an IdentityConfigurationAsApplicationResponse.
         * @implements IIdentityConfigurationAsApplicationResponse
         * @constructor
         * @param {api.IIdentityConfigurationAsApplicationResponse=} [properties] Properties to set
         */
        function IdentityConfigurationAsApplicationResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityConfigurationAsApplicationResponse config.
         * @member {api.IIdentityConfigurationAsApplication|null|undefined} config
         * @memberof api.IdentityConfigurationAsApplicationResponse
         * @instance
         */
        IdentityConfigurationAsApplicationResponse.prototype.config = null;

        /**
         * Creates a new IdentityConfigurationAsApplicationResponse instance using the specified properties.
         * @function create
         * @memberof api.IdentityConfigurationAsApplicationResponse
         * @static
         * @param {api.IIdentityConfigurationAsApplicationResponse=} [properties] Properties to set
         * @returns {api.IdentityConfigurationAsApplicationResponse} IdentityConfigurationAsApplicationResponse instance
         */
        IdentityConfigurationAsApplicationResponse.create = function create(properties) {
            return new IdentityConfigurationAsApplicationResponse(properties);
        };

        /**
         * Encodes the specified IdentityConfigurationAsApplicationResponse message. Does not implicitly {@link api.IdentityConfigurationAsApplicationResponse.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityConfigurationAsApplicationResponse
         * @static
         * @param {api.IIdentityConfigurationAsApplicationResponse} message IdentityConfigurationAsApplicationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityConfigurationAsApplicationResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.config != null && message.hasOwnProperty("config"))
                $root.api.IdentityConfigurationAsApplication.encode(message.config, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityConfigurationAsApplicationResponse message, length delimited. Does not implicitly {@link api.IdentityConfigurationAsApplicationResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityConfigurationAsApplicationResponse
         * @static
         * @param {api.IIdentityConfigurationAsApplicationResponse} message IdentityConfigurationAsApplicationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityConfigurationAsApplicationResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityConfigurationAsApplicationResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityConfigurationAsApplicationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityConfigurationAsApplicationResponse} IdentityConfigurationAsApplicationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityConfigurationAsApplicationResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityConfigurationAsApplicationResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.config = $root.api.IdentityConfigurationAsApplication.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityConfigurationAsApplicationResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityConfigurationAsApplicationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityConfigurationAsApplicationResponse} IdentityConfigurationAsApplicationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityConfigurationAsApplicationResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityConfigurationAsApplicationResponse message.
         * @function verify
         * @memberof api.IdentityConfigurationAsApplicationResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityConfigurationAsApplicationResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.config != null && message.hasOwnProperty("config")) {
                var error = $root.api.IdentityConfigurationAsApplication.verify(message.config);
                if (error)
                    return "config." + error;
            }
            return null;
        };

        /**
         * Creates an IdentityConfigurationAsApplicationResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityConfigurationAsApplicationResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityConfigurationAsApplicationResponse} IdentityConfigurationAsApplicationResponse
         */
        IdentityConfigurationAsApplicationResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityConfigurationAsApplicationResponse)
                return object;
            var message = new $root.api.IdentityConfigurationAsApplicationResponse();
            if (object.config != null) {
                if (typeof object.config !== "object")
                    throw TypeError(".api.IdentityConfigurationAsApplicationResponse.config: object expected");
                message.config = $root.api.IdentityConfigurationAsApplication.fromObject(object.config);
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityConfigurationAsApplicationResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityConfigurationAsApplicationResponse
         * @static
         * @param {api.IdentityConfigurationAsApplicationResponse} message IdentityConfigurationAsApplicationResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityConfigurationAsApplicationResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.config = null;
            if (message.config != null && message.hasOwnProperty("config"))
                object.config = $root.api.IdentityConfigurationAsApplication.toObject(message.config, options);
            return object;
        };

        /**
         * Converts this IdentityConfigurationAsApplicationResponse to JSON.
         * @function toJSON
         * @memberof api.IdentityConfigurationAsApplicationResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityConfigurationAsApplicationResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityConfigurationAsApplicationResponse;
    })();

    api.ApplicationUsageOverview = (function() {

        /**
         * Properties of an ApplicationUsageOverview.
         * @memberof api
         * @interface IApplicationUsageOverview
         * @property {api.ApplicationUsageOverview.IJWT|null} [jwt] ApplicationUsageOverview jwt
         * @property {api.ApplicationUsageOverview.IDelegatedAccess|null} [delegates] ApplicationUsageOverview delegates
         */

        /**
         * Constructs a new ApplicationUsageOverview.
         * @memberof api
         * @classdesc Represents an ApplicationUsageOverview.
         * @implements IApplicationUsageOverview
         * @constructor
         * @param {api.IApplicationUsageOverview=} [properties] Properties to set
         */
        function ApplicationUsageOverview(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApplicationUsageOverview jwt.
         * @member {api.ApplicationUsageOverview.IJWT|null|undefined} jwt
         * @memberof api.ApplicationUsageOverview
         * @instance
         */
        ApplicationUsageOverview.prototype.jwt = null;

        /**
         * ApplicationUsageOverview delegates.
         * @member {api.ApplicationUsageOverview.IDelegatedAccess|null|undefined} delegates
         * @memberof api.ApplicationUsageOverview
         * @instance
         */
        ApplicationUsageOverview.prototype.delegates = null;

        /**
         * Creates a new ApplicationUsageOverview instance using the specified properties.
         * @function create
         * @memberof api.ApplicationUsageOverview
         * @static
         * @param {api.IApplicationUsageOverview=} [properties] Properties to set
         * @returns {api.ApplicationUsageOverview} ApplicationUsageOverview instance
         */
        ApplicationUsageOverview.create = function create(properties) {
            return new ApplicationUsageOverview(properties);
        };

        /**
         * Encodes the specified ApplicationUsageOverview message. Does not implicitly {@link api.ApplicationUsageOverview.verify|verify} messages.
         * @function encode
         * @memberof api.ApplicationUsageOverview
         * @static
         * @param {api.IApplicationUsageOverview} message ApplicationUsageOverview message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationUsageOverview.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.jwt != null && message.hasOwnProperty("jwt"))
                $root.api.ApplicationUsageOverview.JWT.encode(message.jwt, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.delegates != null && message.hasOwnProperty("delegates"))
                $root.api.ApplicationUsageOverview.DelegatedAccess.encode(message.delegates, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ApplicationUsageOverview message, length delimited. Does not implicitly {@link api.ApplicationUsageOverview.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ApplicationUsageOverview
         * @static
         * @param {api.IApplicationUsageOverview} message ApplicationUsageOverview message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationUsageOverview.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApplicationUsageOverview message from the specified reader or buffer.
         * @function decode
         * @memberof api.ApplicationUsageOverview
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ApplicationUsageOverview} ApplicationUsageOverview
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationUsageOverview.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ApplicationUsageOverview();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.jwt = $root.api.ApplicationUsageOverview.JWT.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.delegates = $root.api.ApplicationUsageOverview.DelegatedAccess.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApplicationUsageOverview message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ApplicationUsageOverview
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ApplicationUsageOverview} ApplicationUsageOverview
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationUsageOverview.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApplicationUsageOverview message.
         * @function verify
         * @memberof api.ApplicationUsageOverview
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApplicationUsageOverview.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.jwt != null && message.hasOwnProperty("jwt")) {
                var error = $root.api.ApplicationUsageOverview.JWT.verify(message.jwt);
                if (error)
                    return "jwt." + error;
            }
            if (message.delegates != null && message.hasOwnProperty("delegates")) {
                var error = $root.api.ApplicationUsageOverview.DelegatedAccess.verify(message.delegates);
                if (error)
                    return "delegates." + error;
            }
            return null;
        };

        /**
         * Creates an ApplicationUsageOverview message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ApplicationUsageOverview
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ApplicationUsageOverview} ApplicationUsageOverview
         */
        ApplicationUsageOverview.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ApplicationUsageOverview)
                return object;
            var message = new $root.api.ApplicationUsageOverview();
            if (object.jwt != null) {
                if (typeof object.jwt !== "object")
                    throw TypeError(".api.ApplicationUsageOverview.jwt: object expected");
                message.jwt = $root.api.ApplicationUsageOverview.JWT.fromObject(object.jwt);
            }
            if (object.delegates != null) {
                if (typeof object.delegates !== "object")
                    throw TypeError(".api.ApplicationUsageOverview.delegates: object expected");
                message.delegates = $root.api.ApplicationUsageOverview.DelegatedAccess.fromObject(object.delegates);
            }
            return message;
        };

        /**
         * Creates a plain object from an ApplicationUsageOverview message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ApplicationUsageOverview
         * @static
         * @param {api.ApplicationUsageOverview} message ApplicationUsageOverview
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApplicationUsageOverview.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.jwt = null;
                object.delegates = null;
            }
            if (message.jwt != null && message.hasOwnProperty("jwt"))
                object.jwt = $root.api.ApplicationUsageOverview.JWT.toObject(message.jwt, options);
            if (message.delegates != null && message.hasOwnProperty("delegates"))
                object.delegates = $root.api.ApplicationUsageOverview.DelegatedAccess.toObject(message.delegates, options);
            return object;
        };

        /**
         * Converts this ApplicationUsageOverview to JSON.
         * @function toJSON
         * @memberof api.ApplicationUsageOverview
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApplicationUsageOverview.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        ApplicationUsageOverview.JWT = (function() {

            /**
             * Properties of a JWT.
             * @memberof api.ApplicationUsageOverview
             * @interface IJWT
             * @property {number|null} [totalIdentities] JWT totalIdentities
             * @property {number|null} [newIdentities] JWT newIdentities
             * @property {number|null} [newSessions] JWT newSessions
             */

            /**
             * Constructs a new JWT.
             * @memberof api.ApplicationUsageOverview
             * @classdesc Represents a JWT.
             * @implements IJWT
             * @constructor
             * @param {api.ApplicationUsageOverview.IJWT=} [properties] Properties to set
             */
            function JWT(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * JWT totalIdentities.
             * @member {number} totalIdentities
             * @memberof api.ApplicationUsageOverview.JWT
             * @instance
             */
            JWT.prototype.totalIdentities = 0;

            /**
             * JWT newIdentities.
             * @member {number} newIdentities
             * @memberof api.ApplicationUsageOverview.JWT
             * @instance
             */
            JWT.prototype.newIdentities = 0;

            /**
             * JWT newSessions.
             * @member {number} newSessions
             * @memberof api.ApplicationUsageOverview.JWT
             * @instance
             */
            JWT.prototype.newSessions = 0;

            /**
             * Creates a new JWT instance using the specified properties.
             * @function create
             * @memberof api.ApplicationUsageOverview.JWT
             * @static
             * @param {api.ApplicationUsageOverview.IJWT=} [properties] Properties to set
             * @returns {api.ApplicationUsageOverview.JWT} JWT instance
             */
            JWT.create = function create(properties) {
                return new JWT(properties);
            };

            /**
             * Encodes the specified JWT message. Does not implicitly {@link api.ApplicationUsageOverview.JWT.verify|verify} messages.
             * @function encode
             * @memberof api.ApplicationUsageOverview.JWT
             * @static
             * @param {api.ApplicationUsageOverview.IJWT} message JWT message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JWT.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.totalIdentities != null && message.hasOwnProperty("totalIdentities"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.totalIdentities);
                if (message.newIdentities != null && message.hasOwnProperty("newIdentities"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.newIdentities);
                if (message.newSessions != null && message.hasOwnProperty("newSessions"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.newSessions);
                return writer;
            };

            /**
             * Encodes the specified JWT message, length delimited. Does not implicitly {@link api.ApplicationUsageOverview.JWT.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.ApplicationUsageOverview.JWT
             * @static
             * @param {api.ApplicationUsageOverview.IJWT} message JWT message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JWT.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a JWT message from the specified reader or buffer.
             * @function decode
             * @memberof api.ApplicationUsageOverview.JWT
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.ApplicationUsageOverview.JWT} JWT
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JWT.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ApplicationUsageOverview.JWT();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.totalIdentities = reader.uint32();
                        break;
                    case 2:
                        message.newIdentities = reader.uint32();
                        break;
                    case 3:
                        message.newSessions = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a JWT message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.ApplicationUsageOverview.JWT
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.ApplicationUsageOverview.JWT} JWT
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JWT.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a JWT message.
             * @function verify
             * @memberof api.ApplicationUsageOverview.JWT
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            JWT.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.totalIdentities != null && message.hasOwnProperty("totalIdentities"))
                    if (!$util.isInteger(message.totalIdentities))
                        return "totalIdentities: integer expected";
                if (message.newIdentities != null && message.hasOwnProperty("newIdentities"))
                    if (!$util.isInteger(message.newIdentities))
                        return "newIdentities: integer expected";
                if (message.newSessions != null && message.hasOwnProperty("newSessions"))
                    if (!$util.isInteger(message.newSessions))
                        return "newSessions: integer expected";
                return null;
            };

            /**
             * Creates a JWT message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.ApplicationUsageOverview.JWT
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.ApplicationUsageOverview.JWT} JWT
             */
            JWT.fromObject = function fromObject(object) {
                if (object instanceof $root.api.ApplicationUsageOverview.JWT)
                    return object;
                var message = new $root.api.ApplicationUsageOverview.JWT();
                if (object.totalIdentities != null)
                    message.totalIdentities = object.totalIdentities >>> 0;
                if (object.newIdentities != null)
                    message.newIdentities = object.newIdentities >>> 0;
                if (object.newSessions != null)
                    message.newSessions = object.newSessions >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a JWT message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.ApplicationUsageOverview.JWT
             * @static
             * @param {api.ApplicationUsageOverview.JWT} message JWT
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            JWT.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.totalIdentities = 0;
                    object.newIdentities = 0;
                    object.newSessions = 0;
                }
                if (message.totalIdentities != null && message.hasOwnProperty("totalIdentities"))
                    object.totalIdentities = message.totalIdentities;
                if (message.newIdentities != null && message.hasOwnProperty("newIdentities"))
                    object.newIdentities = message.newIdentities;
                if (message.newSessions != null && message.hasOwnProperty("newSessions"))
                    object.newSessions = message.newSessions;
                return object;
            };

            /**
             * Converts this JWT to JSON.
             * @function toJSON
             * @memberof api.ApplicationUsageOverview.JWT
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            JWT.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return JWT;
        })();

        ApplicationUsageOverview.DelegatedAccess = (function() {

            /**
             * Properties of a DelegatedAccess.
             * @memberof api.ApplicationUsageOverview
             * @interface IDelegatedAccess
             * @property {number|null} [newRequested] DelegatedAccess newRequested
             * @property {number|null} [newResolved] DelegatedAccess newResolved
             * @property {number|null} [newDistinctRequested] DelegatedAccess newDistinctRequested
             * @property {number|null} [newDistinctResolved] DelegatedAccess newDistinctResolved
             */

            /**
             * Constructs a new DelegatedAccess.
             * @memberof api.ApplicationUsageOverview
             * @classdesc Represents a DelegatedAccess.
             * @implements IDelegatedAccess
             * @constructor
             * @param {api.ApplicationUsageOverview.IDelegatedAccess=} [properties] Properties to set
             */
            function DelegatedAccess(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DelegatedAccess newRequested.
             * @member {number} newRequested
             * @memberof api.ApplicationUsageOverview.DelegatedAccess
             * @instance
             */
            DelegatedAccess.prototype.newRequested = 0;

            /**
             * DelegatedAccess newResolved.
             * @member {number} newResolved
             * @memberof api.ApplicationUsageOverview.DelegatedAccess
             * @instance
             */
            DelegatedAccess.prototype.newResolved = 0;

            /**
             * DelegatedAccess newDistinctRequested.
             * @member {number} newDistinctRequested
             * @memberof api.ApplicationUsageOverview.DelegatedAccess
             * @instance
             */
            DelegatedAccess.prototype.newDistinctRequested = 0;

            /**
             * DelegatedAccess newDistinctResolved.
             * @member {number} newDistinctResolved
             * @memberof api.ApplicationUsageOverview.DelegatedAccess
             * @instance
             */
            DelegatedAccess.prototype.newDistinctResolved = 0;

            /**
             * Creates a new DelegatedAccess instance using the specified properties.
             * @function create
             * @memberof api.ApplicationUsageOverview.DelegatedAccess
             * @static
             * @param {api.ApplicationUsageOverview.IDelegatedAccess=} [properties] Properties to set
             * @returns {api.ApplicationUsageOverview.DelegatedAccess} DelegatedAccess instance
             */
            DelegatedAccess.create = function create(properties) {
                return new DelegatedAccess(properties);
            };

            /**
             * Encodes the specified DelegatedAccess message. Does not implicitly {@link api.ApplicationUsageOverview.DelegatedAccess.verify|verify} messages.
             * @function encode
             * @memberof api.ApplicationUsageOverview.DelegatedAccess
             * @static
             * @param {api.ApplicationUsageOverview.IDelegatedAccess} message DelegatedAccess message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DelegatedAccess.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.newRequested != null && message.hasOwnProperty("newRequested"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.newRequested);
                if (message.newResolved != null && message.hasOwnProperty("newResolved"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.newResolved);
                if (message.newDistinctRequested != null && message.hasOwnProperty("newDistinctRequested"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.newDistinctRequested);
                if (message.newDistinctResolved != null && message.hasOwnProperty("newDistinctResolved"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.newDistinctResolved);
                return writer;
            };

            /**
             * Encodes the specified DelegatedAccess message, length delimited. Does not implicitly {@link api.ApplicationUsageOverview.DelegatedAccess.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.ApplicationUsageOverview.DelegatedAccess
             * @static
             * @param {api.ApplicationUsageOverview.IDelegatedAccess} message DelegatedAccess message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DelegatedAccess.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DelegatedAccess message from the specified reader or buffer.
             * @function decode
             * @memberof api.ApplicationUsageOverview.DelegatedAccess
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.ApplicationUsageOverview.DelegatedAccess} DelegatedAccess
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DelegatedAccess.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ApplicationUsageOverview.DelegatedAccess();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.newRequested = reader.uint32();
                        break;
                    case 2:
                        message.newResolved = reader.uint32();
                        break;
                    case 3:
                        message.newDistinctRequested = reader.uint32();
                        break;
                    case 4:
                        message.newDistinctResolved = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DelegatedAccess message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.ApplicationUsageOverview.DelegatedAccess
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.ApplicationUsageOverview.DelegatedAccess} DelegatedAccess
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DelegatedAccess.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DelegatedAccess message.
             * @function verify
             * @memberof api.ApplicationUsageOverview.DelegatedAccess
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DelegatedAccess.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.newRequested != null && message.hasOwnProperty("newRequested"))
                    if (!$util.isInteger(message.newRequested))
                        return "newRequested: integer expected";
                if (message.newResolved != null && message.hasOwnProperty("newResolved"))
                    if (!$util.isInteger(message.newResolved))
                        return "newResolved: integer expected";
                if (message.newDistinctRequested != null && message.hasOwnProperty("newDistinctRequested"))
                    if (!$util.isInteger(message.newDistinctRequested))
                        return "newDistinctRequested: integer expected";
                if (message.newDistinctResolved != null && message.hasOwnProperty("newDistinctResolved"))
                    if (!$util.isInteger(message.newDistinctResolved))
                        return "newDistinctResolved: integer expected";
                return null;
            };

            /**
             * Creates a DelegatedAccess message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.ApplicationUsageOverview.DelegatedAccess
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.ApplicationUsageOverview.DelegatedAccess} DelegatedAccess
             */
            DelegatedAccess.fromObject = function fromObject(object) {
                if (object instanceof $root.api.ApplicationUsageOverview.DelegatedAccess)
                    return object;
                var message = new $root.api.ApplicationUsageOverview.DelegatedAccess();
                if (object.newRequested != null)
                    message.newRequested = object.newRequested >>> 0;
                if (object.newResolved != null)
                    message.newResolved = object.newResolved >>> 0;
                if (object.newDistinctRequested != null)
                    message.newDistinctRequested = object.newDistinctRequested >>> 0;
                if (object.newDistinctResolved != null)
                    message.newDistinctResolved = object.newDistinctResolved >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a DelegatedAccess message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.ApplicationUsageOverview.DelegatedAccess
             * @static
             * @param {api.ApplicationUsageOverview.DelegatedAccess} message DelegatedAccess
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DelegatedAccess.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.newRequested = 0;
                    object.newResolved = 0;
                    object.newDistinctRequested = 0;
                    object.newDistinctResolved = 0;
                }
                if (message.newRequested != null && message.hasOwnProperty("newRequested"))
                    object.newRequested = message.newRequested;
                if (message.newResolved != null && message.hasOwnProperty("newResolved"))
                    object.newResolved = message.newResolved;
                if (message.newDistinctRequested != null && message.hasOwnProperty("newDistinctRequested"))
                    object.newDistinctRequested = message.newDistinctRequested;
                if (message.newDistinctResolved != null && message.hasOwnProperty("newDistinctResolved"))
                    object.newDistinctResolved = message.newDistinctResolved;
                return object;
            };

            /**
             * Converts this DelegatedAccess to JSON.
             * @function toJSON
             * @memberof api.ApplicationUsageOverview.DelegatedAccess
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DelegatedAccess.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DelegatedAccess;
        })();

        return ApplicationUsageOverview;
    })();

    api.ApplicationUsageOverviewRequest = (function() {

        /**
         * Properties of an ApplicationUsageOverviewRequest.
         * @memberof api
         * @interface IApplicationUsageOverviewRequest
         * @property {string|null} [Login] ApplicationUsageOverviewRequest Login
         * @property {number|null} [since] ApplicationUsageOverviewRequest since
         */

        /**
         * Constructs a new ApplicationUsageOverviewRequest.
         * @memberof api
         * @classdesc Represents an ApplicationUsageOverviewRequest.
         * @implements IApplicationUsageOverviewRequest
         * @constructor
         * @param {api.IApplicationUsageOverviewRequest=} [properties] Properties to set
         */
        function ApplicationUsageOverviewRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApplicationUsageOverviewRequest Login.
         * @member {string} Login
         * @memberof api.ApplicationUsageOverviewRequest
         * @instance
         */
        ApplicationUsageOverviewRequest.prototype.Login = "";

        /**
         * ApplicationUsageOverviewRequest since.
         * @member {number} since
         * @memberof api.ApplicationUsageOverviewRequest
         * @instance
         */
        ApplicationUsageOverviewRequest.prototype.since = 0;

        /**
         * Creates a new ApplicationUsageOverviewRequest instance using the specified properties.
         * @function create
         * @memberof api.ApplicationUsageOverviewRequest
         * @static
         * @param {api.IApplicationUsageOverviewRequest=} [properties] Properties to set
         * @returns {api.ApplicationUsageOverviewRequest} ApplicationUsageOverviewRequest instance
         */
        ApplicationUsageOverviewRequest.create = function create(properties) {
            return new ApplicationUsageOverviewRequest(properties);
        };

        /**
         * Encodes the specified ApplicationUsageOverviewRequest message. Does not implicitly {@link api.ApplicationUsageOverviewRequest.verify|verify} messages.
         * @function encode
         * @memberof api.ApplicationUsageOverviewRequest
         * @static
         * @param {api.IApplicationUsageOverviewRequest} message ApplicationUsageOverviewRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationUsageOverviewRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Login != null && message.hasOwnProperty("Login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Login);
            if (message.since != null && message.hasOwnProperty("since"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.since);
            return writer;
        };

        /**
         * Encodes the specified ApplicationUsageOverviewRequest message, length delimited. Does not implicitly {@link api.ApplicationUsageOverviewRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ApplicationUsageOverviewRequest
         * @static
         * @param {api.IApplicationUsageOverviewRequest} message ApplicationUsageOverviewRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationUsageOverviewRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApplicationUsageOverviewRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.ApplicationUsageOverviewRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ApplicationUsageOverviewRequest} ApplicationUsageOverviewRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationUsageOverviewRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ApplicationUsageOverviewRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Login = reader.string();
                    break;
                case 2:
                    message.since = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApplicationUsageOverviewRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ApplicationUsageOverviewRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ApplicationUsageOverviewRequest} ApplicationUsageOverviewRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationUsageOverviewRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApplicationUsageOverviewRequest message.
         * @function verify
         * @memberof api.ApplicationUsageOverviewRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApplicationUsageOverviewRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Login != null && message.hasOwnProperty("Login"))
                if (!$util.isString(message.Login))
                    return "Login: string expected";
            if (message.since != null && message.hasOwnProperty("since"))
                if (!$util.isInteger(message.since))
                    return "since: integer expected";
            return null;
        };

        /**
         * Creates an ApplicationUsageOverviewRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ApplicationUsageOverviewRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ApplicationUsageOverviewRequest} ApplicationUsageOverviewRequest
         */
        ApplicationUsageOverviewRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ApplicationUsageOverviewRequest)
                return object;
            var message = new $root.api.ApplicationUsageOverviewRequest();
            if (object.Login != null)
                message.Login = String(object.Login);
            if (object.since != null)
                message.since = object.since >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an ApplicationUsageOverviewRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ApplicationUsageOverviewRequest
         * @static
         * @param {api.ApplicationUsageOverviewRequest} message ApplicationUsageOverviewRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApplicationUsageOverviewRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.Login = "";
                object.since = 0;
            }
            if (message.Login != null && message.hasOwnProperty("Login"))
                object.Login = message.Login;
            if (message.since != null && message.hasOwnProperty("since"))
                object.since = message.since;
            return object;
        };

        /**
         * Converts this ApplicationUsageOverviewRequest to JSON.
         * @function toJSON
         * @memberof api.ApplicationUsageOverviewRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApplicationUsageOverviewRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApplicationUsageOverviewRequest;
    })();

    api.ApplicationUsageOverviewResponse = (function() {

        /**
         * Properties of an ApplicationUsageOverviewResponse.
         * @memberof api
         * @interface IApplicationUsageOverviewResponse
         * @property {api.IApplicationUsageOverview|null} [overview] ApplicationUsageOverviewResponse overview
         */

        /**
         * Constructs a new ApplicationUsageOverviewResponse.
         * @memberof api
         * @classdesc Represents an ApplicationUsageOverviewResponse.
         * @implements IApplicationUsageOverviewResponse
         * @constructor
         * @param {api.IApplicationUsageOverviewResponse=} [properties] Properties to set
         */
        function ApplicationUsageOverviewResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApplicationUsageOverviewResponse overview.
         * @member {api.IApplicationUsageOverview|null|undefined} overview
         * @memberof api.ApplicationUsageOverviewResponse
         * @instance
         */
        ApplicationUsageOverviewResponse.prototype.overview = null;

        /**
         * Creates a new ApplicationUsageOverviewResponse instance using the specified properties.
         * @function create
         * @memberof api.ApplicationUsageOverviewResponse
         * @static
         * @param {api.IApplicationUsageOverviewResponse=} [properties] Properties to set
         * @returns {api.ApplicationUsageOverviewResponse} ApplicationUsageOverviewResponse instance
         */
        ApplicationUsageOverviewResponse.create = function create(properties) {
            return new ApplicationUsageOverviewResponse(properties);
        };

        /**
         * Encodes the specified ApplicationUsageOverviewResponse message. Does not implicitly {@link api.ApplicationUsageOverviewResponse.verify|verify} messages.
         * @function encode
         * @memberof api.ApplicationUsageOverviewResponse
         * @static
         * @param {api.IApplicationUsageOverviewResponse} message ApplicationUsageOverviewResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationUsageOverviewResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.overview != null && message.hasOwnProperty("overview"))
                $root.api.ApplicationUsageOverview.encode(message.overview, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ApplicationUsageOverviewResponse message, length delimited. Does not implicitly {@link api.ApplicationUsageOverviewResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ApplicationUsageOverviewResponse
         * @static
         * @param {api.IApplicationUsageOverviewResponse} message ApplicationUsageOverviewResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationUsageOverviewResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApplicationUsageOverviewResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.ApplicationUsageOverviewResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ApplicationUsageOverviewResponse} ApplicationUsageOverviewResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationUsageOverviewResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ApplicationUsageOverviewResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.overview = $root.api.ApplicationUsageOverview.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApplicationUsageOverviewResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ApplicationUsageOverviewResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ApplicationUsageOverviewResponse} ApplicationUsageOverviewResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationUsageOverviewResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApplicationUsageOverviewResponse message.
         * @function verify
         * @memberof api.ApplicationUsageOverviewResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApplicationUsageOverviewResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.overview != null && message.hasOwnProperty("overview")) {
                var error = $root.api.ApplicationUsageOverview.verify(message.overview);
                if (error)
                    return "overview." + error;
            }
            return null;
        };

        /**
         * Creates an ApplicationUsageOverviewResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ApplicationUsageOverviewResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ApplicationUsageOverviewResponse} ApplicationUsageOverviewResponse
         */
        ApplicationUsageOverviewResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ApplicationUsageOverviewResponse)
                return object;
            var message = new $root.api.ApplicationUsageOverviewResponse();
            if (object.overview != null) {
                if (typeof object.overview !== "object")
                    throw TypeError(".api.ApplicationUsageOverviewResponse.overview: object expected");
                message.overview = $root.api.ApplicationUsageOverview.fromObject(object.overview);
            }
            return message;
        };

        /**
         * Creates a plain object from an ApplicationUsageOverviewResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ApplicationUsageOverviewResponse
         * @static
         * @param {api.ApplicationUsageOverviewResponse} message ApplicationUsageOverviewResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApplicationUsageOverviewResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.overview = null;
            if (message.overview != null && message.hasOwnProperty("overview"))
                object.overview = $root.api.ApplicationUsageOverview.toObject(message.overview, options);
            return object;
        };

        /**
         * Converts this ApplicationUsageOverviewResponse to JSON.
         * @function toJSON
         * @memberof api.ApplicationUsageOverviewResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApplicationUsageOverviewResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApplicationUsageOverviewResponse;
    })();

    api.UnlockVersionsRequest = (function() {

        /**
         * Properties of an UnlockVersionsRequest.
         * @memberof api
         * @interface IUnlockVersionsRequest
         * @property {string|null} [login] UnlockVersionsRequest login
         * @property {Array.<api.UnlockVersionsRequest.IUnlockedVersion>|null} [unlockedVersions] UnlockVersionsRequest unlockedVersions
         */

        /**
         * Constructs a new UnlockVersionsRequest.
         * @memberof api
         * @classdesc Represents an UnlockVersionsRequest.
         * @implements IUnlockVersionsRequest
         * @constructor
         * @param {api.IUnlockVersionsRequest=} [properties] Properties to set
         */
        function UnlockVersionsRequest(properties) {
            this.unlockedVersions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UnlockVersionsRequest login.
         * @member {string} login
         * @memberof api.UnlockVersionsRequest
         * @instance
         */
        UnlockVersionsRequest.prototype.login = "";

        /**
         * UnlockVersionsRequest unlockedVersions.
         * @member {Array.<api.UnlockVersionsRequest.IUnlockedVersion>} unlockedVersions
         * @memberof api.UnlockVersionsRequest
         * @instance
         */
        UnlockVersionsRequest.prototype.unlockedVersions = $util.emptyArray;

        /**
         * Creates a new UnlockVersionsRequest instance using the specified properties.
         * @function create
         * @memberof api.UnlockVersionsRequest
         * @static
         * @param {api.IUnlockVersionsRequest=} [properties] Properties to set
         * @returns {api.UnlockVersionsRequest} UnlockVersionsRequest instance
         */
        UnlockVersionsRequest.create = function create(properties) {
            return new UnlockVersionsRequest(properties);
        };

        /**
         * Encodes the specified UnlockVersionsRequest message. Does not implicitly {@link api.UnlockVersionsRequest.verify|verify} messages.
         * @function encode
         * @memberof api.UnlockVersionsRequest
         * @static
         * @param {api.IUnlockVersionsRequest} message UnlockVersionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnlockVersionsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.unlockedVersions != null && message.unlockedVersions.length)
                for (var i = 0; i < message.unlockedVersions.length; ++i)
                    $root.api.UnlockVersionsRequest.UnlockedVersion.encode(message.unlockedVersions[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UnlockVersionsRequest message, length delimited. Does not implicitly {@link api.UnlockVersionsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.UnlockVersionsRequest
         * @static
         * @param {api.IUnlockVersionsRequest} message UnlockVersionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnlockVersionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnlockVersionsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.UnlockVersionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.UnlockVersionsRequest} UnlockVersionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnlockVersionsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.UnlockVersionsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    if (!(message.unlockedVersions && message.unlockedVersions.length))
                        message.unlockedVersions = [];
                    message.unlockedVersions.push($root.api.UnlockVersionsRequest.UnlockedVersion.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UnlockVersionsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.UnlockVersionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.UnlockVersionsRequest} UnlockVersionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnlockVersionsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnlockVersionsRequest message.
         * @function verify
         * @memberof api.UnlockVersionsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnlockVersionsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.unlockedVersions != null && message.hasOwnProperty("unlockedVersions")) {
                if (!Array.isArray(message.unlockedVersions))
                    return "unlockedVersions: array expected";
                for (var i = 0; i < message.unlockedVersions.length; ++i) {
                    var error = $root.api.UnlockVersionsRequest.UnlockedVersion.verify(message.unlockedVersions[i]);
                    if (error)
                        return "unlockedVersions." + error;
                }
            }
            return null;
        };

        /**
         * Creates an UnlockVersionsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.UnlockVersionsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.UnlockVersionsRequest} UnlockVersionsRequest
         */
        UnlockVersionsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.UnlockVersionsRequest)
                return object;
            var message = new $root.api.UnlockVersionsRequest();
            if (object.login != null)
                message.login = String(object.login);
            if (object.unlockedVersions) {
                if (!Array.isArray(object.unlockedVersions))
                    throw TypeError(".api.UnlockVersionsRequest.unlockedVersions: array expected");
                message.unlockedVersions = [];
                for (var i = 0; i < object.unlockedVersions.length; ++i) {
                    if (typeof object.unlockedVersions[i] !== "object")
                        throw TypeError(".api.UnlockVersionsRequest.unlockedVersions: object expected");
                    message.unlockedVersions[i] = $root.api.UnlockVersionsRequest.UnlockedVersion.fromObject(object.unlockedVersions[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an UnlockVersionsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.UnlockVersionsRequest
         * @static
         * @param {api.UnlockVersionsRequest} message UnlockVersionsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnlockVersionsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.unlockedVersions = [];
            if (options.defaults)
                object.login = "";
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.unlockedVersions && message.unlockedVersions.length) {
                object.unlockedVersions = [];
                for (var j = 0; j < message.unlockedVersions.length; ++j)
                    object.unlockedVersions[j] = $root.api.UnlockVersionsRequest.UnlockedVersion.toObject(message.unlockedVersions[j], options);
            }
            return object;
        };

        /**
         * Converts this UnlockVersionsRequest to JSON.
         * @function toJSON
         * @memberof api.UnlockVersionsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnlockVersionsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        UnlockVersionsRequest.UnlockedVersion = (function() {

            /**
             * Properties of an UnlockedVersion.
             * @memberof api.UnlockVersionsRequest
             * @interface IUnlockedVersion
             * @property {api.ISessionResolveChallengeRequest|null} [resolvedChallenge] UnlockedVersion resolvedChallenge
             * @property {api.IIdentityBackwardKey|null} [backward] UnlockedVersion backward
             */

            /**
             * Constructs a new UnlockedVersion.
             * @memberof api.UnlockVersionsRequest
             * @classdesc Represents an UnlockedVersion.
             * @implements IUnlockedVersion
             * @constructor
             * @param {api.UnlockVersionsRequest.IUnlockedVersion=} [properties] Properties to set
             */
            function UnlockedVersion(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UnlockedVersion resolvedChallenge.
             * @member {api.ISessionResolveChallengeRequest|null|undefined} resolvedChallenge
             * @memberof api.UnlockVersionsRequest.UnlockedVersion
             * @instance
             */
            UnlockedVersion.prototype.resolvedChallenge = null;

            /**
             * UnlockedVersion backward.
             * @member {api.IIdentityBackwardKey|null|undefined} backward
             * @memberof api.UnlockVersionsRequest.UnlockedVersion
             * @instance
             */
            UnlockedVersion.prototype.backward = null;

            /**
             * Creates a new UnlockedVersion instance using the specified properties.
             * @function create
             * @memberof api.UnlockVersionsRequest.UnlockedVersion
             * @static
             * @param {api.UnlockVersionsRequest.IUnlockedVersion=} [properties] Properties to set
             * @returns {api.UnlockVersionsRequest.UnlockedVersion} UnlockedVersion instance
             */
            UnlockedVersion.create = function create(properties) {
                return new UnlockedVersion(properties);
            };

            /**
             * Encodes the specified UnlockedVersion message. Does not implicitly {@link api.UnlockVersionsRequest.UnlockedVersion.verify|verify} messages.
             * @function encode
             * @memberof api.UnlockVersionsRequest.UnlockedVersion
             * @static
             * @param {api.UnlockVersionsRequest.IUnlockedVersion} message UnlockedVersion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnlockedVersion.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.resolvedChallenge != null && message.hasOwnProperty("resolvedChallenge"))
                    $root.api.SessionResolveChallengeRequest.encode(message.resolvedChallenge, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.backward != null && message.hasOwnProperty("backward"))
                    $root.api.IdentityBackwardKey.encode(message.backward, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified UnlockedVersion message, length delimited. Does not implicitly {@link api.UnlockVersionsRequest.UnlockedVersion.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.UnlockVersionsRequest.UnlockedVersion
             * @static
             * @param {api.UnlockVersionsRequest.IUnlockedVersion} message UnlockedVersion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnlockedVersion.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UnlockedVersion message from the specified reader or buffer.
             * @function decode
             * @memberof api.UnlockVersionsRequest.UnlockedVersion
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.UnlockVersionsRequest.UnlockedVersion} UnlockedVersion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnlockedVersion.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.UnlockVersionsRequest.UnlockedVersion();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.resolvedChallenge = $root.api.SessionResolveChallengeRequest.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.backward = $root.api.IdentityBackwardKey.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UnlockedVersion message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.UnlockVersionsRequest.UnlockedVersion
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.UnlockVersionsRequest.UnlockedVersion} UnlockedVersion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnlockedVersion.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UnlockedVersion message.
             * @function verify
             * @memberof api.UnlockVersionsRequest.UnlockedVersion
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UnlockedVersion.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.resolvedChallenge != null && message.hasOwnProperty("resolvedChallenge")) {
                    var error = $root.api.SessionResolveChallengeRequest.verify(message.resolvedChallenge);
                    if (error)
                        return "resolvedChallenge." + error;
                }
                if (message.backward != null && message.hasOwnProperty("backward")) {
                    var error = $root.api.IdentityBackwardKey.verify(message.backward);
                    if (error)
                        return "backward." + error;
                }
                return null;
            };

            /**
             * Creates an UnlockedVersion message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.UnlockVersionsRequest.UnlockedVersion
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.UnlockVersionsRequest.UnlockedVersion} UnlockedVersion
             */
            UnlockedVersion.fromObject = function fromObject(object) {
                if (object instanceof $root.api.UnlockVersionsRequest.UnlockedVersion)
                    return object;
                var message = new $root.api.UnlockVersionsRequest.UnlockedVersion();
                if (object.resolvedChallenge != null) {
                    if (typeof object.resolvedChallenge !== "object")
                        throw TypeError(".api.UnlockVersionsRequest.UnlockedVersion.resolvedChallenge: object expected");
                    message.resolvedChallenge = $root.api.SessionResolveChallengeRequest.fromObject(object.resolvedChallenge);
                }
                if (object.backward != null) {
                    if (typeof object.backward !== "object")
                        throw TypeError(".api.UnlockVersionsRequest.UnlockedVersion.backward: object expected");
                    message.backward = $root.api.IdentityBackwardKey.fromObject(object.backward);
                }
                return message;
            };

            /**
             * Creates a plain object from an UnlockedVersion message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.UnlockVersionsRequest.UnlockedVersion
             * @static
             * @param {api.UnlockVersionsRequest.UnlockedVersion} message UnlockedVersion
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UnlockedVersion.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.resolvedChallenge = null;
                    object.backward = null;
                }
                if (message.resolvedChallenge != null && message.hasOwnProperty("resolvedChallenge"))
                    object.resolvedChallenge = $root.api.SessionResolveChallengeRequest.toObject(message.resolvedChallenge, options);
                if (message.backward != null && message.hasOwnProperty("backward"))
                    object.backward = $root.api.IdentityBackwardKey.toObject(message.backward, options);
                return object;
            };

            /**
             * Converts this UnlockedVersion to JSON.
             * @function toJSON
             * @memberof api.UnlockVersionsRequest.UnlockedVersion
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UnlockedVersion.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UnlockedVersion;
        })();

        return UnlockVersionsRequest;
    })();

    api.SessionSetSecretRequest = (function() {

        /**
         * Properties of a SessionSetSecretRequest.
         * @memberof api
         * @interface ISessionSetSecretRequest
         * @property {Uint8Array|null} [masterSalt] SessionSetSecretRequest masterSalt
         * @property {api.IIdentityEncryptedKey|null} [sharingEncrypted] SessionSetSecretRequest sharingEncrypted
         */

        /**
         * Constructs a new SessionSetSecretRequest.
         * @memberof api
         * @classdesc Represents a SessionSetSecretRequest.
         * @implements ISessionSetSecretRequest
         * @constructor
         * @param {api.ISessionSetSecretRequest=} [properties] Properties to set
         */
        function SessionSetSecretRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SessionSetSecretRequest masterSalt.
         * @member {Uint8Array} masterSalt
         * @memberof api.SessionSetSecretRequest
         * @instance
         */
        SessionSetSecretRequest.prototype.masterSalt = $util.newBuffer([]);

        /**
         * SessionSetSecretRequest sharingEncrypted.
         * @member {api.IIdentityEncryptedKey|null|undefined} sharingEncrypted
         * @memberof api.SessionSetSecretRequest
         * @instance
         */
        SessionSetSecretRequest.prototype.sharingEncrypted = null;

        /**
         * Creates a new SessionSetSecretRequest instance using the specified properties.
         * @function create
         * @memberof api.SessionSetSecretRequest
         * @static
         * @param {api.ISessionSetSecretRequest=} [properties] Properties to set
         * @returns {api.SessionSetSecretRequest} SessionSetSecretRequest instance
         */
        SessionSetSecretRequest.create = function create(properties) {
            return new SessionSetSecretRequest(properties);
        };

        /**
         * Encodes the specified SessionSetSecretRequest message. Does not implicitly {@link api.SessionSetSecretRequest.verify|verify} messages.
         * @function encode
         * @memberof api.SessionSetSecretRequest
         * @static
         * @param {api.ISessionSetSecretRequest} message SessionSetSecretRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionSetSecretRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.masterSalt != null && message.hasOwnProperty("masterSalt"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.masterSalt);
            if (message.sharingEncrypted != null && message.hasOwnProperty("sharingEncrypted"))
                $root.api.IdentityEncryptedKey.encode(message.sharingEncrypted, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SessionSetSecretRequest message, length delimited. Does not implicitly {@link api.SessionSetSecretRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.SessionSetSecretRequest
         * @static
         * @param {api.ISessionSetSecretRequest} message SessionSetSecretRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionSetSecretRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SessionSetSecretRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.SessionSetSecretRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.SessionSetSecretRequest} SessionSetSecretRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionSetSecretRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.SessionSetSecretRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.masterSalt = reader.bytes();
                    break;
                case 2:
                    message.sharingEncrypted = $root.api.IdentityEncryptedKey.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SessionSetSecretRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.SessionSetSecretRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.SessionSetSecretRequest} SessionSetSecretRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionSetSecretRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SessionSetSecretRequest message.
         * @function verify
         * @memberof api.SessionSetSecretRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SessionSetSecretRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.masterSalt != null && message.hasOwnProperty("masterSalt"))
                if (!(message.masterSalt && typeof message.masterSalt.length === "number" || $util.isString(message.masterSalt)))
                    return "masterSalt: buffer expected";
            if (message.sharingEncrypted != null && message.hasOwnProperty("sharingEncrypted")) {
                var error = $root.api.IdentityEncryptedKey.verify(message.sharingEncrypted);
                if (error)
                    return "sharingEncrypted." + error;
            }
            return null;
        };

        /**
         * Creates a SessionSetSecretRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.SessionSetSecretRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.SessionSetSecretRequest} SessionSetSecretRequest
         */
        SessionSetSecretRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.SessionSetSecretRequest)
                return object;
            var message = new $root.api.SessionSetSecretRequest();
            if (object.masterSalt != null)
                if (typeof object.masterSalt === "string")
                    $util.base64.decode(object.masterSalt, message.masterSalt = $util.newBuffer($util.base64.length(object.masterSalt)), 0);
                else if (object.masterSalt.length)
                    message.masterSalt = object.masterSalt;
            if (object.sharingEncrypted != null) {
                if (typeof object.sharingEncrypted !== "object")
                    throw TypeError(".api.SessionSetSecretRequest.sharingEncrypted: object expected");
                message.sharingEncrypted = $root.api.IdentityEncryptedKey.fromObject(object.sharingEncrypted);
            }
            return message;
        };

        /**
         * Creates a plain object from a SessionSetSecretRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.SessionSetSecretRequest
         * @static
         * @param {api.SessionSetSecretRequest} message SessionSetSecretRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionSetSecretRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.masterSalt = "";
                else {
                    object.masterSalt = [];
                    if (options.bytes !== Array)
                        object.masterSalt = $util.newBuffer(object.masterSalt);
                }
                object.sharingEncrypted = null;
            }
            if (message.masterSalt != null && message.hasOwnProperty("masterSalt"))
                object.masterSalt = options.bytes === String ? $util.base64.encode(message.masterSalt, 0, message.masterSalt.length) : options.bytes === Array ? Array.prototype.slice.call(message.masterSalt) : message.masterSalt;
            if (message.sharingEncrypted != null && message.hasOwnProperty("sharingEncrypted"))
                object.sharingEncrypted = $root.api.IdentityEncryptedKey.toObject(message.sharingEncrypted, options);
            return object;
        };

        /**
         * Converts this SessionSetSecretRequest to JSON.
         * @function toJSON
         * @memberof api.SessionSetSecretRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionSetSecretRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SessionSetSecretRequest;
    })();

    api.SessionUnStaleResponse = (function() {

        /**
         * Properties of a SessionUnStaleResponse.
         * @memberof api
         * @interface ISessionUnStaleResponse
         * @property {api.IIdentityEncryption|null} [encryption] SessionUnStaleResponse encryption
         * @property {api.IIdentityPublicKey|null} [creator] SessionUnStaleResponse creator
         */

        /**
         * Constructs a new SessionUnStaleResponse.
         * @memberof api
         * @classdesc Represents a SessionUnStaleResponse.
         * @implements ISessionUnStaleResponse
         * @constructor
         * @param {api.ISessionUnStaleResponse=} [properties] Properties to set
         */
        function SessionUnStaleResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SessionUnStaleResponse encryption.
         * @member {api.IIdentityEncryption|null|undefined} encryption
         * @memberof api.SessionUnStaleResponse
         * @instance
         */
        SessionUnStaleResponse.prototype.encryption = null;

        /**
         * SessionUnStaleResponse creator.
         * @member {api.IIdentityPublicKey|null|undefined} creator
         * @memberof api.SessionUnStaleResponse
         * @instance
         */
        SessionUnStaleResponse.prototype.creator = null;

        /**
         * Creates a new SessionUnStaleResponse instance using the specified properties.
         * @function create
         * @memberof api.SessionUnStaleResponse
         * @static
         * @param {api.ISessionUnStaleResponse=} [properties] Properties to set
         * @returns {api.SessionUnStaleResponse} SessionUnStaleResponse instance
         */
        SessionUnStaleResponse.create = function create(properties) {
            return new SessionUnStaleResponse(properties);
        };

        /**
         * Encodes the specified SessionUnStaleResponse message. Does not implicitly {@link api.SessionUnStaleResponse.verify|verify} messages.
         * @function encode
         * @memberof api.SessionUnStaleResponse
         * @static
         * @param {api.ISessionUnStaleResponse} message SessionUnStaleResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionUnStaleResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.api.IdentityEncryption.encode(message.encryption, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.creator != null && message.hasOwnProperty("creator"))
                $root.api.IdentityPublicKey.encode(message.creator, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SessionUnStaleResponse message, length delimited. Does not implicitly {@link api.SessionUnStaleResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.SessionUnStaleResponse
         * @static
         * @param {api.ISessionUnStaleResponse} message SessionUnStaleResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionUnStaleResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SessionUnStaleResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.SessionUnStaleResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.SessionUnStaleResponse} SessionUnStaleResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionUnStaleResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.SessionUnStaleResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryption = $root.api.IdentityEncryption.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.creator = $root.api.IdentityPublicKey.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SessionUnStaleResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.SessionUnStaleResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.SessionUnStaleResponse} SessionUnStaleResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionUnStaleResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SessionUnStaleResponse message.
         * @function verify
         * @memberof api.SessionUnStaleResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SessionUnStaleResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.api.IdentityEncryption.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            if (message.creator != null && message.hasOwnProperty("creator")) {
                var error = $root.api.IdentityPublicKey.verify(message.creator);
                if (error)
                    return "creator." + error;
            }
            return null;
        };

        /**
         * Creates a SessionUnStaleResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.SessionUnStaleResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.SessionUnStaleResponse} SessionUnStaleResponse
         */
        SessionUnStaleResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.SessionUnStaleResponse)
                return object;
            var message = new $root.api.SessionUnStaleResponse();
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".api.SessionUnStaleResponse.encryption: object expected");
                message.encryption = $root.api.IdentityEncryption.fromObject(object.encryption);
            }
            if (object.creator != null) {
                if (typeof object.creator !== "object")
                    throw TypeError(".api.SessionUnStaleResponse.creator: object expected");
                message.creator = $root.api.IdentityPublicKey.fromObject(object.creator);
            }
            return message;
        };

        /**
         * Creates a plain object from a SessionUnStaleResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.SessionUnStaleResponse
         * @static
         * @param {api.SessionUnStaleResponse} message SessionUnStaleResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionUnStaleResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.encryption = null;
                object.creator = null;
            }
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.api.IdentityEncryption.toObject(message.encryption, options);
            if (message.creator != null && message.hasOwnProperty("creator"))
                object.creator = $root.api.IdentityPublicKey.toObject(message.creator, options);
            return object;
        };

        /**
         * Converts this SessionUnStaleResponse to JSON.
         * @function toJSON
         * @memberof api.SessionUnStaleResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionUnStaleResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SessionUnStaleResponse;
    })();

    api.SessionAuthenticateResponse = (function() {

        /**
         * Properties of a SessionAuthenticateResponse.
         * @memberof api
         * @interface ISessionAuthenticateResponse
         * @property {string|null} [ownerLogin] SessionAuthenticateResponse ownerLogin
         * @property {string|null} [assumeLogin] SessionAuthenticateResponse assumeLogin
         * @property {api.IdentityAccessKeyKind|null} [assumeKind] SessionAuthenticateResponse assumeKind
         */

        /**
         * Constructs a new SessionAuthenticateResponse.
         * @memberof api
         * @classdesc Represents a SessionAuthenticateResponse.
         * @implements ISessionAuthenticateResponse
         * @constructor
         * @param {api.ISessionAuthenticateResponse=} [properties] Properties to set
         */
        function SessionAuthenticateResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SessionAuthenticateResponse ownerLogin.
         * @member {string} ownerLogin
         * @memberof api.SessionAuthenticateResponse
         * @instance
         */
        SessionAuthenticateResponse.prototype.ownerLogin = "";

        /**
         * SessionAuthenticateResponse assumeLogin.
         * @member {string} assumeLogin
         * @memberof api.SessionAuthenticateResponse
         * @instance
         */
        SessionAuthenticateResponse.prototype.assumeLogin = "";

        /**
         * SessionAuthenticateResponse assumeKind.
         * @member {api.IdentityAccessKeyKind} assumeKind
         * @memberof api.SessionAuthenticateResponse
         * @instance
         */
        SessionAuthenticateResponse.prototype.assumeKind = 0;

        /**
         * Creates a new SessionAuthenticateResponse instance using the specified properties.
         * @function create
         * @memberof api.SessionAuthenticateResponse
         * @static
         * @param {api.ISessionAuthenticateResponse=} [properties] Properties to set
         * @returns {api.SessionAuthenticateResponse} SessionAuthenticateResponse instance
         */
        SessionAuthenticateResponse.create = function create(properties) {
            return new SessionAuthenticateResponse(properties);
        };

        /**
         * Encodes the specified SessionAuthenticateResponse message. Does not implicitly {@link api.SessionAuthenticateResponse.verify|verify} messages.
         * @function encode
         * @memberof api.SessionAuthenticateResponse
         * @static
         * @param {api.ISessionAuthenticateResponse} message SessionAuthenticateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionAuthenticateResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerLogin != null && message.hasOwnProperty("ownerLogin"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.ownerLogin);
            if (message.assumeLogin != null && message.hasOwnProperty("assumeLogin"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.assumeLogin);
            if (message.assumeKind != null && message.hasOwnProperty("assumeKind"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.assumeKind);
            return writer;
        };

        /**
         * Encodes the specified SessionAuthenticateResponse message, length delimited. Does not implicitly {@link api.SessionAuthenticateResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.SessionAuthenticateResponse
         * @static
         * @param {api.ISessionAuthenticateResponse} message SessionAuthenticateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionAuthenticateResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SessionAuthenticateResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.SessionAuthenticateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.SessionAuthenticateResponse} SessionAuthenticateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionAuthenticateResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.SessionAuthenticateResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerLogin = reader.string();
                    break;
                case 2:
                    message.assumeLogin = reader.string();
                    break;
                case 3:
                    message.assumeKind = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SessionAuthenticateResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.SessionAuthenticateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.SessionAuthenticateResponse} SessionAuthenticateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionAuthenticateResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SessionAuthenticateResponse message.
         * @function verify
         * @memberof api.SessionAuthenticateResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SessionAuthenticateResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerLogin != null && message.hasOwnProperty("ownerLogin"))
                if (!$util.isString(message.ownerLogin))
                    return "ownerLogin: string expected";
            if (message.assumeLogin != null && message.hasOwnProperty("assumeLogin"))
                if (!$util.isString(message.assumeLogin))
                    return "assumeLogin: string expected";
            if (message.assumeKind != null && message.hasOwnProperty("assumeKind"))
                switch (message.assumeKind) {
                default:
                    return "assumeKind: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a SessionAuthenticateResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.SessionAuthenticateResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.SessionAuthenticateResponse} SessionAuthenticateResponse
         */
        SessionAuthenticateResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.SessionAuthenticateResponse)
                return object;
            var message = new $root.api.SessionAuthenticateResponse();
            if (object.ownerLogin != null)
                message.ownerLogin = String(object.ownerLogin);
            if (object.assumeLogin != null)
                message.assumeLogin = String(object.assumeLogin);
            switch (object.assumeKind) {
            case "READ":
            case 0:
                message.assumeKind = 0;
                break;
            case "WRITE":
            case 1:
                message.assumeKind = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a SessionAuthenticateResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.SessionAuthenticateResponse
         * @static
         * @param {api.SessionAuthenticateResponse} message SessionAuthenticateResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionAuthenticateResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.ownerLogin = "";
                object.assumeLogin = "";
                object.assumeKind = options.enums === String ? "READ" : 0;
            }
            if (message.ownerLogin != null && message.hasOwnProperty("ownerLogin"))
                object.ownerLogin = message.ownerLogin;
            if (message.assumeLogin != null && message.hasOwnProperty("assumeLogin"))
                object.assumeLogin = message.assumeLogin;
            if (message.assumeKind != null && message.hasOwnProperty("assumeKind"))
                object.assumeKind = options.enums === String ? $root.api.IdentityAccessKeyKind[message.assumeKind] : message.assumeKind;
            return object;
        };

        /**
         * Converts this SessionAuthenticateResponse to JSON.
         * @function toJSON
         * @memberof api.SessionAuthenticateResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionAuthenticateResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SessionAuthenticateResponse;
    })();

    /**
     * ResourceType enum.
     * @name api.ResourceType
     * @enum {string}
     * @property {number} ANONYMOUS=0 ANONYMOUS value
     * @property {number} SES=1 SES value
     */
    api.ResourceType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ANONYMOUS"] = 0;
        values[valuesById[1] = "SES"] = 1;
        return values;
    })();

    /**
     * ResourceAccessReason enum.
     * @name api.ResourceAccessReason
     * @enum {string}
     * @property {number} UNKOWN=0 UNKOWN value
     * @property {number} READ_ACCESS=1 READ_ACCESS value
     * @property {number} SHARE_ACCESS=2 SHARE_ACCESS value
     * @property {number} CUSTOM_ACCESS=3 CUSTOM_ACCESS value
     */
    api.ResourceAccessReason = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKOWN"] = 0;
        values[valuesById[1] = "READ_ACCESS"] = 1;
        values[valuesById[2] = "SHARE_ACCESS"] = 2;
        values[valuesById[3] = "CUSTOM_ACCESS"] = 3;
        return values;
    })();

    api.Resource = (function() {

        /**
         * Properties of a Resource.
         * @memberof api
         * @interface IResource
         * @property {number|Long|null} [id] Resource id
         * @property {string|null} [kind] Resource kind
         * @property {Uint8Array|null} [publicKey] Resource publicKey
         * @property {Uint8Array|null} [nonce] Resource nonce
         * @property {number|Long|null} [created] Resource created
         * @property {Uint8Array|null} [payload] Resource payload
         * @property {api.ResourceType|null} [type] Resource type
         */

        /**
         * Constructs a new Resource.
         * @memberof api
         * @classdesc Represents a Resource.
         * @implements IResource
         * @constructor
         * @param {api.IResource=} [properties] Properties to set
         */
        function Resource(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Resource id.
         * @member {number|Long} id
         * @memberof api.Resource
         * @instance
         */
        Resource.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Resource kind.
         * @member {string} kind
         * @memberof api.Resource
         * @instance
         */
        Resource.prototype.kind = "";

        /**
         * Resource publicKey.
         * @member {Uint8Array} publicKey
         * @memberof api.Resource
         * @instance
         */
        Resource.prototype.publicKey = $util.newBuffer([]);

        /**
         * Resource nonce.
         * @member {Uint8Array} nonce
         * @memberof api.Resource
         * @instance
         */
        Resource.prototype.nonce = $util.newBuffer([]);

        /**
         * Resource created.
         * @member {number|Long} created
         * @memberof api.Resource
         * @instance
         */
        Resource.prototype.created = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Resource payload.
         * @member {Uint8Array} payload
         * @memberof api.Resource
         * @instance
         */
        Resource.prototype.payload = $util.newBuffer([]);

        /**
         * Resource type.
         * @member {api.ResourceType} type
         * @memberof api.Resource
         * @instance
         */
        Resource.prototype.type = 0;

        /**
         * Creates a new Resource instance using the specified properties.
         * @function create
         * @memberof api.Resource
         * @static
         * @param {api.IResource=} [properties] Properties to set
         * @returns {api.Resource} Resource instance
         */
        Resource.create = function create(properties) {
            return new Resource(properties);
        };

        /**
         * Encodes the specified Resource message. Does not implicitly {@link api.Resource.verify|verify} messages.
         * @function encode
         * @memberof api.Resource
         * @static
         * @param {api.IResource} message Resource message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Resource.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            if (message.kind != null && message.hasOwnProperty("kind"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.kind);
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.publicKey);
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.nonce);
            if (message.created != null && message.hasOwnProperty("created"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.created);
            if (message.payload != null && message.hasOwnProperty("payload"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.payload);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified Resource message, length delimited. Does not implicitly {@link api.Resource.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.Resource
         * @static
         * @param {api.IResource} message Resource message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Resource.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Resource message from the specified reader or buffer.
         * @function decode
         * @memberof api.Resource
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.Resource} Resource
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Resource.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Resource();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                case 2:
                    message.kind = reader.string();
                    break;
                case 3:
                    message.publicKey = reader.bytes();
                    break;
                case 4:
                    message.nonce = reader.bytes();
                    break;
                case 5:
                    message.created = reader.int64();
                    break;
                case 6:
                    message.payload = reader.bytes();
                    break;
                case 7:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Resource message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.Resource
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.Resource} Resource
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Resource.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Resource message.
         * @function verify
         * @memberof api.Resource
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Resource.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.kind != null && message.hasOwnProperty("kind"))
                if (!$util.isString(message.kind))
                    return "kind: string expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                    return "nonce: buffer expected";
            if (message.created != null && message.hasOwnProperty("created"))
                if (!$util.isInteger(message.created) && !(message.created && $util.isInteger(message.created.low) && $util.isInteger(message.created.high)))
                    return "created: integer|Long expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a Resource message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.Resource
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.Resource} Resource
         */
        Resource.fromObject = function fromObject(object) {
            if (object instanceof $root.api.Resource)
                return object;
            var message = new $root.api.Resource();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            if (object.kind != null)
                message.kind = String(object.kind);
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.nonce != null)
                if (typeof object.nonce === "string")
                    $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                else if (object.nonce.length)
                    message.nonce = object.nonce;
            if (object.created != null)
                if ($util.Long)
                    (message.created = $util.Long.fromValue(object.created)).unsigned = false;
                else if (typeof object.created === "string")
                    message.created = parseInt(object.created, 10);
                else if (typeof object.created === "number")
                    message.created = object.created;
                else if (typeof object.created === "object")
                    message.created = new $util.LongBits(object.created.low >>> 0, object.created.high >>> 0).toNumber();
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            switch (object.type) {
            case "ANONYMOUS":
            case 0:
                message.type = 0;
                break;
            case "SES":
            case 1:
                message.type = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Resource message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.Resource
         * @static
         * @param {api.Resource} message Resource
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Resource.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.kind = "";
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                if (options.bytes === String)
                    object.nonce = "";
                else {
                    object.nonce = [];
                    if (options.bytes !== Array)
                        object.nonce = $util.newBuffer(object.nonce);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.created = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.created = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
                object.type = options.enums === String ? "ANONYMOUS" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            if (message.kind != null && message.hasOwnProperty("kind"))
                object.kind = message.kind;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
            if (message.created != null && message.hasOwnProperty("created"))
                if (typeof message.created === "number")
                    object.created = options.longs === String ? String(message.created) : message.created;
                else
                    object.created = options.longs === String ? $util.Long.prototype.toString.call(message.created) : options.longs === Number ? new $util.LongBits(message.created.low >>> 0, message.created.high >>> 0).toNumber() : message.created;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.api.ResourceType[message.type] : message.type;
            return object;
        };

        /**
         * Converts this Resource to JSON.
         * @function toJSON
         * @memberof api.Resource
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Resource.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Resource;
    })();

    api.ResourceGetResponse = (function() {

        /**
         * Properties of a ResourceGetResponse.
         * @memberof api
         * @interface IResourceGetResponse
         * @property {api.IResource|null} [resource] ResourceGetResponse resource
         * @property {api.IIdentityKeyID|null} [creator] ResourceGetResponse creator
         * @property {Array.<api.ICipher>|null} [encryptedKey] ResourceGetResponse encryptedKey
         */

        /**
         * Constructs a new ResourceGetResponse.
         * @memberof api
         * @classdesc Represents a ResourceGetResponse.
         * @implements IResourceGetResponse
         * @constructor
         * @param {api.IResourceGetResponse=} [properties] Properties to set
         */
        function ResourceGetResponse(properties) {
            this.encryptedKey = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceGetResponse resource.
         * @member {api.IResource|null|undefined} resource
         * @memberof api.ResourceGetResponse
         * @instance
         */
        ResourceGetResponse.prototype.resource = null;

        /**
         * ResourceGetResponse creator.
         * @member {api.IIdentityKeyID|null|undefined} creator
         * @memberof api.ResourceGetResponse
         * @instance
         */
        ResourceGetResponse.prototype.creator = null;

        /**
         * ResourceGetResponse encryptedKey.
         * @member {Array.<api.ICipher>} encryptedKey
         * @memberof api.ResourceGetResponse
         * @instance
         */
        ResourceGetResponse.prototype.encryptedKey = $util.emptyArray;

        /**
         * Creates a new ResourceGetResponse instance using the specified properties.
         * @function create
         * @memberof api.ResourceGetResponse
         * @static
         * @param {api.IResourceGetResponse=} [properties] Properties to set
         * @returns {api.ResourceGetResponse} ResourceGetResponse instance
         */
        ResourceGetResponse.create = function create(properties) {
            return new ResourceGetResponse(properties);
        };

        /**
         * Encodes the specified ResourceGetResponse message. Does not implicitly {@link api.ResourceGetResponse.verify|verify} messages.
         * @function encode
         * @memberof api.ResourceGetResponse
         * @static
         * @param {api.IResourceGetResponse} message ResourceGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resource != null && message.hasOwnProperty("resource"))
                $root.api.Resource.encode(message.resource, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.creator != null && message.hasOwnProperty("creator"))
                $root.api.IdentityKeyID.encode(message.creator, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.encryptedKey != null && message.encryptedKey.length)
                for (var i = 0; i < message.encryptedKey.length; ++i)
                    $root.api.Cipher.encode(message.encryptedKey[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResourceGetResponse message, length delimited. Does not implicitly {@link api.ResourceGetResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourceGetResponse
         * @static
         * @param {api.IResourceGetResponse} message ResourceGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceGetResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourceGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourceGetResponse} ResourceGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourceGetResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.resource = $root.api.Resource.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.creator = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                case 3:
                    if (!(message.encryptedKey && message.encryptedKey.length))
                        message.encryptedKey = [];
                    message.encryptedKey.push($root.api.Cipher.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceGetResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourceGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourceGetResponse} ResourceGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceGetResponse message.
         * @function verify
         * @memberof api.ResourceGetResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceGetResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.resource != null && message.hasOwnProperty("resource")) {
                var error = $root.api.Resource.verify(message.resource);
                if (error)
                    return "resource." + error;
            }
            if (message.creator != null && message.hasOwnProperty("creator")) {
                var error = $root.api.IdentityKeyID.verify(message.creator);
                if (error)
                    return "creator." + error;
            }
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey")) {
                if (!Array.isArray(message.encryptedKey))
                    return "encryptedKey: array expected";
                for (var i = 0; i < message.encryptedKey.length; ++i) {
                    var error = $root.api.Cipher.verify(message.encryptedKey[i]);
                    if (error)
                        return "encryptedKey." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ResourceGetResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourceGetResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourceGetResponse} ResourceGetResponse
         */
        ResourceGetResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourceGetResponse)
                return object;
            var message = new $root.api.ResourceGetResponse();
            if (object.resource != null) {
                if (typeof object.resource !== "object")
                    throw TypeError(".api.ResourceGetResponse.resource: object expected");
                message.resource = $root.api.Resource.fromObject(object.resource);
            }
            if (object.creator != null) {
                if (typeof object.creator !== "object")
                    throw TypeError(".api.ResourceGetResponse.creator: object expected");
                message.creator = $root.api.IdentityKeyID.fromObject(object.creator);
            }
            if (object.encryptedKey) {
                if (!Array.isArray(object.encryptedKey))
                    throw TypeError(".api.ResourceGetResponse.encryptedKey: array expected");
                message.encryptedKey = [];
                for (var i = 0; i < object.encryptedKey.length; ++i) {
                    if (typeof object.encryptedKey[i] !== "object")
                        throw TypeError(".api.ResourceGetResponse.encryptedKey: object expected");
                    message.encryptedKey[i] = $root.api.Cipher.fromObject(object.encryptedKey[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ResourceGetResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourceGetResponse
         * @static
         * @param {api.ResourceGetResponse} message ResourceGetResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceGetResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.encryptedKey = [];
            if (options.defaults) {
                object.resource = null;
                object.creator = null;
            }
            if (message.resource != null && message.hasOwnProperty("resource"))
                object.resource = $root.api.Resource.toObject(message.resource, options);
            if (message.creator != null && message.hasOwnProperty("creator"))
                object.creator = $root.api.IdentityKeyID.toObject(message.creator, options);
            if (message.encryptedKey && message.encryptedKey.length) {
                object.encryptedKey = [];
                for (var j = 0; j < message.encryptedKey.length; ++j)
                    object.encryptedKey[j] = $root.api.Cipher.toObject(message.encryptedKey[j], options);
            }
            return object;
        };

        /**
         * Converts this ResourceGetResponse to JSON.
         * @function toJSON
         * @memberof api.ResourceGetResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceGetResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceGetResponse;
    })();

    api.ResourceWithKey = (function() {

        /**
         * Properties of a ResourceWithKey.
         * @memberof api
         * @interface IResourceWithKey
         * @property {api.IResource|null} [resource] ResourceWithKey resource
         * @property {api.IIdentityKeyID|null} [owner] ResourceWithKey owner
         * @property {api.IIdentityKeyID|null} [creator] ResourceWithKey creator
         * @property {api.ICipher|null} [encryptedKey] ResourceWithKey encryptedKey
         */

        /**
         * Constructs a new ResourceWithKey.
         * @memberof api
         * @classdesc Represents a ResourceWithKey.
         * @implements IResourceWithKey
         * @constructor
         * @param {api.IResourceWithKey=} [properties] Properties to set
         */
        function ResourceWithKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceWithKey resource.
         * @member {api.IResource|null|undefined} resource
         * @memberof api.ResourceWithKey
         * @instance
         */
        ResourceWithKey.prototype.resource = null;

        /**
         * ResourceWithKey owner.
         * @member {api.IIdentityKeyID|null|undefined} owner
         * @memberof api.ResourceWithKey
         * @instance
         */
        ResourceWithKey.prototype.owner = null;

        /**
         * ResourceWithKey creator.
         * @member {api.IIdentityKeyID|null|undefined} creator
         * @memberof api.ResourceWithKey
         * @instance
         */
        ResourceWithKey.prototype.creator = null;

        /**
         * ResourceWithKey encryptedKey.
         * @member {api.ICipher|null|undefined} encryptedKey
         * @memberof api.ResourceWithKey
         * @instance
         */
        ResourceWithKey.prototype.encryptedKey = null;

        /**
         * Creates a new ResourceWithKey instance using the specified properties.
         * @function create
         * @memberof api.ResourceWithKey
         * @static
         * @param {api.IResourceWithKey=} [properties] Properties to set
         * @returns {api.ResourceWithKey} ResourceWithKey instance
         */
        ResourceWithKey.create = function create(properties) {
            return new ResourceWithKey(properties);
        };

        /**
         * Encodes the specified ResourceWithKey message. Does not implicitly {@link api.ResourceWithKey.verify|verify} messages.
         * @function encode
         * @memberof api.ResourceWithKey
         * @static
         * @param {api.IResourceWithKey} message ResourceWithKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceWithKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resource != null && message.hasOwnProperty("resource"))
                $root.api.Resource.encode(message.resource, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.owner != null && message.hasOwnProperty("owner"))
                $root.api.IdentityKeyID.encode(message.owner, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.creator != null && message.hasOwnProperty("creator"))
                $root.api.IdentityKeyID.encode(message.creator, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                $root.api.Cipher.encode(message.encryptedKey, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResourceWithKey message, length delimited. Does not implicitly {@link api.ResourceWithKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourceWithKey
         * @static
         * @param {api.IResourceWithKey} message ResourceWithKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceWithKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceWithKey message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourceWithKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourceWithKey} ResourceWithKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceWithKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourceWithKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.resource = $root.api.Resource.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.owner = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.creator = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.encryptedKey = $root.api.Cipher.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceWithKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourceWithKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourceWithKey} ResourceWithKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceWithKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceWithKey message.
         * @function verify
         * @memberof api.ResourceWithKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceWithKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.resource != null && message.hasOwnProperty("resource")) {
                var error = $root.api.Resource.verify(message.resource);
                if (error)
                    return "resource." + error;
            }
            if (message.owner != null && message.hasOwnProperty("owner")) {
                var error = $root.api.IdentityKeyID.verify(message.owner);
                if (error)
                    return "owner." + error;
            }
            if (message.creator != null && message.hasOwnProperty("creator")) {
                var error = $root.api.IdentityKeyID.verify(message.creator);
                if (error)
                    return "creator." + error;
            }
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey")) {
                var error = $root.api.Cipher.verify(message.encryptedKey);
                if (error)
                    return "encryptedKey." + error;
            }
            return null;
        };

        /**
         * Creates a ResourceWithKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourceWithKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourceWithKey} ResourceWithKey
         */
        ResourceWithKey.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourceWithKey)
                return object;
            var message = new $root.api.ResourceWithKey();
            if (object.resource != null) {
                if (typeof object.resource !== "object")
                    throw TypeError(".api.ResourceWithKey.resource: object expected");
                message.resource = $root.api.Resource.fromObject(object.resource);
            }
            if (object.owner != null) {
                if (typeof object.owner !== "object")
                    throw TypeError(".api.ResourceWithKey.owner: object expected");
                message.owner = $root.api.IdentityKeyID.fromObject(object.owner);
            }
            if (object.creator != null) {
                if (typeof object.creator !== "object")
                    throw TypeError(".api.ResourceWithKey.creator: object expected");
                message.creator = $root.api.IdentityKeyID.fromObject(object.creator);
            }
            if (object.encryptedKey != null) {
                if (typeof object.encryptedKey !== "object")
                    throw TypeError(".api.ResourceWithKey.encryptedKey: object expected");
                message.encryptedKey = $root.api.Cipher.fromObject(object.encryptedKey);
            }
            return message;
        };

        /**
         * Creates a plain object from a ResourceWithKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourceWithKey
         * @static
         * @param {api.ResourceWithKey} message ResourceWithKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceWithKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.resource = null;
                object.owner = null;
                object.creator = null;
                object.encryptedKey = null;
            }
            if (message.resource != null && message.hasOwnProperty("resource"))
                object.resource = $root.api.Resource.toObject(message.resource, options);
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = $root.api.IdentityKeyID.toObject(message.owner, options);
            if (message.creator != null && message.hasOwnProperty("creator"))
                object.creator = $root.api.IdentityKeyID.toObject(message.creator, options);
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                object.encryptedKey = $root.api.Cipher.toObject(message.encryptedKey, options);
            return object;
        };

        /**
         * Converts this ResourceWithKey to JSON.
         * @function toJSON
         * @memberof api.ResourceWithKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceWithKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceWithKey;
    })();

    api.ResourceGetKeyResponse = (function() {

        /**
         * Properties of a ResourceGetKeyResponse.
         * @memberof api
         * @interface IResourceGetKeyResponse
         * @property {Array.<api.ICipher>|null} [encryptedKey] ResourceGetKeyResponse encryptedKey
         * @property {api.ResourceType|null} [type] ResourceGetKeyResponse type
         */

        /**
         * Constructs a new ResourceGetKeyResponse.
         * @memberof api
         * @classdesc Represents a ResourceGetKeyResponse.
         * @implements IResourceGetKeyResponse
         * @constructor
         * @param {api.IResourceGetKeyResponse=} [properties] Properties to set
         */
        function ResourceGetKeyResponse(properties) {
            this.encryptedKey = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceGetKeyResponse encryptedKey.
         * @member {Array.<api.ICipher>} encryptedKey
         * @memberof api.ResourceGetKeyResponse
         * @instance
         */
        ResourceGetKeyResponse.prototype.encryptedKey = $util.emptyArray;

        /**
         * ResourceGetKeyResponse type.
         * @member {api.ResourceType} type
         * @memberof api.ResourceGetKeyResponse
         * @instance
         */
        ResourceGetKeyResponse.prototype.type = 0;

        /**
         * Creates a new ResourceGetKeyResponse instance using the specified properties.
         * @function create
         * @memberof api.ResourceGetKeyResponse
         * @static
         * @param {api.IResourceGetKeyResponse=} [properties] Properties to set
         * @returns {api.ResourceGetKeyResponse} ResourceGetKeyResponse instance
         */
        ResourceGetKeyResponse.create = function create(properties) {
            return new ResourceGetKeyResponse(properties);
        };

        /**
         * Encodes the specified ResourceGetKeyResponse message. Does not implicitly {@link api.ResourceGetKeyResponse.verify|verify} messages.
         * @function encode
         * @memberof api.ResourceGetKeyResponse
         * @static
         * @param {api.IResourceGetKeyResponse} message ResourceGetKeyResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetKeyResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedKey != null && message.encryptedKey.length)
                for (var i = 0; i < message.encryptedKey.length; ++i)
                    $root.api.Cipher.encode(message.encryptedKey[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified ResourceGetKeyResponse message, length delimited. Does not implicitly {@link api.ResourceGetKeyResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourceGetKeyResponse
         * @static
         * @param {api.IResourceGetKeyResponse} message ResourceGetKeyResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetKeyResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceGetKeyResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourceGetKeyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourceGetKeyResponse} ResourceGetKeyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetKeyResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourceGetKeyResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.encryptedKey && message.encryptedKey.length))
                        message.encryptedKey = [];
                    message.encryptedKey.push($root.api.Cipher.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceGetKeyResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourceGetKeyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourceGetKeyResponse} ResourceGetKeyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetKeyResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceGetKeyResponse message.
         * @function verify
         * @memberof api.ResourceGetKeyResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceGetKeyResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey")) {
                if (!Array.isArray(message.encryptedKey))
                    return "encryptedKey: array expected";
                for (var i = 0; i < message.encryptedKey.length; ++i) {
                    var error = $root.api.Cipher.verify(message.encryptedKey[i]);
                    if (error)
                        return "encryptedKey." + error;
                }
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a ResourceGetKeyResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourceGetKeyResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourceGetKeyResponse} ResourceGetKeyResponse
         */
        ResourceGetKeyResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourceGetKeyResponse)
                return object;
            var message = new $root.api.ResourceGetKeyResponse();
            if (object.encryptedKey) {
                if (!Array.isArray(object.encryptedKey))
                    throw TypeError(".api.ResourceGetKeyResponse.encryptedKey: array expected");
                message.encryptedKey = [];
                for (var i = 0; i < object.encryptedKey.length; ++i) {
                    if (typeof object.encryptedKey[i] !== "object")
                        throw TypeError(".api.ResourceGetKeyResponse.encryptedKey: object expected");
                    message.encryptedKey[i] = $root.api.Cipher.fromObject(object.encryptedKey[i]);
                }
            }
            switch (object.type) {
            case "ANONYMOUS":
            case 0:
                message.type = 0;
                break;
            case "SES":
            case 1:
                message.type = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a ResourceGetKeyResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourceGetKeyResponse
         * @static
         * @param {api.ResourceGetKeyResponse} message ResourceGetKeyResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceGetKeyResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.encryptedKey = [];
            if (options.defaults)
                object.type = options.enums === String ? "ANONYMOUS" : 0;
            if (message.encryptedKey && message.encryptedKey.length) {
                object.encryptedKey = [];
                for (var j = 0; j < message.encryptedKey.length; ++j)
                    object.encryptedKey[j] = $root.api.Cipher.toObject(message.encryptedKey[j], options);
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.api.ResourceType[message.type] : message.type;
            return object;
        };

        /**
         * Converts this ResourceGetKeyResponse to JSON.
         * @function toJSON
         * @memberof api.ResourceGetKeyResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceGetKeyResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceGetKeyResponse;
    })();

    api.ResourceShareEntry = (function() {

        /**
         * Properties of a ResourceShareEntry.
         * @memberof api
         * @interface IResourceShareEntry
         * @property {string|null} [login] ResourceShareEntry login
         * @property {number|null} [version] ResourceShareEntry version
         * @property {Uint8Array|null} [nonce] ResourceShareEntry nonce
         * @property {Uint8Array|null} [encryptedKey] ResourceShareEntry encryptedKey
         */

        /**
         * Constructs a new ResourceShareEntry.
         * @memberof api
         * @classdesc Represents a ResourceShareEntry.
         * @implements IResourceShareEntry
         * @constructor
         * @param {api.IResourceShareEntry=} [properties] Properties to set
         */
        function ResourceShareEntry(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceShareEntry login.
         * @member {string} login
         * @memberof api.ResourceShareEntry
         * @instance
         */
        ResourceShareEntry.prototype.login = "";

        /**
         * ResourceShareEntry version.
         * @member {number} version
         * @memberof api.ResourceShareEntry
         * @instance
         */
        ResourceShareEntry.prototype.version = 0;

        /**
         * ResourceShareEntry nonce.
         * @member {Uint8Array} nonce
         * @memberof api.ResourceShareEntry
         * @instance
         */
        ResourceShareEntry.prototype.nonce = $util.newBuffer([]);

        /**
         * ResourceShareEntry encryptedKey.
         * @member {Uint8Array} encryptedKey
         * @memberof api.ResourceShareEntry
         * @instance
         */
        ResourceShareEntry.prototype.encryptedKey = $util.newBuffer([]);

        /**
         * Creates a new ResourceShareEntry instance using the specified properties.
         * @function create
         * @memberof api.ResourceShareEntry
         * @static
         * @param {api.IResourceShareEntry=} [properties] Properties to set
         * @returns {api.ResourceShareEntry} ResourceShareEntry instance
         */
        ResourceShareEntry.create = function create(properties) {
            return new ResourceShareEntry(properties);
        };

        /**
         * Encodes the specified ResourceShareEntry message. Does not implicitly {@link api.ResourceShareEntry.verify|verify} messages.
         * @function encode
         * @memberof api.ResourceShareEntry
         * @static
         * @param {api.IResourceShareEntry} message ResourceShareEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceShareEntry.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.nonce);
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.encryptedKey);
            return writer;
        };

        /**
         * Encodes the specified ResourceShareEntry message, length delimited. Does not implicitly {@link api.ResourceShareEntry.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourceShareEntry
         * @static
         * @param {api.IResourceShareEntry} message ResourceShareEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceShareEntry.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceShareEntry message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourceShareEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourceShareEntry} ResourceShareEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceShareEntry.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourceShareEntry();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                case 3:
                    message.nonce = reader.bytes();
                    break;
                case 4:
                    message.encryptedKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceShareEntry message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourceShareEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourceShareEntry} ResourceShareEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceShareEntry.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceShareEntry message.
         * @function verify
         * @memberof api.ResourceShareEntry
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceShareEntry.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                    return "nonce: buffer expected";
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                if (!(message.encryptedKey && typeof message.encryptedKey.length === "number" || $util.isString(message.encryptedKey)))
                    return "encryptedKey: buffer expected";
            return null;
        };

        /**
         * Creates a ResourceShareEntry message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourceShareEntry
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourceShareEntry} ResourceShareEntry
         */
        ResourceShareEntry.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourceShareEntry)
                return object;
            var message = new $root.api.ResourceShareEntry();
            if (object.login != null)
                message.login = String(object.login);
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.nonce != null)
                if (typeof object.nonce === "string")
                    $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                else if (object.nonce.length)
                    message.nonce = object.nonce;
            if (object.encryptedKey != null)
                if (typeof object.encryptedKey === "string")
                    $util.base64.decode(object.encryptedKey, message.encryptedKey = $util.newBuffer($util.base64.length(object.encryptedKey)), 0);
                else if (object.encryptedKey.length)
                    message.encryptedKey = object.encryptedKey;
            return message;
        };

        /**
         * Creates a plain object from a ResourceShareEntry message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourceShareEntry
         * @static
         * @param {api.ResourceShareEntry} message ResourceShareEntry
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceShareEntry.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.version = 0;
                if (options.bytes === String)
                    object.nonce = "";
                else {
                    object.nonce = [];
                    if (options.bytes !== Array)
                        object.nonce = $util.newBuffer(object.nonce);
                }
                if (options.bytes === String)
                    object.encryptedKey = "";
                else {
                    object.encryptedKey = [];
                    if (options.bytes !== Array)
                        object.encryptedKey = $util.newBuffer(object.encryptedKey);
                }
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                object.encryptedKey = options.bytes === String ? $util.base64.encode(message.encryptedKey, 0, message.encryptedKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedKey) : message.encryptedKey;
            return object;
        };

        /**
         * Converts this ResourceShareEntry to JSON.
         * @function toJSON
         * @memberof api.ResourceShareEntry
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceShareEntry.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceShareEntry;
    })();

    api.ResourcePostRequest = (function() {

        /**
         * Properties of a ResourcePostRequest.
         * @memberof api
         * @interface IResourcePostRequest
         * @property {string|null} [kind] ResourcePostRequest kind
         * @property {Uint8Array|null} [publicKey] ResourcePostRequest publicKey
         * @property {Uint8Array|null} [nonce] ResourcePostRequest nonce
         * @property {Uint8Array|null} [payload] ResourcePostRequest payload
         * @property {Array.<api.IResourceShareEntry>|null} [sharingGroup] ResourcePostRequest sharingGroup
         * @property {api.ResourceType|null} [type] ResourcePostRequest type
         */

        /**
         * Constructs a new ResourcePostRequest.
         * @memberof api
         * @classdesc Represents a ResourcePostRequest.
         * @implements IResourcePostRequest
         * @constructor
         * @param {api.IResourcePostRequest=} [properties] Properties to set
         */
        function ResourcePostRequest(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourcePostRequest kind.
         * @member {string} kind
         * @memberof api.ResourcePostRequest
         * @instance
         */
        ResourcePostRequest.prototype.kind = "";

        /**
         * ResourcePostRequest publicKey.
         * @member {Uint8Array} publicKey
         * @memberof api.ResourcePostRequest
         * @instance
         */
        ResourcePostRequest.prototype.publicKey = $util.newBuffer([]);

        /**
         * ResourcePostRequest nonce.
         * @member {Uint8Array} nonce
         * @memberof api.ResourcePostRequest
         * @instance
         */
        ResourcePostRequest.prototype.nonce = $util.newBuffer([]);

        /**
         * ResourcePostRequest payload.
         * @member {Uint8Array} payload
         * @memberof api.ResourcePostRequest
         * @instance
         */
        ResourcePostRequest.prototype.payload = $util.newBuffer([]);

        /**
         * ResourcePostRequest sharingGroup.
         * @member {Array.<api.IResourceShareEntry>} sharingGroup
         * @memberof api.ResourcePostRequest
         * @instance
         */
        ResourcePostRequest.prototype.sharingGroup = $util.emptyArray;

        /**
         * ResourcePostRequest type.
         * @member {api.ResourceType} type
         * @memberof api.ResourcePostRequest
         * @instance
         */
        ResourcePostRequest.prototype.type = 0;

        /**
         * Creates a new ResourcePostRequest instance using the specified properties.
         * @function create
         * @memberof api.ResourcePostRequest
         * @static
         * @param {api.IResourcePostRequest=} [properties] Properties to set
         * @returns {api.ResourcePostRequest} ResourcePostRequest instance
         */
        ResourcePostRequest.create = function create(properties) {
            return new ResourcePostRequest(properties);
        };

        /**
         * Encodes the specified ResourcePostRequest message. Does not implicitly {@link api.ResourcePostRequest.verify|verify} messages.
         * @function encode
         * @memberof api.ResourcePostRequest
         * @static
         * @param {api.IResourcePostRequest} message ResourcePostRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourcePostRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.kind != null && message.hasOwnProperty("kind"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.kind);
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.publicKey);
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.nonce);
            if (message.payload != null && message.hasOwnProperty("payload"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.payload);
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.api.ResourceShareEntry.encode(message.sharingGroup[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified ResourcePostRequest message, length delimited. Does not implicitly {@link api.ResourcePostRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourcePostRequest
         * @static
         * @param {api.IResourcePostRequest} message ResourcePostRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourcePostRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourcePostRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourcePostRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourcePostRequest} ResourcePostRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourcePostRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourcePostRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.kind = reader.string();
                    break;
                case 2:
                    message.publicKey = reader.bytes();
                    break;
                case 3:
                    message.nonce = reader.bytes();
                    break;
                case 4:
                    message.payload = reader.bytes();
                    break;
                case 5:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.api.ResourceShareEntry.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourcePostRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourcePostRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourcePostRequest} ResourcePostRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourcePostRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourcePostRequest message.
         * @function verify
         * @memberof api.ResourcePostRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourcePostRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.kind != null && message.hasOwnProperty("kind"))
                if (!$util.isString(message.kind))
                    return "kind: string expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                    return "nonce: buffer expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.api.ResourceShareEntry.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a ResourcePostRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourcePostRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourcePostRequest} ResourcePostRequest
         */
        ResourcePostRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourcePostRequest)
                return object;
            var message = new $root.api.ResourcePostRequest();
            if (object.kind != null)
                message.kind = String(object.kind);
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.nonce != null)
                if (typeof object.nonce === "string")
                    $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                else if (object.nonce.length)
                    message.nonce = object.nonce;
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".api.ResourcePostRequest.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".api.ResourcePostRequest.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.api.ResourceShareEntry.fromObject(object.sharingGroup[i]);
                }
            }
            switch (object.type) {
            case "ANONYMOUS":
            case 0:
                message.type = 0;
                break;
            case "SES":
            case 1:
                message.type = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a ResourcePostRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourcePostRequest
         * @static
         * @param {api.ResourcePostRequest} message ResourcePostRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourcePostRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults) {
                object.kind = "";
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                if (options.bytes === String)
                    object.nonce = "";
                else {
                    object.nonce = [];
                    if (options.bytes !== Array)
                        object.nonce = $util.newBuffer(object.nonce);
                }
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
                object.type = options.enums === String ? "ANONYMOUS" : 0;
            }
            if (message.kind != null && message.hasOwnProperty("kind"))
                object.kind = message.kind;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.api.ResourceShareEntry.toObject(message.sharingGroup[j], options);
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.api.ResourceType[message.type] : message.type;
            return object;
        };

        /**
         * Converts this ResourcePostRequest to JSON.
         * @function toJSON
         * @memberof api.ResourcePostRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourcePostRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourcePostRequest;
    })();

    api.ResourcePostResponse = (function() {

        /**
         * Properties of a ResourcePostResponse.
         * @memberof api
         * @interface IResourcePostResponse
         * @property {number|Long|null} [id] ResourcePostResponse id
         */

        /**
         * Constructs a new ResourcePostResponse.
         * @memberof api
         * @classdesc Represents a ResourcePostResponse.
         * @implements IResourcePostResponse
         * @constructor
         * @param {api.IResourcePostResponse=} [properties] Properties to set
         */
        function ResourcePostResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourcePostResponse id.
         * @member {number|Long} id
         * @memberof api.ResourcePostResponse
         * @instance
         */
        ResourcePostResponse.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ResourcePostResponse instance using the specified properties.
         * @function create
         * @memberof api.ResourcePostResponse
         * @static
         * @param {api.IResourcePostResponse=} [properties] Properties to set
         * @returns {api.ResourcePostResponse} ResourcePostResponse instance
         */
        ResourcePostResponse.create = function create(properties) {
            return new ResourcePostResponse(properties);
        };

        /**
         * Encodes the specified ResourcePostResponse message. Does not implicitly {@link api.ResourcePostResponse.verify|verify} messages.
         * @function encode
         * @memberof api.ResourcePostResponse
         * @static
         * @param {api.IResourcePostResponse} message ResourcePostResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourcePostResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            return writer;
        };

        /**
         * Encodes the specified ResourcePostResponse message, length delimited. Does not implicitly {@link api.ResourcePostResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourcePostResponse
         * @static
         * @param {api.IResourcePostResponse} message ResourcePostResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourcePostResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourcePostResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourcePostResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourcePostResponse} ResourcePostResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourcePostResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourcePostResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourcePostResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourcePostResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourcePostResponse} ResourcePostResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourcePostResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourcePostResponse message.
         * @function verify
         * @memberof api.ResourcePostResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourcePostResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            return null;
        };

        /**
         * Creates a ResourcePostResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourcePostResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourcePostResponse} ResourcePostResponse
         */
        ResourcePostResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourcePostResponse)
                return object;
            var message = new $root.api.ResourcePostResponse();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a ResourcePostResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourcePostResponse
         * @static
         * @param {api.ResourcePostResponse} message ResourcePostResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourcePostResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            return object;
        };

        /**
         * Converts this ResourcePostResponse to JSON.
         * @function toJSON
         * @memberof api.ResourcePostResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourcePostResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourcePostResponse;
    })();

    api.ResourceExtendSharingGroupRequest = (function() {

        /**
         * Properties of a ResourceExtendSharingGroupRequest.
         * @memberof api
         * @interface IResourceExtendSharingGroupRequest
         * @property {number|Long|null} [id] ResourceExtendSharingGroupRequest id
         * @property {Array.<api.IResourceShareEntry>|null} [sharingGroup] ResourceExtendSharingGroupRequest sharingGroup
         */

        /**
         * Constructs a new ResourceExtendSharingGroupRequest.
         * @memberof api
         * @classdesc Represents a ResourceExtendSharingGroupRequest.
         * @implements IResourceExtendSharingGroupRequest
         * @constructor
         * @param {api.IResourceExtendSharingGroupRequest=} [properties] Properties to set
         */
        function ResourceExtendSharingGroupRequest(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceExtendSharingGroupRequest id.
         * @member {number|Long} id
         * @memberof api.ResourceExtendSharingGroupRequest
         * @instance
         */
        ResourceExtendSharingGroupRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ResourceExtendSharingGroupRequest sharingGroup.
         * @member {Array.<api.IResourceShareEntry>} sharingGroup
         * @memberof api.ResourceExtendSharingGroupRequest
         * @instance
         */
        ResourceExtendSharingGroupRequest.prototype.sharingGroup = $util.emptyArray;

        /**
         * Creates a new ResourceExtendSharingGroupRequest instance using the specified properties.
         * @function create
         * @memberof api.ResourceExtendSharingGroupRequest
         * @static
         * @param {api.IResourceExtendSharingGroupRequest=} [properties] Properties to set
         * @returns {api.ResourceExtendSharingGroupRequest} ResourceExtendSharingGroupRequest instance
         */
        ResourceExtendSharingGroupRequest.create = function create(properties) {
            return new ResourceExtendSharingGroupRequest(properties);
        };

        /**
         * Encodes the specified ResourceExtendSharingGroupRequest message. Does not implicitly {@link api.ResourceExtendSharingGroupRequest.verify|verify} messages.
         * @function encode
         * @memberof api.ResourceExtendSharingGroupRequest
         * @static
         * @param {api.IResourceExtendSharingGroupRequest} message ResourceExtendSharingGroupRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceExtendSharingGroupRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.api.ResourceShareEntry.encode(message.sharingGroup[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResourceExtendSharingGroupRequest message, length delimited. Does not implicitly {@link api.ResourceExtendSharingGroupRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourceExtendSharingGroupRequest
         * @static
         * @param {api.IResourceExtendSharingGroupRequest} message ResourceExtendSharingGroupRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceExtendSharingGroupRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceExtendSharingGroupRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourceExtendSharingGroupRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourceExtendSharingGroupRequest} ResourceExtendSharingGroupRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceExtendSharingGroupRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourceExtendSharingGroupRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                case 2:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.api.ResourceShareEntry.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceExtendSharingGroupRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourceExtendSharingGroupRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourceExtendSharingGroupRequest} ResourceExtendSharingGroupRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceExtendSharingGroupRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceExtendSharingGroupRequest message.
         * @function verify
         * @memberof api.ResourceExtendSharingGroupRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceExtendSharingGroupRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.api.ResourceShareEntry.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ResourceExtendSharingGroupRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourceExtendSharingGroupRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourceExtendSharingGroupRequest} ResourceExtendSharingGroupRequest
         */
        ResourceExtendSharingGroupRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourceExtendSharingGroupRequest)
                return object;
            var message = new $root.api.ResourceExtendSharingGroupRequest();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".api.ResourceExtendSharingGroupRequest.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".api.ResourceExtendSharingGroupRequest.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.api.ResourceShareEntry.fromObject(object.sharingGroup[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ResourceExtendSharingGroupRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourceExtendSharingGroupRequest
         * @static
         * @param {api.ResourceExtendSharingGroupRequest} message ResourceExtendSharingGroupRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceExtendSharingGroupRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.api.ResourceShareEntry.toObject(message.sharingGroup[j], options);
            }
            return object;
        };

        /**
         * Converts this ResourceExtendSharingGroupRequest to JSON.
         * @function toJSON
         * @memberof api.ResourceExtendSharingGroupRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceExtendSharingGroupRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceExtendSharingGroupRequest;
    })();

    api.ResourceListResponse = (function() {

        /**
         * Properties of a ResourceListResponse.
         * @memberof api
         * @interface IResourceListResponse
         * @property {Array.<api.IResourceWithKey>|null} [resources] ResourceListResponse resources
         */

        /**
         * Constructs a new ResourceListResponse.
         * @memberof api
         * @classdesc Represents a ResourceListResponse.
         * @implements IResourceListResponse
         * @constructor
         * @param {api.IResourceListResponse=} [properties] Properties to set
         */
        function ResourceListResponse(properties) {
            this.resources = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceListResponse resources.
         * @member {Array.<api.IResourceWithKey>} resources
         * @memberof api.ResourceListResponse
         * @instance
         */
        ResourceListResponse.prototype.resources = $util.emptyArray;

        /**
         * Creates a new ResourceListResponse instance using the specified properties.
         * @function create
         * @memberof api.ResourceListResponse
         * @static
         * @param {api.IResourceListResponse=} [properties] Properties to set
         * @returns {api.ResourceListResponse} ResourceListResponse instance
         */
        ResourceListResponse.create = function create(properties) {
            return new ResourceListResponse(properties);
        };

        /**
         * Encodes the specified ResourceListResponse message. Does not implicitly {@link api.ResourceListResponse.verify|verify} messages.
         * @function encode
         * @memberof api.ResourceListResponse
         * @static
         * @param {api.IResourceListResponse} message ResourceListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceListResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resources != null && message.resources.length)
                for (var i = 0; i < message.resources.length; ++i)
                    $root.api.ResourceWithKey.encode(message.resources[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResourceListResponse message, length delimited. Does not implicitly {@link api.ResourceListResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourceListResponse
         * @static
         * @param {api.IResourceListResponse} message ResourceListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceListResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceListResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourceListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourceListResponse} ResourceListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceListResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourceListResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.resources && message.resources.length))
                        message.resources = [];
                    message.resources.push($root.api.ResourceWithKey.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceListResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourceListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourceListResponse} ResourceListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceListResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceListResponse message.
         * @function verify
         * @memberof api.ResourceListResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceListResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.resources != null && message.hasOwnProperty("resources")) {
                if (!Array.isArray(message.resources))
                    return "resources: array expected";
                for (var i = 0; i < message.resources.length; ++i) {
                    var error = $root.api.ResourceWithKey.verify(message.resources[i]);
                    if (error)
                        return "resources." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ResourceListResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourceListResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourceListResponse} ResourceListResponse
         */
        ResourceListResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourceListResponse)
                return object;
            var message = new $root.api.ResourceListResponse();
            if (object.resources) {
                if (!Array.isArray(object.resources))
                    throw TypeError(".api.ResourceListResponse.resources: array expected");
                message.resources = [];
                for (var i = 0; i < object.resources.length; ++i) {
                    if (typeof object.resources[i] !== "object")
                        throw TypeError(".api.ResourceListResponse.resources: object expected");
                    message.resources[i] = $root.api.ResourceWithKey.fromObject(object.resources[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ResourceListResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourceListResponse
         * @static
         * @param {api.ResourceListResponse} message ResourceListResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceListResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.resources = [];
            if (message.resources && message.resources.length) {
                object.resources = [];
                for (var j = 0; j < message.resources.length; ++j)
                    object.resources[j] = $root.api.ResourceWithKey.toObject(message.resources[j], options);
            }
            return object;
        };

        /**
         * Converts this ResourceListResponse to JSON.
         * @function toJSON
         * @memberof api.ResourceListResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceListResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceListResponse;
    })();

    api.ResourceGetSharingGroupResponse = (function() {

        /**
         * Properties of a ResourceGetSharingGroupResponse.
         * @memberof api
         * @interface IResourceGetSharingGroupResponse
         * @property {Array.<api.IResourceShareLink>|null} [sharingGroup] ResourceGetSharingGroupResponse sharingGroup
         */

        /**
         * Constructs a new ResourceGetSharingGroupResponse.
         * @memberof api
         * @classdesc Represents a ResourceGetSharingGroupResponse.
         * @implements IResourceGetSharingGroupResponse
         * @constructor
         * @param {api.IResourceGetSharingGroupResponse=} [properties] Properties to set
         */
        function ResourceGetSharingGroupResponse(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceGetSharingGroupResponse sharingGroup.
         * @member {Array.<api.IResourceShareLink>} sharingGroup
         * @memberof api.ResourceGetSharingGroupResponse
         * @instance
         */
        ResourceGetSharingGroupResponse.prototype.sharingGroup = $util.emptyArray;

        /**
         * Creates a new ResourceGetSharingGroupResponse instance using the specified properties.
         * @function create
         * @memberof api.ResourceGetSharingGroupResponse
         * @static
         * @param {api.IResourceGetSharingGroupResponse=} [properties] Properties to set
         * @returns {api.ResourceGetSharingGroupResponse} ResourceGetSharingGroupResponse instance
         */
        ResourceGetSharingGroupResponse.create = function create(properties) {
            return new ResourceGetSharingGroupResponse(properties);
        };

        /**
         * Encodes the specified ResourceGetSharingGroupResponse message. Does not implicitly {@link api.ResourceGetSharingGroupResponse.verify|verify} messages.
         * @function encode
         * @memberof api.ResourceGetSharingGroupResponse
         * @static
         * @param {api.IResourceGetSharingGroupResponse} message ResourceGetSharingGroupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetSharingGroupResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.api.ResourceShareLink.encode(message.sharingGroup[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResourceGetSharingGroupResponse message, length delimited. Does not implicitly {@link api.ResourceGetSharingGroupResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourceGetSharingGroupResponse
         * @static
         * @param {api.IResourceGetSharingGroupResponse} message ResourceGetSharingGroupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetSharingGroupResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceGetSharingGroupResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourceGetSharingGroupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourceGetSharingGroupResponse} ResourceGetSharingGroupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetSharingGroupResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourceGetSharingGroupResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.api.ResourceShareLink.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceGetSharingGroupResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourceGetSharingGroupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourceGetSharingGroupResponse} ResourceGetSharingGroupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetSharingGroupResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceGetSharingGroupResponse message.
         * @function verify
         * @memberof api.ResourceGetSharingGroupResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceGetSharingGroupResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.api.ResourceShareLink.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ResourceGetSharingGroupResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourceGetSharingGroupResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourceGetSharingGroupResponse} ResourceGetSharingGroupResponse
         */
        ResourceGetSharingGroupResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourceGetSharingGroupResponse)
                return object;
            var message = new $root.api.ResourceGetSharingGroupResponse();
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".api.ResourceGetSharingGroupResponse.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".api.ResourceGetSharingGroupResponse.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.api.ResourceShareLink.fromObject(object.sharingGroup[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ResourceGetSharingGroupResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourceGetSharingGroupResponse
         * @static
         * @param {api.ResourceGetSharingGroupResponse} message ResourceGetSharingGroupResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceGetSharingGroupResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.api.ResourceShareLink.toObject(message.sharingGroup[j], options);
            }
            return object;
        };

        /**
         * Converts this ResourceGetSharingGroupResponse to JSON.
         * @function toJSON
         * @memberof api.ResourceGetSharingGroupResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceGetSharingGroupResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceGetSharingGroupResponse;
    })();

    api.ResourceShareLink = (function() {

        /**
         * Properties of a ResourceShareLink.
         * @memberof api
         * @interface IResourceShareLink
         * @property {api.IIdentityKeyID|null} [identityID] ResourceShareLink identityID
         */

        /**
         * Constructs a new ResourceShareLink.
         * @memberof api
         * @classdesc Represents a ResourceShareLink.
         * @implements IResourceShareLink
         * @constructor
         * @param {api.IResourceShareLink=} [properties] Properties to set
         */
        function ResourceShareLink(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceShareLink identityID.
         * @member {api.IIdentityKeyID|null|undefined} identityID
         * @memberof api.ResourceShareLink
         * @instance
         */
        ResourceShareLink.prototype.identityID = null;

        /**
         * Creates a new ResourceShareLink instance using the specified properties.
         * @function create
         * @memberof api.ResourceShareLink
         * @static
         * @param {api.IResourceShareLink=} [properties] Properties to set
         * @returns {api.ResourceShareLink} ResourceShareLink instance
         */
        ResourceShareLink.create = function create(properties) {
            return new ResourceShareLink(properties);
        };

        /**
         * Encodes the specified ResourceShareLink message. Does not implicitly {@link api.ResourceShareLink.verify|verify} messages.
         * @function encode
         * @memberof api.ResourceShareLink
         * @static
         * @param {api.IResourceShareLink} message ResourceShareLink message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceShareLink.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.identityID != null && message.hasOwnProperty("identityID"))
                $root.api.IdentityKeyID.encode(message.identityID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResourceShareLink message, length delimited. Does not implicitly {@link api.ResourceShareLink.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourceShareLink
         * @static
         * @param {api.IResourceShareLink} message ResourceShareLink message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceShareLink.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceShareLink message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourceShareLink
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourceShareLink} ResourceShareLink
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceShareLink.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourceShareLink();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.identityID = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceShareLink message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourceShareLink
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourceShareLink} ResourceShareLink
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceShareLink.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceShareLink message.
         * @function verify
         * @memberof api.ResourceShareLink
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceShareLink.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.identityID != null && message.hasOwnProperty("identityID")) {
                var error = $root.api.IdentityKeyID.verify(message.identityID);
                if (error)
                    return "identityID." + error;
            }
            return null;
        };

        /**
         * Creates a ResourceShareLink message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourceShareLink
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourceShareLink} ResourceShareLink
         */
        ResourceShareLink.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourceShareLink)
                return object;
            var message = new $root.api.ResourceShareLink();
            if (object.identityID != null) {
                if (typeof object.identityID !== "object")
                    throw TypeError(".api.ResourceShareLink.identityID: object expected");
                message.identityID = $root.api.IdentityKeyID.fromObject(object.identityID);
            }
            return message;
        };

        /**
         * Creates a plain object from a ResourceShareLink message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourceShareLink
         * @static
         * @param {api.ResourceShareLink} message ResourceShareLink
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceShareLink.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.identityID = null;
            if (message.identityID != null && message.hasOwnProperty("identityID"))
                object.identityID = $root.api.IdentityKeyID.toObject(message.identityID, options);
            return object;
        };

        /**
         * Converts this ResourceShareLink to JSON.
         * @function toJSON
         * @memberof api.ResourceShareLink
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceShareLink.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceShareLink;
    })();

    api.ResourceAccessLog = (function() {

        /**
         * Properties of a ResourceAccessLog.
         * @memberof api
         * @interface IResourceAccessLog
         * @property {number|Long|null} [resourceID] ResourceAccessLog resourceID
         * @property {api.IIdentityKeyID|null} [owner] ResourceAccessLog owner
         * @property {api.IIdentityKeyID|null} [assume] ResourceAccessLog assume
         * @property {number|Long|null} [timestamp] ResourceAccessLog timestamp
         * @property {string|null} [reason] ResourceAccessLog reason
         */

        /**
         * Constructs a new ResourceAccessLog.
         * @memberof api
         * @classdesc Represents a ResourceAccessLog.
         * @implements IResourceAccessLog
         * @constructor
         * @param {api.IResourceAccessLog=} [properties] Properties to set
         */
        function ResourceAccessLog(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceAccessLog resourceID.
         * @member {number|Long} resourceID
         * @memberof api.ResourceAccessLog
         * @instance
         */
        ResourceAccessLog.prototype.resourceID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ResourceAccessLog owner.
         * @member {api.IIdentityKeyID|null|undefined} owner
         * @memberof api.ResourceAccessLog
         * @instance
         */
        ResourceAccessLog.prototype.owner = null;

        /**
         * ResourceAccessLog assume.
         * @member {api.IIdentityKeyID|null|undefined} assume
         * @memberof api.ResourceAccessLog
         * @instance
         */
        ResourceAccessLog.prototype.assume = null;

        /**
         * ResourceAccessLog timestamp.
         * @member {number|Long} timestamp
         * @memberof api.ResourceAccessLog
         * @instance
         */
        ResourceAccessLog.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ResourceAccessLog reason.
         * @member {string} reason
         * @memberof api.ResourceAccessLog
         * @instance
         */
        ResourceAccessLog.prototype.reason = "";

        /**
         * Creates a new ResourceAccessLog instance using the specified properties.
         * @function create
         * @memberof api.ResourceAccessLog
         * @static
         * @param {api.IResourceAccessLog=} [properties] Properties to set
         * @returns {api.ResourceAccessLog} ResourceAccessLog instance
         */
        ResourceAccessLog.create = function create(properties) {
            return new ResourceAccessLog(properties);
        };

        /**
         * Encodes the specified ResourceAccessLog message. Does not implicitly {@link api.ResourceAccessLog.verify|verify} messages.
         * @function encode
         * @memberof api.ResourceAccessLog
         * @static
         * @param {api.IResourceAccessLog} message ResourceAccessLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceAccessLog.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resourceID != null && message.hasOwnProperty("resourceID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.resourceID);
            if (message.owner != null && message.hasOwnProperty("owner"))
                $root.api.IdentityKeyID.encode(message.owner, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.assume != null && message.hasOwnProperty("assume"))
                $root.api.IdentityKeyID.encode(message.assume, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.timestamp);
            if (message.reason != null && message.hasOwnProperty("reason"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.reason);
            return writer;
        };

        /**
         * Encodes the specified ResourceAccessLog message, length delimited. Does not implicitly {@link api.ResourceAccessLog.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourceAccessLog
         * @static
         * @param {api.IResourceAccessLog} message ResourceAccessLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceAccessLog.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceAccessLog message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourceAccessLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourceAccessLog} ResourceAccessLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceAccessLog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourceAccessLog();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.resourceID = reader.uint64();
                    break;
                case 2:
                    message.owner = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.assume = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.timestamp = reader.uint64();
                    break;
                case 5:
                    message.reason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceAccessLog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourceAccessLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourceAccessLog} ResourceAccessLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceAccessLog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceAccessLog message.
         * @function verify
         * @memberof api.ResourceAccessLog
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceAccessLog.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.resourceID != null && message.hasOwnProperty("resourceID"))
                if (!$util.isInteger(message.resourceID) && !(message.resourceID && $util.isInteger(message.resourceID.low) && $util.isInteger(message.resourceID.high)))
                    return "resourceID: integer|Long expected";
            if (message.owner != null && message.hasOwnProperty("owner")) {
                var error = $root.api.IdentityKeyID.verify(message.owner);
                if (error)
                    return "owner." + error;
            }
            if (message.assume != null && message.hasOwnProperty("assume")) {
                var error = $root.api.IdentityKeyID.verify(message.assume);
                if (error)
                    return "assume." + error;
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            return null;
        };

        /**
         * Creates a ResourceAccessLog message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourceAccessLog
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourceAccessLog} ResourceAccessLog
         */
        ResourceAccessLog.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourceAccessLog)
                return object;
            var message = new $root.api.ResourceAccessLog();
            if (object.resourceID != null)
                if ($util.Long)
                    (message.resourceID = $util.Long.fromValue(object.resourceID)).unsigned = true;
                else if (typeof object.resourceID === "string")
                    message.resourceID = parseInt(object.resourceID, 10);
                else if (typeof object.resourceID === "number")
                    message.resourceID = object.resourceID;
                else if (typeof object.resourceID === "object")
                    message.resourceID = new $util.LongBits(object.resourceID.low >>> 0, object.resourceID.high >>> 0).toNumber(true);
            if (object.owner != null) {
                if (typeof object.owner !== "object")
                    throw TypeError(".api.ResourceAccessLog.owner: object expected");
                message.owner = $root.api.IdentityKeyID.fromObject(object.owner);
            }
            if (object.assume != null) {
                if (typeof object.assume !== "object")
                    throw TypeError(".api.ResourceAccessLog.assume: object expected");
                message.assume = $root.api.IdentityKeyID.fromObject(object.assume);
            }
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
            if (object.reason != null)
                message.reason = String(object.reason);
            return message;
        };

        /**
         * Creates a plain object from a ResourceAccessLog message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourceAccessLog
         * @static
         * @param {api.ResourceAccessLog} message ResourceAccessLog
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceAccessLog.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.resourceID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.resourceID = options.longs === String ? "0" : 0;
                object.owner = null;
                object.assume = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.reason = "";
            }
            if (message.resourceID != null && message.hasOwnProperty("resourceID"))
                if (typeof message.resourceID === "number")
                    object.resourceID = options.longs === String ? String(message.resourceID) : message.resourceID;
                else
                    object.resourceID = options.longs === String ? $util.Long.prototype.toString.call(message.resourceID) : options.longs === Number ? new $util.LongBits(message.resourceID.low >>> 0, message.resourceID.high >>> 0).toNumber(true) : message.resourceID;
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = $root.api.IdentityKeyID.toObject(message.owner, options);
            if (message.assume != null && message.hasOwnProperty("assume"))
                object.assume = $root.api.IdentityKeyID.toObject(message.assume, options);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            return object;
        };

        /**
         * Converts this ResourceAccessLog to JSON.
         * @function toJSON
         * @memberof api.ResourceAccessLog
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceAccessLog.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceAccessLog;
    })();

    api.ResourceGetAccessLogsRequest = (function() {

        /**
         * Properties of a ResourceGetAccessLogsRequest.
         * @memberof api
         * @interface IResourceGetAccessLogsRequest
         * @property {Array.<number|Long>|null} [resourceIDs] ResourceGetAccessLogsRequest resourceIDs
         * @property {number|null} [limit] ResourceGetAccessLogsRequest limit
         * @property {number|null} [offset] ResourceGetAccessLogsRequest offset
         */

        /**
         * Constructs a new ResourceGetAccessLogsRequest.
         * @memberof api
         * @classdesc Represents a ResourceGetAccessLogsRequest.
         * @implements IResourceGetAccessLogsRequest
         * @constructor
         * @param {api.IResourceGetAccessLogsRequest=} [properties] Properties to set
         */
        function ResourceGetAccessLogsRequest(properties) {
            this.resourceIDs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceGetAccessLogsRequest resourceIDs.
         * @member {Array.<number|Long>} resourceIDs
         * @memberof api.ResourceGetAccessLogsRequest
         * @instance
         */
        ResourceGetAccessLogsRequest.prototype.resourceIDs = $util.emptyArray;

        /**
         * ResourceGetAccessLogsRequest limit.
         * @member {number} limit
         * @memberof api.ResourceGetAccessLogsRequest
         * @instance
         */
        ResourceGetAccessLogsRequest.prototype.limit = 0;

        /**
         * ResourceGetAccessLogsRequest offset.
         * @member {number} offset
         * @memberof api.ResourceGetAccessLogsRequest
         * @instance
         */
        ResourceGetAccessLogsRequest.prototype.offset = 0;

        /**
         * Creates a new ResourceGetAccessLogsRequest instance using the specified properties.
         * @function create
         * @memberof api.ResourceGetAccessLogsRequest
         * @static
         * @param {api.IResourceGetAccessLogsRequest=} [properties] Properties to set
         * @returns {api.ResourceGetAccessLogsRequest} ResourceGetAccessLogsRequest instance
         */
        ResourceGetAccessLogsRequest.create = function create(properties) {
            return new ResourceGetAccessLogsRequest(properties);
        };

        /**
         * Encodes the specified ResourceGetAccessLogsRequest message. Does not implicitly {@link api.ResourceGetAccessLogsRequest.verify|verify} messages.
         * @function encode
         * @memberof api.ResourceGetAccessLogsRequest
         * @static
         * @param {api.IResourceGetAccessLogsRequest} message ResourceGetAccessLogsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetAccessLogsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resourceIDs != null && message.resourceIDs.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.resourceIDs.length; ++i)
                    writer.uint64(message.resourceIDs[i]);
                writer.ldelim();
            }
            if (message.limit != null && message.hasOwnProperty("limit"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.limit);
            if (message.offset != null && message.hasOwnProperty("offset"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.offset);
            return writer;
        };

        /**
         * Encodes the specified ResourceGetAccessLogsRequest message, length delimited. Does not implicitly {@link api.ResourceGetAccessLogsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourceGetAccessLogsRequest
         * @static
         * @param {api.IResourceGetAccessLogsRequest} message ResourceGetAccessLogsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetAccessLogsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceGetAccessLogsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourceGetAccessLogsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourceGetAccessLogsRequest} ResourceGetAccessLogsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetAccessLogsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourceGetAccessLogsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.resourceIDs && message.resourceIDs.length))
                        message.resourceIDs = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.resourceIDs.push(reader.uint64());
                    } else
                        message.resourceIDs.push(reader.uint64());
                    break;
                case 2:
                    message.limit = reader.uint32();
                    break;
                case 3:
                    message.offset = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceGetAccessLogsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourceGetAccessLogsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourceGetAccessLogsRequest} ResourceGetAccessLogsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetAccessLogsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceGetAccessLogsRequest message.
         * @function verify
         * @memberof api.ResourceGetAccessLogsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceGetAccessLogsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.resourceIDs != null && message.hasOwnProperty("resourceIDs")) {
                if (!Array.isArray(message.resourceIDs))
                    return "resourceIDs: array expected";
                for (var i = 0; i < message.resourceIDs.length; ++i)
                    if (!$util.isInteger(message.resourceIDs[i]) && !(message.resourceIDs[i] && $util.isInteger(message.resourceIDs[i].low) && $util.isInteger(message.resourceIDs[i].high)))
                        return "resourceIDs: integer|Long[] expected";
            }
            if (message.limit != null && message.hasOwnProperty("limit"))
                if (!$util.isInteger(message.limit))
                    return "limit: integer expected";
            if (message.offset != null && message.hasOwnProperty("offset"))
                if (!$util.isInteger(message.offset))
                    return "offset: integer expected";
            return null;
        };

        /**
         * Creates a ResourceGetAccessLogsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourceGetAccessLogsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourceGetAccessLogsRequest} ResourceGetAccessLogsRequest
         */
        ResourceGetAccessLogsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourceGetAccessLogsRequest)
                return object;
            var message = new $root.api.ResourceGetAccessLogsRequest();
            if (object.resourceIDs) {
                if (!Array.isArray(object.resourceIDs))
                    throw TypeError(".api.ResourceGetAccessLogsRequest.resourceIDs: array expected");
                message.resourceIDs = [];
                for (var i = 0; i < object.resourceIDs.length; ++i)
                    if ($util.Long)
                        (message.resourceIDs[i] = $util.Long.fromValue(object.resourceIDs[i])).unsigned = true;
                    else if (typeof object.resourceIDs[i] === "string")
                        message.resourceIDs[i] = parseInt(object.resourceIDs[i], 10);
                    else if (typeof object.resourceIDs[i] === "number")
                        message.resourceIDs[i] = object.resourceIDs[i];
                    else if (typeof object.resourceIDs[i] === "object")
                        message.resourceIDs[i] = new $util.LongBits(object.resourceIDs[i].low >>> 0, object.resourceIDs[i].high >>> 0).toNumber(true);
            }
            if (object.limit != null)
                message.limit = object.limit >>> 0;
            if (object.offset != null)
                message.offset = object.offset >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ResourceGetAccessLogsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourceGetAccessLogsRequest
         * @static
         * @param {api.ResourceGetAccessLogsRequest} message ResourceGetAccessLogsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceGetAccessLogsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.resourceIDs = [];
            if (options.defaults) {
                object.limit = 0;
                object.offset = 0;
            }
            if (message.resourceIDs && message.resourceIDs.length) {
                object.resourceIDs = [];
                for (var j = 0; j < message.resourceIDs.length; ++j)
                    if (typeof message.resourceIDs[j] === "number")
                        object.resourceIDs[j] = options.longs === String ? String(message.resourceIDs[j]) : message.resourceIDs[j];
                    else
                        object.resourceIDs[j] = options.longs === String ? $util.Long.prototype.toString.call(message.resourceIDs[j]) : options.longs === Number ? new $util.LongBits(message.resourceIDs[j].low >>> 0, message.resourceIDs[j].high >>> 0).toNumber(true) : message.resourceIDs[j];
            }
            if (message.limit != null && message.hasOwnProperty("limit"))
                object.limit = message.limit;
            if (message.offset != null && message.hasOwnProperty("offset"))
                object.offset = message.offset;
            return object;
        };

        /**
         * Converts this ResourceGetAccessLogsRequest to JSON.
         * @function toJSON
         * @memberof api.ResourceGetAccessLogsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceGetAccessLogsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceGetAccessLogsRequest;
    })();

    api.ResourceGetAccessLogsResponse = (function() {

        /**
         * Properties of a ResourceGetAccessLogsResponse.
         * @memberof api
         * @interface IResourceGetAccessLogsResponse
         * @property {Array.<api.IResourceAccessLog>|null} [logs] ResourceGetAccessLogsResponse logs
         */

        /**
         * Constructs a new ResourceGetAccessLogsResponse.
         * @memberof api
         * @classdesc Represents a ResourceGetAccessLogsResponse.
         * @implements IResourceGetAccessLogsResponse
         * @constructor
         * @param {api.IResourceGetAccessLogsResponse=} [properties] Properties to set
         */
        function ResourceGetAccessLogsResponse(properties) {
            this.logs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceGetAccessLogsResponse logs.
         * @member {Array.<api.IResourceAccessLog>} logs
         * @memberof api.ResourceGetAccessLogsResponse
         * @instance
         */
        ResourceGetAccessLogsResponse.prototype.logs = $util.emptyArray;

        /**
         * Creates a new ResourceGetAccessLogsResponse instance using the specified properties.
         * @function create
         * @memberof api.ResourceGetAccessLogsResponse
         * @static
         * @param {api.IResourceGetAccessLogsResponse=} [properties] Properties to set
         * @returns {api.ResourceGetAccessLogsResponse} ResourceGetAccessLogsResponse instance
         */
        ResourceGetAccessLogsResponse.create = function create(properties) {
            return new ResourceGetAccessLogsResponse(properties);
        };

        /**
         * Encodes the specified ResourceGetAccessLogsResponse message. Does not implicitly {@link api.ResourceGetAccessLogsResponse.verify|verify} messages.
         * @function encode
         * @memberof api.ResourceGetAccessLogsResponse
         * @static
         * @param {api.IResourceGetAccessLogsResponse} message ResourceGetAccessLogsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetAccessLogsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.logs != null && message.logs.length)
                for (var i = 0; i < message.logs.length; ++i)
                    $root.api.ResourceAccessLog.encode(message.logs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResourceGetAccessLogsResponse message, length delimited. Does not implicitly {@link api.ResourceGetAccessLogsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourceGetAccessLogsResponse
         * @static
         * @param {api.IResourceGetAccessLogsResponse} message ResourceGetAccessLogsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetAccessLogsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceGetAccessLogsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourceGetAccessLogsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourceGetAccessLogsResponse} ResourceGetAccessLogsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetAccessLogsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourceGetAccessLogsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.logs && message.logs.length))
                        message.logs = [];
                    message.logs.push($root.api.ResourceAccessLog.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceGetAccessLogsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourceGetAccessLogsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourceGetAccessLogsResponse} ResourceGetAccessLogsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetAccessLogsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceGetAccessLogsResponse message.
         * @function verify
         * @memberof api.ResourceGetAccessLogsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceGetAccessLogsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.logs != null && message.hasOwnProperty("logs")) {
                if (!Array.isArray(message.logs))
                    return "logs: array expected";
                for (var i = 0; i < message.logs.length; ++i) {
                    var error = $root.api.ResourceAccessLog.verify(message.logs[i]);
                    if (error)
                        return "logs." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ResourceGetAccessLogsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourceGetAccessLogsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourceGetAccessLogsResponse} ResourceGetAccessLogsResponse
         */
        ResourceGetAccessLogsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourceGetAccessLogsResponse)
                return object;
            var message = new $root.api.ResourceGetAccessLogsResponse();
            if (object.logs) {
                if (!Array.isArray(object.logs))
                    throw TypeError(".api.ResourceGetAccessLogsResponse.logs: array expected");
                message.logs = [];
                for (var i = 0; i < object.logs.length; ++i) {
                    if (typeof object.logs[i] !== "object")
                        throw TypeError(".api.ResourceGetAccessLogsResponse.logs: object expected");
                    message.logs[i] = $root.api.ResourceAccessLog.fromObject(object.logs[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ResourceGetAccessLogsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourceGetAccessLogsResponse
         * @static
         * @param {api.ResourceGetAccessLogsResponse} message ResourceGetAccessLogsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceGetAccessLogsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.logs = [];
            if (message.logs && message.logs.length) {
                object.logs = [];
                for (var j = 0; j < message.logs.length; ++j)
                    object.logs[j] = $root.api.ResourceAccessLog.toObject(message.logs[j], options);
            }
            return object;
        };

        /**
         * Converts this ResourceGetAccessLogsResponse to JSON.
         * @function toJSON
         * @memberof api.ResourceGetAccessLogsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceGetAccessLogsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceGetAccessLogsResponse;
    })();

    api.Event = (function() {

        /**
         * Properties of an Event.
         * @memberof api
         * @interface IEvent
         * @property {google.protobuf.IAny|null} [payload] Event payload
         */

        /**
         * Constructs a new Event.
         * @memberof api
         * @classdesc Represents an Event.
         * @implements IEvent
         * @constructor
         * @param {api.IEvent=} [properties] Properties to set
         */
        function Event(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Event payload.
         * @member {google.protobuf.IAny|null|undefined} payload
         * @memberof api.Event
         * @instance
         */
        Event.prototype.payload = null;

        /**
         * Creates a new Event instance using the specified properties.
         * @function create
         * @memberof api.Event
         * @static
         * @param {api.IEvent=} [properties] Properties to set
         * @returns {api.Event} Event instance
         */
        Event.create = function create(properties) {
            return new Event(properties);
        };

        /**
         * Encodes the specified Event message. Does not implicitly {@link api.Event.verify|verify} messages.
         * @function encode
         * @memberof api.Event
         * @static
         * @param {api.IEvent} message Event message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Event.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.payload != null && message.hasOwnProperty("payload"))
                $root.google.protobuf.Any.encode(message.payload, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Event message, length delimited. Does not implicitly {@link api.Event.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.Event
         * @static
         * @param {api.IEvent} message Event message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Event.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Event message from the specified reader or buffer.
         * @function decode
         * @memberof api.Event
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.Event} Event
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Event.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Event();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.payload = $root.google.protobuf.Any.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Event message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.Event
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.Event} Event
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Event.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Event message.
         * @function verify
         * @memberof api.Event
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Event.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.payload != null && message.hasOwnProperty("payload")) {
                var error = $root.google.protobuf.Any.verify(message.payload);
                if (error)
                    return "payload." + error;
            }
            return null;
        };

        /**
         * Creates an Event message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.Event
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.Event} Event
         */
        Event.fromObject = function fromObject(object) {
            if (object instanceof $root.api.Event)
                return object;
            var message = new $root.api.Event();
            if (object.payload != null) {
                if (typeof object.payload !== "object")
                    throw TypeError(".api.Event.payload: object expected");
                message.payload = $root.google.protobuf.Any.fromObject(object.payload);
            }
            return message;
        };

        /**
         * Creates a plain object from an Event message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.Event
         * @static
         * @param {api.Event} message Event
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Event.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.payload = null;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = $root.google.protobuf.Any.toObject(message.payload, options);
            return object;
        };

        /**
         * Converts this Event to JSON.
         * @function toJSON
         * @memberof api.Event
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Event.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Event;
    })();

    api.EventChannelMessage = (function() {

        /**
         * Properties of an EventChannelMessage.
         * @memberof api
         * @interface IEventChannelMessage
         * @property {number|Long|null} [channelId] EventChannelMessage channelId
         * @property {Uint8Array|null} [content] EventChannelMessage content
         */

        /**
         * Constructs a new EventChannelMessage.
         * @memberof api
         * @classdesc Represents an EventChannelMessage.
         * @implements IEventChannelMessage
         * @constructor
         * @param {api.IEventChannelMessage=} [properties] Properties to set
         */
        function EventChannelMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventChannelMessage channelId.
         * @member {number|Long} channelId
         * @memberof api.EventChannelMessage
         * @instance
         */
        EventChannelMessage.prototype.channelId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * EventChannelMessage content.
         * @member {Uint8Array} content
         * @memberof api.EventChannelMessage
         * @instance
         */
        EventChannelMessage.prototype.content = $util.newBuffer([]);

        /**
         * Creates a new EventChannelMessage instance using the specified properties.
         * @function create
         * @memberof api.EventChannelMessage
         * @static
         * @param {api.IEventChannelMessage=} [properties] Properties to set
         * @returns {api.EventChannelMessage} EventChannelMessage instance
         */
        EventChannelMessage.create = function create(properties) {
            return new EventChannelMessage(properties);
        };

        /**
         * Encodes the specified EventChannelMessage message. Does not implicitly {@link api.EventChannelMessage.verify|verify} messages.
         * @function encode
         * @memberof api.EventChannelMessage
         * @static
         * @param {api.IEventChannelMessage} message EventChannelMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventChannelMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.channelId);
            if (message.content != null && message.hasOwnProperty("content"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.content);
            return writer;
        };

        /**
         * Encodes the specified EventChannelMessage message, length delimited. Does not implicitly {@link api.EventChannelMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.EventChannelMessage
         * @static
         * @param {api.IEventChannelMessage} message EventChannelMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventChannelMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventChannelMessage message from the specified reader or buffer.
         * @function decode
         * @memberof api.EventChannelMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.EventChannelMessage} EventChannelMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventChannelMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.EventChannelMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channelId = reader.uint64();
                    break;
                case 2:
                    message.content = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EventChannelMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.EventChannelMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.EventChannelMessage} EventChannelMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventChannelMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventChannelMessage message.
         * @function verify
         * @memberof api.EventChannelMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventChannelMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!$util.isInteger(message.channelId) && !(message.channelId && $util.isInteger(message.channelId.low) && $util.isInteger(message.channelId.high)))
                    return "channelId: integer|Long expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                    return "content: buffer expected";
            return null;
        };

        /**
         * Creates an EventChannelMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.EventChannelMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.EventChannelMessage} EventChannelMessage
         */
        EventChannelMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.api.EventChannelMessage)
                return object;
            var message = new $root.api.EventChannelMessage();
            if (object.channelId != null)
                if ($util.Long)
                    (message.channelId = $util.Long.fromValue(object.channelId)).unsigned = true;
                else if (typeof object.channelId === "string")
                    message.channelId = parseInt(object.channelId, 10);
                else if (typeof object.channelId === "number")
                    message.channelId = object.channelId;
                else if (typeof object.channelId === "object")
                    message.channelId = new $util.LongBits(object.channelId.low >>> 0, object.channelId.high >>> 0).toNumber(true);
            if (object.content != null)
                if (typeof object.content === "string")
                    $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                else if (object.content.length)
                    message.content = object.content;
            return message;
        };

        /**
         * Creates a plain object from an EventChannelMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.EventChannelMessage
         * @static
         * @param {api.EventChannelMessage} message EventChannelMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventChannelMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.channelId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.channelId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.content = "";
                else {
                    object.content = [];
                    if (options.bytes !== Array)
                        object.content = $util.newBuffer(object.content);
                }
            }
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (typeof message.channelId === "number")
                    object.channelId = options.longs === String ? String(message.channelId) : message.channelId;
                else
                    object.channelId = options.longs === String ? $util.Long.prototype.toString.call(message.channelId) : options.longs === Number ? new $util.LongBits(message.channelId.low >>> 0, message.channelId.high >>> 0).toNumber(true) : message.channelId;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
            return object;
        };

        /**
         * Converts this EventChannelMessage to JSON.
         * @function toJSON
         * @memberof api.EventChannelMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventChannelMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventChannelMessage;
    })();

    api.ChannelGetResponse = (function() {

        /**
         * Properties of a ChannelGetResponse.
         * @memberof api
         * @interface IChannelGetResponse
         * @property {number|Long|null} [id] ChannelGetResponse id
         * @property {api.IResourceGetResponse|null} [resource] ChannelGetResponse resource
         */

        /**
         * Constructs a new ChannelGetResponse.
         * @memberof api
         * @classdesc Represents a ChannelGetResponse.
         * @implements IChannelGetResponse
         * @constructor
         * @param {api.IChannelGetResponse=} [properties] Properties to set
         */
        function ChannelGetResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelGetResponse id.
         * @member {number|Long} id
         * @memberof api.ChannelGetResponse
         * @instance
         */
        ChannelGetResponse.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelGetResponse resource.
         * @member {api.IResourceGetResponse|null|undefined} resource
         * @memberof api.ChannelGetResponse
         * @instance
         */
        ChannelGetResponse.prototype.resource = null;

        /**
         * Creates a new ChannelGetResponse instance using the specified properties.
         * @function create
         * @memberof api.ChannelGetResponse
         * @static
         * @param {api.IChannelGetResponse=} [properties] Properties to set
         * @returns {api.ChannelGetResponse} ChannelGetResponse instance
         */
        ChannelGetResponse.create = function create(properties) {
            return new ChannelGetResponse(properties);
        };

        /**
         * Encodes the specified ChannelGetResponse message. Does not implicitly {@link api.ChannelGetResponse.verify|verify} messages.
         * @function encode
         * @memberof api.ChannelGetResponse
         * @static
         * @param {api.IChannelGetResponse} message ChannelGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelGetResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            if (message.resource != null && message.hasOwnProperty("resource"))
                $root.api.ResourceGetResponse.encode(message.resource, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChannelGetResponse message, length delimited. Does not implicitly {@link api.ChannelGetResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ChannelGetResponse
         * @static
         * @param {api.IChannelGetResponse} message ChannelGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelGetResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelGetResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.ChannelGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ChannelGetResponse} ChannelGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelGetResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ChannelGetResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                case 2:
                    message.resource = $root.api.ResourceGetResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelGetResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ChannelGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ChannelGetResponse} ChannelGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelGetResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelGetResponse message.
         * @function verify
         * @memberof api.ChannelGetResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelGetResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.resource != null && message.hasOwnProperty("resource")) {
                var error = $root.api.ResourceGetResponse.verify(message.resource);
                if (error)
                    return "resource." + error;
            }
            return null;
        };

        /**
         * Creates a ChannelGetResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ChannelGetResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ChannelGetResponse} ChannelGetResponse
         */
        ChannelGetResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ChannelGetResponse)
                return object;
            var message = new $root.api.ChannelGetResponse();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            if (object.resource != null) {
                if (typeof object.resource !== "object")
                    throw TypeError(".api.ChannelGetResponse.resource: object expected");
                message.resource = $root.api.ResourceGetResponse.fromObject(object.resource);
            }
            return message;
        };

        /**
         * Creates a plain object from a ChannelGetResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ChannelGetResponse
         * @static
         * @param {api.ChannelGetResponse} message ChannelGetResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelGetResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.resource = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            if (message.resource != null && message.hasOwnProperty("resource"))
                object.resource = $root.api.ResourceGetResponse.toObject(message.resource, options);
            return object;
        };

        /**
         * Converts this ChannelGetResponse to JSON.
         * @function toJSON
         * @memberof api.ChannelGetResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelGetResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelGetResponse;
    })();

    api.ChannelPostRequest = (function() {

        /**
         * Properties of a ChannelPostRequest.
         * @memberof api
         * @interface IChannelPostRequest
         * @property {Uint8Array|null} [publicKey] ChannelPostRequest publicKey
         * @property {Uint8Array|null} [nonce] ChannelPostRequest nonce
         * @property {Uint8Array|null} [payload] ChannelPostRequest payload
         * @property {Array.<api.IResourceShareEntry>|null} [sharingGroup] ChannelPostRequest sharingGroup
         * @property {api.ResourceType|null} [type] ChannelPostRequest type
         */

        /**
         * Constructs a new ChannelPostRequest.
         * @memberof api
         * @classdesc Represents a ChannelPostRequest.
         * @implements IChannelPostRequest
         * @constructor
         * @param {api.IChannelPostRequest=} [properties] Properties to set
         */
        function ChannelPostRequest(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelPostRequest publicKey.
         * @member {Uint8Array} publicKey
         * @memberof api.ChannelPostRequest
         * @instance
         */
        ChannelPostRequest.prototype.publicKey = $util.newBuffer([]);

        /**
         * ChannelPostRequest nonce.
         * @member {Uint8Array} nonce
         * @memberof api.ChannelPostRequest
         * @instance
         */
        ChannelPostRequest.prototype.nonce = $util.newBuffer([]);

        /**
         * ChannelPostRequest payload.
         * @member {Uint8Array} payload
         * @memberof api.ChannelPostRequest
         * @instance
         */
        ChannelPostRequest.prototype.payload = $util.newBuffer([]);

        /**
         * ChannelPostRequest sharingGroup.
         * @member {Array.<api.IResourceShareEntry>} sharingGroup
         * @memberof api.ChannelPostRequest
         * @instance
         */
        ChannelPostRequest.prototype.sharingGroup = $util.emptyArray;

        /**
         * ChannelPostRequest type.
         * @member {api.ResourceType} type
         * @memberof api.ChannelPostRequest
         * @instance
         */
        ChannelPostRequest.prototype.type = 0;

        /**
         * Creates a new ChannelPostRequest instance using the specified properties.
         * @function create
         * @memberof api.ChannelPostRequest
         * @static
         * @param {api.IChannelPostRequest=} [properties] Properties to set
         * @returns {api.ChannelPostRequest} ChannelPostRequest instance
         */
        ChannelPostRequest.create = function create(properties) {
            return new ChannelPostRequest(properties);
        };

        /**
         * Encodes the specified ChannelPostRequest message. Does not implicitly {@link api.ChannelPostRequest.verify|verify} messages.
         * @function encode
         * @memberof api.ChannelPostRequest
         * @static
         * @param {api.IChannelPostRequest} message ChannelPostRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelPostRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nonce);
            if (message.payload != null && message.hasOwnProperty("payload"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.payload);
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.api.ResourceShareEntry.encode(message.sharingGroup[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified ChannelPostRequest message, length delimited. Does not implicitly {@link api.ChannelPostRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ChannelPostRequest
         * @static
         * @param {api.IChannelPostRequest} message ChannelPostRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelPostRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelPostRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.ChannelPostRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ChannelPostRequest} ChannelPostRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelPostRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ChannelPostRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.publicKey = reader.bytes();
                    break;
                case 2:
                    message.nonce = reader.bytes();
                    break;
                case 3:
                    message.payload = reader.bytes();
                    break;
                case 4:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.api.ResourceShareEntry.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelPostRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ChannelPostRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ChannelPostRequest} ChannelPostRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelPostRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelPostRequest message.
         * @function verify
         * @memberof api.ChannelPostRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelPostRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                    return "nonce: buffer expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.api.ResourceShareEntry.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a ChannelPostRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ChannelPostRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ChannelPostRequest} ChannelPostRequest
         */
        ChannelPostRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ChannelPostRequest)
                return object;
            var message = new $root.api.ChannelPostRequest();
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.nonce != null)
                if (typeof object.nonce === "string")
                    $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                else if (object.nonce.length)
                    message.nonce = object.nonce;
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".api.ChannelPostRequest.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".api.ChannelPostRequest.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.api.ResourceShareEntry.fromObject(object.sharingGroup[i]);
                }
            }
            switch (object.type) {
            case "ANONYMOUS":
            case 0:
                message.type = 0;
                break;
            case "SES":
            case 1:
                message.type = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a ChannelPostRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ChannelPostRequest
         * @static
         * @param {api.ChannelPostRequest} message ChannelPostRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelPostRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                if (options.bytes === String)
                    object.nonce = "";
                else {
                    object.nonce = [];
                    if (options.bytes !== Array)
                        object.nonce = $util.newBuffer(object.nonce);
                }
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
                object.type = options.enums === String ? "ANONYMOUS" : 0;
            }
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.api.ResourceShareEntry.toObject(message.sharingGroup[j], options);
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.api.ResourceType[message.type] : message.type;
            return object;
        };

        /**
         * Converts this ChannelPostRequest to JSON.
         * @function toJSON
         * @memberof api.ChannelPostRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelPostRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelPostRequest;
    })();

    api.ChannelPostResponse = (function() {

        /**
         * Properties of a ChannelPostResponse.
         * @memberof api
         * @interface IChannelPostResponse
         * @property {number|Long|null} [id] ChannelPostResponse id
         */

        /**
         * Constructs a new ChannelPostResponse.
         * @memberof api
         * @classdesc Represents a ChannelPostResponse.
         * @implements IChannelPostResponse
         * @constructor
         * @param {api.IChannelPostResponse=} [properties] Properties to set
         */
        function ChannelPostResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelPostResponse id.
         * @member {number|Long} id
         * @memberof api.ChannelPostResponse
         * @instance
         */
        ChannelPostResponse.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ChannelPostResponse instance using the specified properties.
         * @function create
         * @memberof api.ChannelPostResponse
         * @static
         * @param {api.IChannelPostResponse=} [properties] Properties to set
         * @returns {api.ChannelPostResponse} ChannelPostResponse instance
         */
        ChannelPostResponse.create = function create(properties) {
            return new ChannelPostResponse(properties);
        };

        /**
         * Encodes the specified ChannelPostResponse message. Does not implicitly {@link api.ChannelPostResponse.verify|verify} messages.
         * @function encode
         * @memberof api.ChannelPostResponse
         * @static
         * @param {api.IChannelPostResponse} message ChannelPostResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelPostResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            return writer;
        };

        /**
         * Encodes the specified ChannelPostResponse message, length delimited. Does not implicitly {@link api.ChannelPostResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ChannelPostResponse
         * @static
         * @param {api.IChannelPostResponse} message ChannelPostResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelPostResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelPostResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.ChannelPostResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ChannelPostResponse} ChannelPostResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelPostResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ChannelPostResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelPostResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ChannelPostResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ChannelPostResponse} ChannelPostResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelPostResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelPostResponse message.
         * @function verify
         * @memberof api.ChannelPostResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelPostResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            return null;
        };

        /**
         * Creates a ChannelPostResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ChannelPostResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ChannelPostResponse} ChannelPostResponse
         */
        ChannelPostResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ChannelPostResponse)
                return object;
            var message = new $root.api.ChannelPostResponse();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a ChannelPostResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ChannelPostResponse
         * @static
         * @param {api.ChannelPostResponse} message ChannelPostResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelPostResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            return object;
        };

        /**
         * Converts this ChannelPostResponse to JSON.
         * @function toJSON
         * @memberof api.ChannelPostResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelPostResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelPostResponse;
    })();

    api.ChannelPostMessageRequest = (function() {

        /**
         * Properties of a ChannelPostMessageRequest.
         * @memberof api
         * @interface IChannelPostMessageRequest
         * @property {number|Long|null} [channelId] ChannelPostMessageRequest channelId
         * @property {Uint8Array|null} [content] ChannelPostMessageRequest content
         */

        /**
         * Constructs a new ChannelPostMessageRequest.
         * @memberof api
         * @classdesc Represents a ChannelPostMessageRequest.
         * @implements IChannelPostMessageRequest
         * @constructor
         * @param {api.IChannelPostMessageRequest=} [properties] Properties to set
         */
        function ChannelPostMessageRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelPostMessageRequest channelId.
         * @member {number|Long} channelId
         * @memberof api.ChannelPostMessageRequest
         * @instance
         */
        ChannelPostMessageRequest.prototype.channelId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelPostMessageRequest content.
         * @member {Uint8Array} content
         * @memberof api.ChannelPostMessageRequest
         * @instance
         */
        ChannelPostMessageRequest.prototype.content = $util.newBuffer([]);

        /**
         * Creates a new ChannelPostMessageRequest instance using the specified properties.
         * @function create
         * @memberof api.ChannelPostMessageRequest
         * @static
         * @param {api.IChannelPostMessageRequest=} [properties] Properties to set
         * @returns {api.ChannelPostMessageRequest} ChannelPostMessageRequest instance
         */
        ChannelPostMessageRequest.create = function create(properties) {
            return new ChannelPostMessageRequest(properties);
        };

        /**
         * Encodes the specified ChannelPostMessageRequest message. Does not implicitly {@link api.ChannelPostMessageRequest.verify|verify} messages.
         * @function encode
         * @memberof api.ChannelPostMessageRequest
         * @static
         * @param {api.IChannelPostMessageRequest} message ChannelPostMessageRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelPostMessageRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.channelId);
            if (message.content != null && message.hasOwnProperty("content"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.content);
            return writer;
        };

        /**
         * Encodes the specified ChannelPostMessageRequest message, length delimited. Does not implicitly {@link api.ChannelPostMessageRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ChannelPostMessageRequest
         * @static
         * @param {api.IChannelPostMessageRequest} message ChannelPostMessageRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelPostMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelPostMessageRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.ChannelPostMessageRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ChannelPostMessageRequest} ChannelPostMessageRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelPostMessageRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ChannelPostMessageRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channelId = reader.uint64();
                    break;
                case 2:
                    message.content = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelPostMessageRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ChannelPostMessageRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ChannelPostMessageRequest} ChannelPostMessageRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelPostMessageRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelPostMessageRequest message.
         * @function verify
         * @memberof api.ChannelPostMessageRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelPostMessageRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!$util.isInteger(message.channelId) && !(message.channelId && $util.isInteger(message.channelId.low) && $util.isInteger(message.channelId.high)))
                    return "channelId: integer|Long expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                    return "content: buffer expected";
            return null;
        };

        /**
         * Creates a ChannelPostMessageRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ChannelPostMessageRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ChannelPostMessageRequest} ChannelPostMessageRequest
         */
        ChannelPostMessageRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ChannelPostMessageRequest)
                return object;
            var message = new $root.api.ChannelPostMessageRequest();
            if (object.channelId != null)
                if ($util.Long)
                    (message.channelId = $util.Long.fromValue(object.channelId)).unsigned = true;
                else if (typeof object.channelId === "string")
                    message.channelId = parseInt(object.channelId, 10);
                else if (typeof object.channelId === "number")
                    message.channelId = object.channelId;
                else if (typeof object.channelId === "object")
                    message.channelId = new $util.LongBits(object.channelId.low >>> 0, object.channelId.high >>> 0).toNumber(true);
            if (object.content != null)
                if (typeof object.content === "string")
                    $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                else if (object.content.length)
                    message.content = object.content;
            return message;
        };

        /**
         * Creates a plain object from a ChannelPostMessageRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ChannelPostMessageRequest
         * @static
         * @param {api.ChannelPostMessageRequest} message ChannelPostMessageRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelPostMessageRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.channelId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.channelId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.content = "";
                else {
                    object.content = [];
                    if (options.bytes !== Array)
                        object.content = $util.newBuffer(object.content);
                }
            }
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (typeof message.channelId === "number")
                    object.channelId = options.longs === String ? String(message.channelId) : message.channelId;
                else
                    object.channelId = options.longs === String ? $util.Long.prototype.toString.call(message.channelId) : options.longs === Number ? new $util.LongBits(message.channelId.low >>> 0, message.channelId.high >>> 0).toNumber(true) : message.channelId;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
            return object;
        };

        /**
         * Converts this ChannelPostMessageRequest to JSON.
         * @function toJSON
         * @memberof api.ChannelPostMessageRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelPostMessageRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelPostMessageRequest;
    })();

    api.DelegatedPostRequest = (function() {

        /**
         * Properties of a DelegatedPostRequest.
         * @memberof api
         * @interface IDelegatedPostRequest
         * @property {Uint8Array|null} [publicKey] DelegatedPostRequest publicKey
         * @property {Uint8Array|null} [sign] DelegatedPostRequest sign
         * @property {string|null} [requester] DelegatedPostRequest requester
         * @property {api.IResourceShareEntry|null} [sharing] DelegatedPostRequest sharing
         */

        /**
         * Constructs a new DelegatedPostRequest.
         * @memberof api
         * @classdesc Represents a DelegatedPostRequest.
         * @implements IDelegatedPostRequest
         * @constructor
         * @param {api.IDelegatedPostRequest=} [properties] Properties to set
         */
        function DelegatedPostRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelegatedPostRequest publicKey.
         * @member {Uint8Array} publicKey
         * @memberof api.DelegatedPostRequest
         * @instance
         */
        DelegatedPostRequest.prototype.publicKey = $util.newBuffer([]);

        /**
         * DelegatedPostRequest sign.
         * @member {Uint8Array} sign
         * @memberof api.DelegatedPostRequest
         * @instance
         */
        DelegatedPostRequest.prototype.sign = $util.newBuffer([]);

        /**
         * DelegatedPostRequest requester.
         * @member {string} requester
         * @memberof api.DelegatedPostRequest
         * @instance
         */
        DelegatedPostRequest.prototype.requester = "";

        /**
         * DelegatedPostRequest sharing.
         * @member {api.IResourceShareEntry|null|undefined} sharing
         * @memberof api.DelegatedPostRequest
         * @instance
         */
        DelegatedPostRequest.prototype.sharing = null;

        /**
         * Creates a new DelegatedPostRequest instance using the specified properties.
         * @function create
         * @memberof api.DelegatedPostRequest
         * @static
         * @param {api.IDelegatedPostRequest=} [properties] Properties to set
         * @returns {api.DelegatedPostRequest} DelegatedPostRequest instance
         */
        DelegatedPostRequest.create = function create(properties) {
            return new DelegatedPostRequest(properties);
        };

        /**
         * Encodes the specified DelegatedPostRequest message. Does not implicitly {@link api.DelegatedPostRequest.verify|verify} messages.
         * @function encode
         * @memberof api.DelegatedPostRequest
         * @static
         * @param {api.IDelegatedPostRequest} message DelegatedPostRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedPostRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
            if (message.sign != null && message.hasOwnProperty("sign"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.sign);
            if (message.requester != null && message.hasOwnProperty("requester"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.requester);
            if (message.sharing != null && message.hasOwnProperty("sharing"))
                $root.api.ResourceShareEntry.encode(message.sharing, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DelegatedPostRequest message, length delimited. Does not implicitly {@link api.DelegatedPostRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.DelegatedPostRequest
         * @static
         * @param {api.IDelegatedPostRequest} message DelegatedPostRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedPostRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelegatedPostRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.DelegatedPostRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.DelegatedPostRequest} DelegatedPostRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedPostRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DelegatedPostRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.publicKey = reader.bytes();
                    break;
                case 2:
                    message.sign = reader.bytes();
                    break;
                case 3:
                    message.requester = reader.string();
                    break;
                case 4:
                    message.sharing = $root.api.ResourceShareEntry.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelegatedPostRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.DelegatedPostRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.DelegatedPostRequest} DelegatedPostRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedPostRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelegatedPostRequest message.
         * @function verify
         * @memberof api.DelegatedPostRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelegatedPostRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.sign != null && message.hasOwnProperty("sign"))
                if (!(message.sign && typeof message.sign.length === "number" || $util.isString(message.sign)))
                    return "sign: buffer expected";
            if (message.requester != null && message.hasOwnProperty("requester"))
                if (!$util.isString(message.requester))
                    return "requester: string expected";
            if (message.sharing != null && message.hasOwnProperty("sharing")) {
                var error = $root.api.ResourceShareEntry.verify(message.sharing);
                if (error)
                    return "sharing." + error;
            }
            return null;
        };

        /**
         * Creates a DelegatedPostRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.DelegatedPostRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.DelegatedPostRequest} DelegatedPostRequest
         */
        DelegatedPostRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.DelegatedPostRequest)
                return object;
            var message = new $root.api.DelegatedPostRequest();
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.sign != null)
                if (typeof object.sign === "string")
                    $util.base64.decode(object.sign, message.sign = $util.newBuffer($util.base64.length(object.sign)), 0);
                else if (object.sign.length)
                    message.sign = object.sign;
            if (object.requester != null)
                message.requester = String(object.requester);
            if (object.sharing != null) {
                if (typeof object.sharing !== "object")
                    throw TypeError(".api.DelegatedPostRequest.sharing: object expected");
                message.sharing = $root.api.ResourceShareEntry.fromObject(object.sharing);
            }
            return message;
        };

        /**
         * Creates a plain object from a DelegatedPostRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.DelegatedPostRequest
         * @static
         * @param {api.DelegatedPostRequest} message DelegatedPostRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelegatedPostRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                if (options.bytes === String)
                    object.sign = "";
                else {
                    object.sign = [];
                    if (options.bytes !== Array)
                        object.sign = $util.newBuffer(object.sign);
                }
                object.requester = "";
                object.sharing = null;
            }
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.sign != null && message.hasOwnProperty("sign"))
                object.sign = options.bytes === String ? $util.base64.encode(message.sign, 0, message.sign.length) : options.bytes === Array ? Array.prototype.slice.call(message.sign) : message.sign;
            if (message.requester != null && message.hasOwnProperty("requester"))
                object.requester = message.requester;
            if (message.sharing != null && message.hasOwnProperty("sharing"))
                object.sharing = $root.api.ResourceShareEntry.toObject(message.sharing, options);
            return object;
        };

        /**
         * Converts this DelegatedPostRequest to JSON.
         * @function toJSON
         * @memberof api.DelegatedPostRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelegatedPostRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelegatedPostRequest;
    })();

    api.DelegatedPostResponse = (function() {

        /**
         * Properties of a DelegatedPostResponse.
         * @memberof api
         * @interface IDelegatedPostResponse
         * @property {number|Long|null} [id] DelegatedPostResponse id
         */

        /**
         * Constructs a new DelegatedPostResponse.
         * @memberof api
         * @classdesc Represents a DelegatedPostResponse.
         * @implements IDelegatedPostResponse
         * @constructor
         * @param {api.IDelegatedPostResponse=} [properties] Properties to set
         */
        function DelegatedPostResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelegatedPostResponse id.
         * @member {number|Long} id
         * @memberof api.DelegatedPostResponse
         * @instance
         */
        DelegatedPostResponse.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new DelegatedPostResponse instance using the specified properties.
         * @function create
         * @memberof api.DelegatedPostResponse
         * @static
         * @param {api.IDelegatedPostResponse=} [properties] Properties to set
         * @returns {api.DelegatedPostResponse} DelegatedPostResponse instance
         */
        DelegatedPostResponse.create = function create(properties) {
            return new DelegatedPostResponse(properties);
        };

        /**
         * Encodes the specified DelegatedPostResponse message. Does not implicitly {@link api.DelegatedPostResponse.verify|verify} messages.
         * @function encode
         * @memberof api.DelegatedPostResponse
         * @static
         * @param {api.IDelegatedPostResponse} message DelegatedPostResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedPostResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            return writer;
        };

        /**
         * Encodes the specified DelegatedPostResponse message, length delimited. Does not implicitly {@link api.DelegatedPostResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.DelegatedPostResponse
         * @static
         * @param {api.IDelegatedPostResponse} message DelegatedPostResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedPostResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelegatedPostResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.DelegatedPostResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.DelegatedPostResponse} DelegatedPostResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedPostResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DelegatedPostResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelegatedPostResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.DelegatedPostResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.DelegatedPostResponse} DelegatedPostResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedPostResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelegatedPostResponse message.
         * @function verify
         * @memberof api.DelegatedPostResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelegatedPostResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            return null;
        };

        /**
         * Creates a DelegatedPostResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.DelegatedPostResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.DelegatedPostResponse} DelegatedPostResponse
         */
        DelegatedPostResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.DelegatedPostResponse)
                return object;
            var message = new $root.api.DelegatedPostResponse();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a DelegatedPostResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.DelegatedPostResponse
         * @static
         * @param {api.DelegatedPostResponse} message DelegatedPostResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelegatedPostResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            return object;
        };

        /**
         * Converts this DelegatedPostResponse to JSON.
         * @function toJSON
         * @memberof api.DelegatedPostResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelegatedPostResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelegatedPostResponse;
    })();

    api.DelegatedGetResponse = (function() {

        /**
         * Properties of a DelegatedGetResponse.
         * @memberof api
         * @interface IDelegatedGetResponse
         * @property {api.IResourceGetResponse|null} [resource] DelegatedGetResponse resource
         * @property {Uint8Array|null} [sign] DelegatedGetResponse sign
         */

        /**
         * Constructs a new DelegatedGetResponse.
         * @memberof api
         * @classdesc Represents a DelegatedGetResponse.
         * @implements IDelegatedGetResponse
         * @constructor
         * @param {api.IDelegatedGetResponse=} [properties] Properties to set
         */
        function DelegatedGetResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelegatedGetResponse resource.
         * @member {api.IResourceGetResponse|null|undefined} resource
         * @memberof api.DelegatedGetResponse
         * @instance
         */
        DelegatedGetResponse.prototype.resource = null;

        /**
         * DelegatedGetResponse sign.
         * @member {Uint8Array} sign
         * @memberof api.DelegatedGetResponse
         * @instance
         */
        DelegatedGetResponse.prototype.sign = $util.newBuffer([]);

        /**
         * Creates a new DelegatedGetResponse instance using the specified properties.
         * @function create
         * @memberof api.DelegatedGetResponse
         * @static
         * @param {api.IDelegatedGetResponse=} [properties] Properties to set
         * @returns {api.DelegatedGetResponse} DelegatedGetResponse instance
         */
        DelegatedGetResponse.create = function create(properties) {
            return new DelegatedGetResponse(properties);
        };

        /**
         * Encodes the specified DelegatedGetResponse message. Does not implicitly {@link api.DelegatedGetResponse.verify|verify} messages.
         * @function encode
         * @memberof api.DelegatedGetResponse
         * @static
         * @param {api.IDelegatedGetResponse} message DelegatedGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedGetResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resource != null && message.hasOwnProperty("resource"))
                $root.api.ResourceGetResponse.encode(message.resource, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.sign != null && message.hasOwnProperty("sign"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.sign);
            return writer;
        };

        /**
         * Encodes the specified DelegatedGetResponse message, length delimited. Does not implicitly {@link api.DelegatedGetResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.DelegatedGetResponse
         * @static
         * @param {api.IDelegatedGetResponse} message DelegatedGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedGetResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelegatedGetResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.DelegatedGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.DelegatedGetResponse} DelegatedGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedGetResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DelegatedGetResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.resource = $root.api.ResourceGetResponse.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.sign = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelegatedGetResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.DelegatedGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.DelegatedGetResponse} DelegatedGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedGetResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelegatedGetResponse message.
         * @function verify
         * @memberof api.DelegatedGetResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelegatedGetResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.resource != null && message.hasOwnProperty("resource")) {
                var error = $root.api.ResourceGetResponse.verify(message.resource);
                if (error)
                    return "resource." + error;
            }
            if (message.sign != null && message.hasOwnProperty("sign"))
                if (!(message.sign && typeof message.sign.length === "number" || $util.isString(message.sign)))
                    return "sign: buffer expected";
            return null;
        };

        /**
         * Creates a DelegatedGetResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.DelegatedGetResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.DelegatedGetResponse} DelegatedGetResponse
         */
        DelegatedGetResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.DelegatedGetResponse)
                return object;
            var message = new $root.api.DelegatedGetResponse();
            if (object.resource != null) {
                if (typeof object.resource !== "object")
                    throw TypeError(".api.DelegatedGetResponse.resource: object expected");
                message.resource = $root.api.ResourceGetResponse.fromObject(object.resource);
            }
            if (object.sign != null)
                if (typeof object.sign === "string")
                    $util.base64.decode(object.sign, message.sign = $util.newBuffer($util.base64.length(object.sign)), 0);
                else if (object.sign.length)
                    message.sign = object.sign;
            return message;
        };

        /**
         * Creates a plain object from a DelegatedGetResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.DelegatedGetResponse
         * @static
         * @param {api.DelegatedGetResponse} message DelegatedGetResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelegatedGetResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.resource = null;
                if (options.bytes === String)
                    object.sign = "";
                else {
                    object.sign = [];
                    if (options.bytes !== Array)
                        object.sign = $util.newBuffer(object.sign);
                }
            }
            if (message.resource != null && message.hasOwnProperty("resource"))
                object.resource = $root.api.ResourceGetResponse.toObject(message.resource, options);
            if (message.sign != null && message.hasOwnProperty("sign"))
                object.sign = options.bytes === String ? $util.base64.encode(message.sign, 0, message.sign.length) : options.bytes === Array ? Array.prototype.slice.call(message.sign) : message.sign;
            return object;
        };

        /**
         * Converts this DelegatedGetResponse to JSON.
         * @function toJSON
         * @memberof api.DelegatedGetResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelegatedGetResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelegatedGetResponse;
    })();

    api.DelegatedKeys = (function() {

        /**
         * Properties of a DelegatedKeys.
         * @memberof api
         * @interface IDelegatedKeys
         * @property {string|null} [login] DelegatedKeys login
         * @property {number|null} [version] DelegatedKeys version
         * @property {Uint8Array|null} [signKey] DelegatedKeys signKey
         * @property {Uint8Array|null} [readKey] DelegatedKeys readKey
         * @property {Uint8Array|null} [sharingKey] DelegatedKeys sharingKey
         * @property {Uint8Array|null} [boxKey] DelegatedKeys boxKey
         */

        /**
         * Constructs a new DelegatedKeys.
         * @memberof api
         * @classdesc Represents a DelegatedKeys.
         * @implements IDelegatedKeys
         * @constructor
         * @param {api.IDelegatedKeys=} [properties] Properties to set
         */
        function DelegatedKeys(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelegatedKeys login.
         * @member {string} login
         * @memberof api.DelegatedKeys
         * @instance
         */
        DelegatedKeys.prototype.login = "";

        /**
         * DelegatedKeys version.
         * @member {number} version
         * @memberof api.DelegatedKeys
         * @instance
         */
        DelegatedKeys.prototype.version = 0;

        /**
         * DelegatedKeys signKey.
         * @member {Uint8Array} signKey
         * @memberof api.DelegatedKeys
         * @instance
         */
        DelegatedKeys.prototype.signKey = $util.newBuffer([]);

        /**
         * DelegatedKeys readKey.
         * @member {Uint8Array} readKey
         * @memberof api.DelegatedKeys
         * @instance
         */
        DelegatedKeys.prototype.readKey = $util.newBuffer([]);

        /**
         * DelegatedKeys sharingKey.
         * @member {Uint8Array} sharingKey
         * @memberof api.DelegatedKeys
         * @instance
         */
        DelegatedKeys.prototype.sharingKey = $util.newBuffer([]);

        /**
         * DelegatedKeys boxKey.
         * @member {Uint8Array} boxKey
         * @memberof api.DelegatedKeys
         * @instance
         */
        DelegatedKeys.prototype.boxKey = $util.newBuffer([]);

        /**
         * Creates a new DelegatedKeys instance using the specified properties.
         * @function create
         * @memberof api.DelegatedKeys
         * @static
         * @param {api.IDelegatedKeys=} [properties] Properties to set
         * @returns {api.DelegatedKeys} DelegatedKeys instance
         */
        DelegatedKeys.create = function create(properties) {
            return new DelegatedKeys(properties);
        };

        /**
         * Encodes the specified DelegatedKeys message. Does not implicitly {@link api.DelegatedKeys.verify|verify} messages.
         * @function encode
         * @memberof api.DelegatedKeys
         * @static
         * @param {api.IDelegatedKeys} message DelegatedKeys message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedKeys.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            if (message.signKey != null && message.hasOwnProperty("signKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signKey);
            if (message.readKey != null && message.hasOwnProperty("readKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.readKey);
            if (message.sharingKey != null && message.hasOwnProperty("sharingKey"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.sharingKey);
            if (message.boxKey != null && message.hasOwnProperty("boxKey"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.boxKey);
            return writer;
        };

        /**
         * Encodes the specified DelegatedKeys message, length delimited. Does not implicitly {@link api.DelegatedKeys.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.DelegatedKeys
         * @static
         * @param {api.IDelegatedKeys} message DelegatedKeys message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedKeys.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelegatedKeys message from the specified reader or buffer.
         * @function decode
         * @memberof api.DelegatedKeys
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.DelegatedKeys} DelegatedKeys
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedKeys.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DelegatedKeys();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                case 3:
                    message.signKey = reader.bytes();
                    break;
                case 4:
                    message.readKey = reader.bytes();
                    break;
                case 5:
                    message.sharingKey = reader.bytes();
                    break;
                case 6:
                    message.boxKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelegatedKeys message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.DelegatedKeys
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.DelegatedKeys} DelegatedKeys
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedKeys.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelegatedKeys message.
         * @function verify
         * @memberof api.DelegatedKeys
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelegatedKeys.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.signKey != null && message.hasOwnProperty("signKey"))
                if (!(message.signKey && typeof message.signKey.length === "number" || $util.isString(message.signKey)))
                    return "signKey: buffer expected";
            if (message.readKey != null && message.hasOwnProperty("readKey"))
                if (!(message.readKey && typeof message.readKey.length === "number" || $util.isString(message.readKey)))
                    return "readKey: buffer expected";
            if (message.sharingKey != null && message.hasOwnProperty("sharingKey"))
                if (!(message.sharingKey && typeof message.sharingKey.length === "number" || $util.isString(message.sharingKey)))
                    return "sharingKey: buffer expected";
            if (message.boxKey != null && message.hasOwnProperty("boxKey"))
                if (!(message.boxKey && typeof message.boxKey.length === "number" || $util.isString(message.boxKey)))
                    return "boxKey: buffer expected";
            return null;
        };

        /**
         * Creates a DelegatedKeys message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.DelegatedKeys
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.DelegatedKeys} DelegatedKeys
         */
        DelegatedKeys.fromObject = function fromObject(object) {
            if (object instanceof $root.api.DelegatedKeys)
                return object;
            var message = new $root.api.DelegatedKeys();
            if (object.login != null)
                message.login = String(object.login);
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.signKey != null)
                if (typeof object.signKey === "string")
                    $util.base64.decode(object.signKey, message.signKey = $util.newBuffer($util.base64.length(object.signKey)), 0);
                else if (object.signKey.length)
                    message.signKey = object.signKey;
            if (object.readKey != null)
                if (typeof object.readKey === "string")
                    $util.base64.decode(object.readKey, message.readKey = $util.newBuffer($util.base64.length(object.readKey)), 0);
                else if (object.readKey.length)
                    message.readKey = object.readKey;
            if (object.sharingKey != null)
                if (typeof object.sharingKey === "string")
                    $util.base64.decode(object.sharingKey, message.sharingKey = $util.newBuffer($util.base64.length(object.sharingKey)), 0);
                else if (object.sharingKey.length)
                    message.sharingKey = object.sharingKey;
            if (object.boxKey != null)
                if (typeof object.boxKey === "string")
                    $util.base64.decode(object.boxKey, message.boxKey = $util.newBuffer($util.base64.length(object.boxKey)), 0);
                else if (object.boxKey.length)
                    message.boxKey = object.boxKey;
            return message;
        };

        /**
         * Creates a plain object from a DelegatedKeys message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.DelegatedKeys
         * @static
         * @param {api.DelegatedKeys} message DelegatedKeys
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelegatedKeys.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.version = 0;
                if (options.bytes === String)
                    object.signKey = "";
                else {
                    object.signKey = [];
                    if (options.bytes !== Array)
                        object.signKey = $util.newBuffer(object.signKey);
                }
                if (options.bytes === String)
                    object.readKey = "";
                else {
                    object.readKey = [];
                    if (options.bytes !== Array)
                        object.readKey = $util.newBuffer(object.readKey);
                }
                if (options.bytes === String)
                    object.sharingKey = "";
                else {
                    object.sharingKey = [];
                    if (options.bytes !== Array)
                        object.sharingKey = $util.newBuffer(object.sharingKey);
                }
                if (options.bytes === String)
                    object.boxKey = "";
                else {
                    object.boxKey = [];
                    if (options.bytes !== Array)
                        object.boxKey = $util.newBuffer(object.boxKey);
                }
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.signKey != null && message.hasOwnProperty("signKey"))
                object.signKey = options.bytes === String ? $util.base64.encode(message.signKey, 0, message.signKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.signKey) : message.signKey;
            if (message.readKey != null && message.hasOwnProperty("readKey"))
                object.readKey = options.bytes === String ? $util.base64.encode(message.readKey, 0, message.readKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.readKey) : message.readKey;
            if (message.sharingKey != null && message.hasOwnProperty("sharingKey"))
                object.sharingKey = options.bytes === String ? $util.base64.encode(message.sharingKey, 0, message.sharingKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.sharingKey) : message.sharingKey;
            if (message.boxKey != null && message.hasOwnProperty("boxKey"))
                object.boxKey = options.bytes === String ? $util.base64.encode(message.boxKey, 0, message.boxKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.boxKey) : message.boxKey;
            return object;
        };

        /**
         * Converts this DelegatedKeys to JSON.
         * @function toJSON
         * @memberof api.DelegatedKeys
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelegatedKeys.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelegatedKeys;
    })();

    api.DelegatedGetKeysResponse = (function() {

        /**
         * Properties of a DelegatedGetKeysResponse.
         * @memberof api
         * @interface IDelegatedGetKeysResponse
         * @property {Uint8Array|null} [keys] DelegatedGetKeysResponse keys
         */

        /**
         * Constructs a new DelegatedGetKeysResponse.
         * @memberof api
         * @classdesc Represents a DelegatedGetKeysResponse.
         * @implements IDelegatedGetKeysResponse
         * @constructor
         * @param {api.IDelegatedGetKeysResponse=} [properties] Properties to set
         */
        function DelegatedGetKeysResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelegatedGetKeysResponse keys.
         * @member {Uint8Array} keys
         * @memberof api.DelegatedGetKeysResponse
         * @instance
         */
        DelegatedGetKeysResponse.prototype.keys = $util.newBuffer([]);

        /**
         * Creates a new DelegatedGetKeysResponse instance using the specified properties.
         * @function create
         * @memberof api.DelegatedGetKeysResponse
         * @static
         * @param {api.IDelegatedGetKeysResponse=} [properties] Properties to set
         * @returns {api.DelegatedGetKeysResponse} DelegatedGetKeysResponse instance
         */
        DelegatedGetKeysResponse.create = function create(properties) {
            return new DelegatedGetKeysResponse(properties);
        };

        /**
         * Encodes the specified DelegatedGetKeysResponse message. Does not implicitly {@link api.DelegatedGetKeysResponse.verify|verify} messages.
         * @function encode
         * @memberof api.DelegatedGetKeysResponse
         * @static
         * @param {api.IDelegatedGetKeysResponse} message DelegatedGetKeysResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedGetKeysResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keys != null && message.hasOwnProperty("keys"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.keys);
            return writer;
        };

        /**
         * Encodes the specified DelegatedGetKeysResponse message, length delimited. Does not implicitly {@link api.DelegatedGetKeysResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.DelegatedGetKeysResponse
         * @static
         * @param {api.IDelegatedGetKeysResponse} message DelegatedGetKeysResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedGetKeysResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelegatedGetKeysResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.DelegatedGetKeysResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.DelegatedGetKeysResponse} DelegatedGetKeysResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedGetKeysResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DelegatedGetKeysResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keys = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelegatedGetKeysResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.DelegatedGetKeysResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.DelegatedGetKeysResponse} DelegatedGetKeysResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedGetKeysResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelegatedGetKeysResponse message.
         * @function verify
         * @memberof api.DelegatedGetKeysResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelegatedGetKeysResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keys != null && message.hasOwnProperty("keys"))
                if (!(message.keys && typeof message.keys.length === "number" || $util.isString(message.keys)))
                    return "keys: buffer expected";
            return null;
        };

        /**
         * Creates a DelegatedGetKeysResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.DelegatedGetKeysResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.DelegatedGetKeysResponse} DelegatedGetKeysResponse
         */
        DelegatedGetKeysResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.DelegatedGetKeysResponse)
                return object;
            var message = new $root.api.DelegatedGetKeysResponse();
            if (object.keys != null)
                if (typeof object.keys === "string")
                    $util.base64.decode(object.keys, message.keys = $util.newBuffer($util.base64.length(object.keys)), 0);
                else if (object.keys.length)
                    message.keys = object.keys;
            return message;
        };

        /**
         * Creates a plain object from a DelegatedGetKeysResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.DelegatedGetKeysResponse
         * @static
         * @param {api.DelegatedGetKeysResponse} message DelegatedGetKeysResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelegatedGetKeysResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.keys = "";
                else {
                    object.keys = [];
                    if (options.bytes !== Array)
                        object.keys = $util.newBuffer(object.keys);
                }
            if (message.keys != null && message.hasOwnProperty("keys"))
                object.keys = options.bytes === String ? $util.base64.encode(message.keys, 0, message.keys.length) : options.bytes === Array ? Array.prototype.slice.call(message.keys) : message.keys;
            return object;
        };

        /**
         * Converts this DelegatedGetKeysResponse to JSON.
         * @function toJSON
         * @memberof api.DelegatedGetKeysResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelegatedGetKeysResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelegatedGetKeysResponse;
    })();

    api.DelegatedPostKeysRequest = (function() {

        /**
         * Properties of a DelegatedPostKeysRequest.
         * @memberof api
         * @interface IDelegatedPostKeysRequest
         * @property {number|Long|null} [DelegatedID] DelegatedPostKeysRequest DelegatedID
         * @property {Uint8Array|null} [keys] DelegatedPostKeysRequest keys
         */

        /**
         * Constructs a new DelegatedPostKeysRequest.
         * @memberof api
         * @classdesc Represents a DelegatedPostKeysRequest.
         * @implements IDelegatedPostKeysRequest
         * @constructor
         * @param {api.IDelegatedPostKeysRequest=} [properties] Properties to set
         */
        function DelegatedPostKeysRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelegatedPostKeysRequest DelegatedID.
         * @member {number|Long} DelegatedID
         * @memberof api.DelegatedPostKeysRequest
         * @instance
         */
        DelegatedPostKeysRequest.prototype.DelegatedID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * DelegatedPostKeysRequest keys.
         * @member {Uint8Array} keys
         * @memberof api.DelegatedPostKeysRequest
         * @instance
         */
        DelegatedPostKeysRequest.prototype.keys = $util.newBuffer([]);

        /**
         * Creates a new DelegatedPostKeysRequest instance using the specified properties.
         * @function create
         * @memberof api.DelegatedPostKeysRequest
         * @static
         * @param {api.IDelegatedPostKeysRequest=} [properties] Properties to set
         * @returns {api.DelegatedPostKeysRequest} DelegatedPostKeysRequest instance
         */
        DelegatedPostKeysRequest.create = function create(properties) {
            return new DelegatedPostKeysRequest(properties);
        };

        /**
         * Encodes the specified DelegatedPostKeysRequest message. Does not implicitly {@link api.DelegatedPostKeysRequest.verify|verify} messages.
         * @function encode
         * @memberof api.DelegatedPostKeysRequest
         * @static
         * @param {api.IDelegatedPostKeysRequest} message DelegatedPostKeysRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedPostKeysRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.DelegatedID != null && message.hasOwnProperty("DelegatedID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.DelegatedID);
            if (message.keys != null && message.hasOwnProperty("keys"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.keys);
            return writer;
        };

        /**
         * Encodes the specified DelegatedPostKeysRequest message, length delimited. Does not implicitly {@link api.DelegatedPostKeysRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.DelegatedPostKeysRequest
         * @static
         * @param {api.IDelegatedPostKeysRequest} message DelegatedPostKeysRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedPostKeysRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelegatedPostKeysRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.DelegatedPostKeysRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.DelegatedPostKeysRequest} DelegatedPostKeysRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedPostKeysRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DelegatedPostKeysRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.DelegatedID = reader.uint64();
                    break;
                case 2:
                    message.keys = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelegatedPostKeysRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.DelegatedPostKeysRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.DelegatedPostKeysRequest} DelegatedPostKeysRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedPostKeysRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelegatedPostKeysRequest message.
         * @function verify
         * @memberof api.DelegatedPostKeysRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelegatedPostKeysRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.DelegatedID != null && message.hasOwnProperty("DelegatedID"))
                if (!$util.isInteger(message.DelegatedID) && !(message.DelegatedID && $util.isInteger(message.DelegatedID.low) && $util.isInteger(message.DelegatedID.high)))
                    return "DelegatedID: integer|Long expected";
            if (message.keys != null && message.hasOwnProperty("keys"))
                if (!(message.keys && typeof message.keys.length === "number" || $util.isString(message.keys)))
                    return "keys: buffer expected";
            return null;
        };

        /**
         * Creates a DelegatedPostKeysRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.DelegatedPostKeysRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.DelegatedPostKeysRequest} DelegatedPostKeysRequest
         */
        DelegatedPostKeysRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.DelegatedPostKeysRequest)
                return object;
            var message = new $root.api.DelegatedPostKeysRequest();
            if (object.DelegatedID != null)
                if ($util.Long)
                    (message.DelegatedID = $util.Long.fromValue(object.DelegatedID)).unsigned = true;
                else if (typeof object.DelegatedID === "string")
                    message.DelegatedID = parseInt(object.DelegatedID, 10);
                else if (typeof object.DelegatedID === "number")
                    message.DelegatedID = object.DelegatedID;
                else if (typeof object.DelegatedID === "object")
                    message.DelegatedID = new $util.LongBits(object.DelegatedID.low >>> 0, object.DelegatedID.high >>> 0).toNumber(true);
            if (object.keys != null)
                if (typeof object.keys === "string")
                    $util.base64.decode(object.keys, message.keys = $util.newBuffer($util.base64.length(object.keys)), 0);
                else if (object.keys.length)
                    message.keys = object.keys;
            return message;
        };

        /**
         * Creates a plain object from a DelegatedPostKeysRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.DelegatedPostKeysRequest
         * @static
         * @param {api.DelegatedPostKeysRequest} message DelegatedPostKeysRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelegatedPostKeysRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.DelegatedID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.DelegatedID = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.keys = "";
                else {
                    object.keys = [];
                    if (options.bytes !== Array)
                        object.keys = $util.newBuffer(object.keys);
                }
            }
            if (message.DelegatedID != null && message.hasOwnProperty("DelegatedID"))
                if (typeof message.DelegatedID === "number")
                    object.DelegatedID = options.longs === String ? String(message.DelegatedID) : message.DelegatedID;
                else
                    object.DelegatedID = options.longs === String ? $util.Long.prototype.toString.call(message.DelegatedID) : options.longs === Number ? new $util.LongBits(message.DelegatedID.low >>> 0, message.DelegatedID.high >>> 0).toNumber(true) : message.DelegatedID;
            if (message.keys != null && message.hasOwnProperty("keys"))
                object.keys = options.bytes === String ? $util.base64.encode(message.keys, 0, message.keys.length) : options.bytes === Array ? Array.prototype.slice.call(message.keys) : message.keys;
            return object;
        };

        /**
         * Converts this DelegatedPostKeysRequest to JSON.
         * @function toJSON
         * @memberof api.DelegatedPostKeysRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelegatedPostKeysRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelegatedPostKeysRequest;
    })();

    api.DelegatedAccess = (function() {

        /**
         * Properties of a DelegatedAccess.
         * @memberof api
         * @interface IDelegatedAccess
         * @property {number|Long|null} [id] DelegatedAccess id
         * @property {Uint8Array|null} [publicKey] DelegatedAccess publicKey
         * @property {Uint8Array|null} [sign] DelegatedAccess sign
         * @property {api.IIdentityKeyID|null} [requester] DelegatedAccess requester
         * @property {api.IIdentityKeyID|null} [target] DelegatedAccess target
         * @property {number|Long|null} [created] DelegatedAccess created
         * @property {boolean|null} [resolved] DelegatedAccess resolved
         */

        /**
         * Constructs a new DelegatedAccess.
         * @memberof api
         * @classdesc Represents a DelegatedAccess.
         * @implements IDelegatedAccess
         * @constructor
         * @param {api.IDelegatedAccess=} [properties] Properties to set
         */
        function DelegatedAccess(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelegatedAccess id.
         * @member {number|Long} id
         * @memberof api.DelegatedAccess
         * @instance
         */
        DelegatedAccess.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * DelegatedAccess publicKey.
         * @member {Uint8Array} publicKey
         * @memberof api.DelegatedAccess
         * @instance
         */
        DelegatedAccess.prototype.publicKey = $util.newBuffer([]);

        /**
         * DelegatedAccess sign.
         * @member {Uint8Array} sign
         * @memberof api.DelegatedAccess
         * @instance
         */
        DelegatedAccess.prototype.sign = $util.newBuffer([]);

        /**
         * DelegatedAccess requester.
         * @member {api.IIdentityKeyID|null|undefined} requester
         * @memberof api.DelegatedAccess
         * @instance
         */
        DelegatedAccess.prototype.requester = null;

        /**
         * DelegatedAccess target.
         * @member {api.IIdentityKeyID|null|undefined} target
         * @memberof api.DelegatedAccess
         * @instance
         */
        DelegatedAccess.prototype.target = null;

        /**
         * DelegatedAccess created.
         * @member {number|Long} created
         * @memberof api.DelegatedAccess
         * @instance
         */
        DelegatedAccess.prototype.created = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DelegatedAccess resolved.
         * @member {boolean} resolved
         * @memberof api.DelegatedAccess
         * @instance
         */
        DelegatedAccess.prototype.resolved = false;

        /**
         * Creates a new DelegatedAccess instance using the specified properties.
         * @function create
         * @memberof api.DelegatedAccess
         * @static
         * @param {api.IDelegatedAccess=} [properties] Properties to set
         * @returns {api.DelegatedAccess} DelegatedAccess instance
         */
        DelegatedAccess.create = function create(properties) {
            return new DelegatedAccess(properties);
        };

        /**
         * Encodes the specified DelegatedAccess message. Does not implicitly {@link api.DelegatedAccess.verify|verify} messages.
         * @function encode
         * @memberof api.DelegatedAccess
         * @static
         * @param {api.IDelegatedAccess} message DelegatedAccess message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedAccess.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.publicKey);
            if (message.sign != null && message.hasOwnProperty("sign"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.sign);
            if (message.requester != null && message.hasOwnProperty("requester"))
                $root.api.IdentityKeyID.encode(message.requester, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.target != null && message.hasOwnProperty("target"))
                $root.api.IdentityKeyID.encode(message.target, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.created != null && message.hasOwnProperty("created"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.created);
            if (message.resolved != null && message.hasOwnProperty("resolved"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.resolved);
            return writer;
        };

        /**
         * Encodes the specified DelegatedAccess message, length delimited. Does not implicitly {@link api.DelegatedAccess.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.DelegatedAccess
         * @static
         * @param {api.IDelegatedAccess} message DelegatedAccess message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedAccess.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelegatedAccess message from the specified reader or buffer.
         * @function decode
         * @memberof api.DelegatedAccess
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.DelegatedAccess} DelegatedAccess
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedAccess.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DelegatedAccess();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                case 2:
                    message.publicKey = reader.bytes();
                    break;
                case 3:
                    message.sign = reader.bytes();
                    break;
                case 4:
                    message.requester = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.target = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.created = reader.int64();
                    break;
                case 7:
                    message.resolved = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelegatedAccess message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.DelegatedAccess
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.DelegatedAccess} DelegatedAccess
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedAccess.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelegatedAccess message.
         * @function verify
         * @memberof api.DelegatedAccess
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelegatedAccess.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.sign != null && message.hasOwnProperty("sign"))
                if (!(message.sign && typeof message.sign.length === "number" || $util.isString(message.sign)))
                    return "sign: buffer expected";
            if (message.requester != null && message.hasOwnProperty("requester")) {
                var error = $root.api.IdentityKeyID.verify(message.requester);
                if (error)
                    return "requester." + error;
            }
            if (message.target != null && message.hasOwnProperty("target")) {
                var error = $root.api.IdentityKeyID.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.created != null && message.hasOwnProperty("created"))
                if (!$util.isInteger(message.created) && !(message.created && $util.isInteger(message.created.low) && $util.isInteger(message.created.high)))
                    return "created: integer|Long expected";
            if (message.resolved != null && message.hasOwnProperty("resolved"))
                if (typeof message.resolved !== "boolean")
                    return "resolved: boolean expected";
            return null;
        };

        /**
         * Creates a DelegatedAccess message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.DelegatedAccess
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.DelegatedAccess} DelegatedAccess
         */
        DelegatedAccess.fromObject = function fromObject(object) {
            if (object instanceof $root.api.DelegatedAccess)
                return object;
            var message = new $root.api.DelegatedAccess();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.sign != null)
                if (typeof object.sign === "string")
                    $util.base64.decode(object.sign, message.sign = $util.newBuffer($util.base64.length(object.sign)), 0);
                else if (object.sign.length)
                    message.sign = object.sign;
            if (object.requester != null) {
                if (typeof object.requester !== "object")
                    throw TypeError(".api.DelegatedAccess.requester: object expected");
                message.requester = $root.api.IdentityKeyID.fromObject(object.requester);
            }
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".api.DelegatedAccess.target: object expected");
                message.target = $root.api.IdentityKeyID.fromObject(object.target);
            }
            if (object.created != null)
                if ($util.Long)
                    (message.created = $util.Long.fromValue(object.created)).unsigned = false;
                else if (typeof object.created === "string")
                    message.created = parseInt(object.created, 10);
                else if (typeof object.created === "number")
                    message.created = object.created;
                else if (typeof object.created === "object")
                    message.created = new $util.LongBits(object.created.low >>> 0, object.created.high >>> 0).toNumber();
            if (object.resolved != null)
                message.resolved = Boolean(object.resolved);
            return message;
        };

        /**
         * Creates a plain object from a DelegatedAccess message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.DelegatedAccess
         * @static
         * @param {api.DelegatedAccess} message DelegatedAccess
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelegatedAccess.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                if (options.bytes === String)
                    object.sign = "";
                else {
                    object.sign = [];
                    if (options.bytes !== Array)
                        object.sign = $util.newBuffer(object.sign);
                }
                object.requester = null;
                object.target = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.created = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.created = options.longs === String ? "0" : 0;
                object.resolved = false;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.sign != null && message.hasOwnProperty("sign"))
                object.sign = options.bytes === String ? $util.base64.encode(message.sign, 0, message.sign.length) : options.bytes === Array ? Array.prototype.slice.call(message.sign) : message.sign;
            if (message.requester != null && message.hasOwnProperty("requester"))
                object.requester = $root.api.IdentityKeyID.toObject(message.requester, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.api.IdentityKeyID.toObject(message.target, options);
            if (message.created != null && message.hasOwnProperty("created"))
                if (typeof message.created === "number")
                    object.created = options.longs === String ? String(message.created) : message.created;
                else
                    object.created = options.longs === String ? $util.Long.prototype.toString.call(message.created) : options.longs === Number ? new $util.LongBits(message.created.low >>> 0, message.created.high >>> 0).toNumber() : message.created;
            if (message.resolved != null && message.hasOwnProperty("resolved"))
                object.resolved = message.resolved;
            return object;
        };

        /**
         * Converts this DelegatedAccess to JSON.
         * @function toJSON
         * @memberof api.DelegatedAccess
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelegatedAccess.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelegatedAccess;
    })();

    api.DelegatedAccessListResponse = (function() {

        /**
         * Properties of a DelegatedAccessListResponse.
         * @memberof api
         * @interface IDelegatedAccessListResponse
         * @property {Array.<api.IDelegatedAccess>|null} [accesses] DelegatedAccessListResponse accesses
         */

        /**
         * Constructs a new DelegatedAccessListResponse.
         * @memberof api
         * @classdesc Represents a DelegatedAccessListResponse.
         * @implements IDelegatedAccessListResponse
         * @constructor
         * @param {api.IDelegatedAccessListResponse=} [properties] Properties to set
         */
        function DelegatedAccessListResponse(properties) {
            this.accesses = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelegatedAccessListResponse accesses.
         * @member {Array.<api.IDelegatedAccess>} accesses
         * @memberof api.DelegatedAccessListResponse
         * @instance
         */
        DelegatedAccessListResponse.prototype.accesses = $util.emptyArray;

        /**
         * Creates a new DelegatedAccessListResponse instance using the specified properties.
         * @function create
         * @memberof api.DelegatedAccessListResponse
         * @static
         * @param {api.IDelegatedAccessListResponse=} [properties] Properties to set
         * @returns {api.DelegatedAccessListResponse} DelegatedAccessListResponse instance
         */
        DelegatedAccessListResponse.create = function create(properties) {
            return new DelegatedAccessListResponse(properties);
        };

        /**
         * Encodes the specified DelegatedAccessListResponse message. Does not implicitly {@link api.DelegatedAccessListResponse.verify|verify} messages.
         * @function encode
         * @memberof api.DelegatedAccessListResponse
         * @static
         * @param {api.IDelegatedAccessListResponse} message DelegatedAccessListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedAccessListResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accesses != null && message.accesses.length)
                for (var i = 0; i < message.accesses.length; ++i)
                    $root.api.DelegatedAccess.encode(message.accesses[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DelegatedAccessListResponse message, length delimited. Does not implicitly {@link api.DelegatedAccessListResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.DelegatedAccessListResponse
         * @static
         * @param {api.IDelegatedAccessListResponse} message DelegatedAccessListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedAccessListResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelegatedAccessListResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.DelegatedAccessListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.DelegatedAccessListResponse} DelegatedAccessListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedAccessListResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DelegatedAccessListResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.accesses && message.accesses.length))
                        message.accesses = [];
                    message.accesses.push($root.api.DelegatedAccess.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelegatedAccessListResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.DelegatedAccessListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.DelegatedAccessListResponse} DelegatedAccessListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedAccessListResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelegatedAccessListResponse message.
         * @function verify
         * @memberof api.DelegatedAccessListResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelegatedAccessListResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.accesses != null && message.hasOwnProperty("accesses")) {
                if (!Array.isArray(message.accesses))
                    return "accesses: array expected";
                for (var i = 0; i < message.accesses.length; ++i) {
                    var error = $root.api.DelegatedAccess.verify(message.accesses[i]);
                    if (error)
                        return "accesses." + error;
                }
            }
            return null;
        };

        /**
         * Creates a DelegatedAccessListResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.DelegatedAccessListResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.DelegatedAccessListResponse} DelegatedAccessListResponse
         */
        DelegatedAccessListResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.DelegatedAccessListResponse)
                return object;
            var message = new $root.api.DelegatedAccessListResponse();
            if (object.accesses) {
                if (!Array.isArray(object.accesses))
                    throw TypeError(".api.DelegatedAccessListResponse.accesses: array expected");
                message.accesses = [];
                for (var i = 0; i < object.accesses.length; ++i) {
                    if (typeof object.accesses[i] !== "object")
                        throw TypeError(".api.DelegatedAccessListResponse.accesses: object expected");
                    message.accesses[i] = $root.api.DelegatedAccess.fromObject(object.accesses[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a DelegatedAccessListResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.DelegatedAccessListResponse
         * @static
         * @param {api.DelegatedAccessListResponse} message DelegatedAccessListResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelegatedAccessListResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.accesses = [];
            if (message.accesses && message.accesses.length) {
                object.accesses = [];
                for (var j = 0; j < message.accesses.length; ++j)
                    object.accesses[j] = $root.api.DelegatedAccess.toObject(message.accesses[j], options);
            }
            return object;
        };

        /**
         * Converts this DelegatedAccessListResponse to JSON.
         * @function toJSON
         * @memberof api.DelegatedAccessListResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelegatedAccessListResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelegatedAccessListResponse;
    })();

    /**
     * RegisterTokenStatus enum.
     * @name api.RegisterTokenStatus
     * @enum {string}
     * @property {number} PENDING=0 PENDING value
     * @property {number} SENT=1 SENT value
     * @property {number} RECEIVED=2 RECEIVED value
     */
    api.RegisterTokenStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PENDING"] = 0;
        values[valuesById[1] = "SENT"] = 1;
        values[valuesById[2] = "RECEIVED"] = 2;
        return values;
    })();

    api.RegisterEmailValidationToken = (function() {

        /**
         * Properties of a RegisterEmailValidationToken.
         * @memberof api
         * @interface IRegisterEmailValidationToken
         * @property {Uint8Array|null} [token] RegisterEmailValidationToken token
         * @property {string|null} [email] RegisterEmailValidationToken email
         * @property {number|Long|null} [created] RegisterEmailValidationToken created
         * @property {api.RegisterTokenStatus|null} [status] RegisterEmailValidationToken status
         */

        /**
         * Constructs a new RegisterEmailValidationToken.
         * @memberof api
         * @classdesc Represents a RegisterEmailValidationToken.
         * @implements IRegisterEmailValidationToken
         * @constructor
         * @param {api.IRegisterEmailValidationToken=} [properties] Properties to set
         */
        function RegisterEmailValidationToken(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegisterEmailValidationToken token.
         * @member {Uint8Array} token
         * @memberof api.RegisterEmailValidationToken
         * @instance
         */
        RegisterEmailValidationToken.prototype.token = $util.newBuffer([]);

        /**
         * RegisterEmailValidationToken email.
         * @member {string} email
         * @memberof api.RegisterEmailValidationToken
         * @instance
         */
        RegisterEmailValidationToken.prototype.email = "";

        /**
         * RegisterEmailValidationToken created.
         * @member {number|Long} created
         * @memberof api.RegisterEmailValidationToken
         * @instance
         */
        RegisterEmailValidationToken.prototype.created = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RegisterEmailValidationToken status.
         * @member {api.RegisterTokenStatus} status
         * @memberof api.RegisterEmailValidationToken
         * @instance
         */
        RegisterEmailValidationToken.prototype.status = 0;

        /**
         * Creates a new RegisterEmailValidationToken instance using the specified properties.
         * @function create
         * @memberof api.RegisterEmailValidationToken
         * @static
         * @param {api.IRegisterEmailValidationToken=} [properties] Properties to set
         * @returns {api.RegisterEmailValidationToken} RegisterEmailValidationToken instance
         */
        RegisterEmailValidationToken.create = function create(properties) {
            return new RegisterEmailValidationToken(properties);
        };

        /**
         * Encodes the specified RegisterEmailValidationToken message. Does not implicitly {@link api.RegisterEmailValidationToken.verify|verify} messages.
         * @function encode
         * @memberof api.RegisterEmailValidationToken
         * @static
         * @param {api.IRegisterEmailValidationToken} message RegisterEmailValidationToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterEmailValidationToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.token != null && message.hasOwnProperty("token"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.token);
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.email);
            if (message.created != null && message.hasOwnProperty("created"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.created);
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.status);
            return writer;
        };

        /**
         * Encodes the specified RegisterEmailValidationToken message, length delimited. Does not implicitly {@link api.RegisterEmailValidationToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.RegisterEmailValidationToken
         * @static
         * @param {api.IRegisterEmailValidationToken} message RegisterEmailValidationToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterEmailValidationToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterEmailValidationToken message from the specified reader or buffer.
         * @function decode
         * @memberof api.RegisterEmailValidationToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.RegisterEmailValidationToken} RegisterEmailValidationToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterEmailValidationToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.RegisterEmailValidationToken();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.token = reader.bytes();
                    break;
                case 2:
                    message.email = reader.string();
                    break;
                case 3:
                    message.created = reader.int64();
                    break;
                case 4:
                    message.status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterEmailValidationToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.RegisterEmailValidationToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.RegisterEmailValidationToken} RegisterEmailValidationToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterEmailValidationToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterEmailValidationToken message.
         * @function verify
         * @memberof api.RegisterEmailValidationToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterEmailValidationToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                    return "token: buffer expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.created != null && message.hasOwnProperty("created"))
                if (!$util.isInteger(message.created) && !(message.created && $util.isInteger(message.created.low) && $util.isInteger(message.created.high)))
                    return "created: integer|Long expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a RegisterEmailValidationToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.RegisterEmailValidationToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.RegisterEmailValidationToken} RegisterEmailValidationToken
         */
        RegisterEmailValidationToken.fromObject = function fromObject(object) {
            if (object instanceof $root.api.RegisterEmailValidationToken)
                return object;
            var message = new $root.api.RegisterEmailValidationToken();
            if (object.token != null)
                if (typeof object.token === "string")
                    $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                else if (object.token.length)
                    message.token = object.token;
            if (object.email != null)
                message.email = String(object.email);
            if (object.created != null)
                if ($util.Long)
                    (message.created = $util.Long.fromValue(object.created)).unsigned = false;
                else if (typeof object.created === "string")
                    message.created = parseInt(object.created, 10);
                else if (typeof object.created === "number")
                    message.created = object.created;
                else if (typeof object.created === "object")
                    message.created = new $util.LongBits(object.created.low >>> 0, object.created.high >>> 0).toNumber();
            switch (object.status) {
            case "PENDING":
            case 0:
                message.status = 0;
                break;
            case "SENT":
            case 1:
                message.status = 1;
                break;
            case "RECEIVED":
            case 2:
                message.status = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a RegisterEmailValidationToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.RegisterEmailValidationToken
         * @static
         * @param {api.RegisterEmailValidationToken} message RegisterEmailValidationToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegisterEmailValidationToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.token = "";
                else {
                    object.token = [];
                    if (options.bytes !== Array)
                        object.token = $util.newBuffer(object.token);
                }
                object.email = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.created = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.created = options.longs === String ? "0" : 0;
                object.status = options.enums === String ? "PENDING" : 0;
            }
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.created != null && message.hasOwnProperty("created"))
                if (typeof message.created === "number")
                    object.created = options.longs === String ? String(message.created) : message.created;
                else
                    object.created = options.longs === String ? $util.Long.prototype.toString.call(message.created) : options.longs === Number ? new $util.LongBits(message.created.low >>> 0, message.created.high >>> 0).toNumber() : message.created;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.api.RegisterTokenStatus[message.status] : message.status;
            return object;
        };

        /**
         * Converts this RegisterEmailValidationToken to JSON.
         * @function toJSON
         * @memberof api.RegisterEmailValidationToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegisterEmailValidationToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegisterEmailValidationToken;
    })();

    api.RegisterLinkRequest = (function() {

        /**
         * Properties of a RegisterLinkRequest.
         * @memberof api
         * @interface IRegisterLinkRequest
         * @property {string|null} [email] RegisterLinkRequest email
         */

        /**
         * Constructs a new RegisterLinkRequest.
         * @memberof api
         * @classdesc Represents a RegisterLinkRequest.
         * @implements IRegisterLinkRequest
         * @constructor
         * @param {api.IRegisterLinkRequest=} [properties] Properties to set
         */
        function RegisterLinkRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegisterLinkRequest email.
         * @member {string} email
         * @memberof api.RegisterLinkRequest
         * @instance
         */
        RegisterLinkRequest.prototype.email = "";

        /**
         * Creates a new RegisterLinkRequest instance using the specified properties.
         * @function create
         * @memberof api.RegisterLinkRequest
         * @static
         * @param {api.IRegisterLinkRequest=} [properties] Properties to set
         * @returns {api.RegisterLinkRequest} RegisterLinkRequest instance
         */
        RegisterLinkRequest.create = function create(properties) {
            return new RegisterLinkRequest(properties);
        };

        /**
         * Encodes the specified RegisterLinkRequest message. Does not implicitly {@link api.RegisterLinkRequest.verify|verify} messages.
         * @function encode
         * @memberof api.RegisterLinkRequest
         * @static
         * @param {api.IRegisterLinkRequest} message RegisterLinkRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterLinkRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.email);
            return writer;
        };

        /**
         * Encodes the specified RegisterLinkRequest message, length delimited. Does not implicitly {@link api.RegisterLinkRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.RegisterLinkRequest
         * @static
         * @param {api.IRegisterLinkRequest} message RegisterLinkRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterLinkRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterLinkRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.RegisterLinkRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.RegisterLinkRequest} RegisterLinkRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterLinkRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.RegisterLinkRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterLinkRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.RegisterLinkRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.RegisterLinkRequest} RegisterLinkRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterLinkRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterLinkRequest message.
         * @function verify
         * @memberof api.RegisterLinkRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterLinkRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            return null;
        };

        /**
         * Creates a RegisterLinkRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.RegisterLinkRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.RegisterLinkRequest} RegisterLinkRequest
         */
        RegisterLinkRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.RegisterLinkRequest)
                return object;
            var message = new $root.api.RegisterLinkRequest();
            if (object.email != null)
                message.email = String(object.email);
            return message;
        };

        /**
         * Creates a plain object from a RegisterLinkRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.RegisterLinkRequest
         * @static
         * @param {api.RegisterLinkRequest} message RegisterLinkRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegisterLinkRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.email = "";
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            return object;
        };

        /**
         * Converts this RegisterLinkRequest to JSON.
         * @function toJSON
         * @memberof api.RegisterLinkRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegisterLinkRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegisterLinkRequest;
    })();

    api.LinksGetResponse = (function() {

        /**
         * Properties of a LinksGetResponse.
         * @memberof api
         * @interface ILinksGetResponse
         * @property {Array.<api.IRegisterEmailValidationToken>|null} [links] LinksGetResponse links
         */

        /**
         * Constructs a new LinksGetResponse.
         * @memberof api
         * @classdesc Represents a LinksGetResponse.
         * @implements ILinksGetResponse
         * @constructor
         * @param {api.ILinksGetResponse=} [properties] Properties to set
         */
        function LinksGetResponse(properties) {
            this.links = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LinksGetResponse links.
         * @member {Array.<api.IRegisterEmailValidationToken>} links
         * @memberof api.LinksGetResponse
         * @instance
         */
        LinksGetResponse.prototype.links = $util.emptyArray;

        /**
         * Creates a new LinksGetResponse instance using the specified properties.
         * @function create
         * @memberof api.LinksGetResponse
         * @static
         * @param {api.ILinksGetResponse=} [properties] Properties to set
         * @returns {api.LinksGetResponse} LinksGetResponse instance
         */
        LinksGetResponse.create = function create(properties) {
            return new LinksGetResponse(properties);
        };

        /**
         * Encodes the specified LinksGetResponse message. Does not implicitly {@link api.LinksGetResponse.verify|verify} messages.
         * @function encode
         * @memberof api.LinksGetResponse
         * @static
         * @param {api.ILinksGetResponse} message LinksGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LinksGetResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.links != null && message.links.length)
                for (var i = 0; i < message.links.length; ++i)
                    $root.api.RegisterEmailValidationToken.encode(message.links[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LinksGetResponse message, length delimited. Does not implicitly {@link api.LinksGetResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.LinksGetResponse
         * @static
         * @param {api.ILinksGetResponse} message LinksGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LinksGetResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LinksGetResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.LinksGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.LinksGetResponse} LinksGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LinksGetResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.LinksGetResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.links && message.links.length))
                        message.links = [];
                    message.links.push($root.api.RegisterEmailValidationToken.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LinksGetResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.LinksGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.LinksGetResponse} LinksGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LinksGetResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LinksGetResponse message.
         * @function verify
         * @memberof api.LinksGetResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LinksGetResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.links != null && message.hasOwnProperty("links")) {
                if (!Array.isArray(message.links))
                    return "links: array expected";
                for (var i = 0; i < message.links.length; ++i) {
                    var error = $root.api.RegisterEmailValidationToken.verify(message.links[i]);
                    if (error)
                        return "links." + error;
                }
            }
            return null;
        };

        /**
         * Creates a LinksGetResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.LinksGetResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.LinksGetResponse} LinksGetResponse
         */
        LinksGetResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.LinksGetResponse)
                return object;
            var message = new $root.api.LinksGetResponse();
            if (object.links) {
                if (!Array.isArray(object.links))
                    throw TypeError(".api.LinksGetResponse.links: array expected");
                message.links = [];
                for (var i = 0; i < object.links.length; ++i) {
                    if (typeof object.links[i] !== "object")
                        throw TypeError(".api.LinksGetResponse.links: object expected");
                    message.links[i] = $root.api.RegisterEmailValidationToken.fromObject(object.links[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a LinksGetResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.LinksGetResponse
         * @static
         * @param {api.LinksGetResponse} message LinksGetResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LinksGetResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.links = [];
            if (message.links && message.links.length) {
                object.links = [];
                for (var j = 0; j < message.links.length; ++j)
                    object.links[j] = $root.api.RegisterEmailValidationToken.toObject(message.links[j], options);
            }
            return object;
        };

        /**
         * Converts this LinksGetResponse to JSON.
         * @function toJSON
         * @memberof api.LinksGetResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LinksGetResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LinksGetResponse;
    })();

    api.LinkTokenGetResponse = (function() {

        /**
         * Properties of a LinkTokenGetResponse.
         * @memberof api
         * @interface ILinkTokenGetResponse
         * @property {string|null} [email] LinkTokenGetResponse email
         */

        /**
         * Constructs a new LinkTokenGetResponse.
         * @memberof api
         * @classdesc Represents a LinkTokenGetResponse.
         * @implements ILinkTokenGetResponse
         * @constructor
         * @param {api.ILinkTokenGetResponse=} [properties] Properties to set
         */
        function LinkTokenGetResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LinkTokenGetResponse email.
         * @member {string} email
         * @memberof api.LinkTokenGetResponse
         * @instance
         */
        LinkTokenGetResponse.prototype.email = "";

        /**
         * Creates a new LinkTokenGetResponse instance using the specified properties.
         * @function create
         * @memberof api.LinkTokenGetResponse
         * @static
         * @param {api.ILinkTokenGetResponse=} [properties] Properties to set
         * @returns {api.LinkTokenGetResponse} LinkTokenGetResponse instance
         */
        LinkTokenGetResponse.create = function create(properties) {
            return new LinkTokenGetResponse(properties);
        };

        /**
         * Encodes the specified LinkTokenGetResponse message. Does not implicitly {@link api.LinkTokenGetResponse.verify|verify} messages.
         * @function encode
         * @memberof api.LinkTokenGetResponse
         * @static
         * @param {api.ILinkTokenGetResponse} message LinkTokenGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LinkTokenGetResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.email);
            return writer;
        };

        /**
         * Encodes the specified LinkTokenGetResponse message, length delimited. Does not implicitly {@link api.LinkTokenGetResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.LinkTokenGetResponse
         * @static
         * @param {api.ILinkTokenGetResponse} message LinkTokenGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LinkTokenGetResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LinkTokenGetResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.LinkTokenGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.LinkTokenGetResponse} LinkTokenGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LinkTokenGetResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.LinkTokenGetResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LinkTokenGetResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.LinkTokenGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.LinkTokenGetResponse} LinkTokenGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LinkTokenGetResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LinkTokenGetResponse message.
         * @function verify
         * @memberof api.LinkTokenGetResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LinkTokenGetResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            return null;
        };

        /**
         * Creates a LinkTokenGetResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.LinkTokenGetResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.LinkTokenGetResponse} LinkTokenGetResponse
         */
        LinkTokenGetResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.LinkTokenGetResponse)
                return object;
            var message = new $root.api.LinkTokenGetResponse();
            if (object.email != null)
                message.email = String(object.email);
            return message;
        };

        /**
         * Creates a plain object from a LinkTokenGetResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.LinkTokenGetResponse
         * @static
         * @param {api.LinkTokenGetResponse} message LinkTokenGetResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LinkTokenGetResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.email = "";
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            return object;
        };

        /**
         * Converts this LinkTokenGetResponse to JSON.
         * @function toJSON
         * @memberof api.LinkTokenGetResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LinkTokenGetResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LinkTokenGetResponse;
    })();

    api.RegisterPostLinkTokenRequest = (function() {

        /**
         * Properties of a RegisterPostLinkTokenRequest.
         * @memberof api
         * @interface IRegisterPostLinkTokenRequest
         * @property {string|null} [token] RegisterPostLinkTokenRequest token
         * @property {api.IIdentityFields|null} [identity] RegisterPostLinkTokenRequest identity
         * @property {api.IIdentityEncryption|null} [encryption] RegisterPostLinkTokenRequest encryption
         */

        /**
         * Constructs a new RegisterPostLinkTokenRequest.
         * @memberof api
         * @classdesc Represents a RegisterPostLinkTokenRequest.
         * @implements IRegisterPostLinkTokenRequest
         * @constructor
         * @param {api.IRegisterPostLinkTokenRequest=} [properties] Properties to set
         */
        function RegisterPostLinkTokenRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegisterPostLinkTokenRequest token.
         * @member {string} token
         * @memberof api.RegisterPostLinkTokenRequest
         * @instance
         */
        RegisterPostLinkTokenRequest.prototype.token = "";

        /**
         * RegisterPostLinkTokenRequest identity.
         * @member {api.IIdentityFields|null|undefined} identity
         * @memberof api.RegisterPostLinkTokenRequest
         * @instance
         */
        RegisterPostLinkTokenRequest.prototype.identity = null;

        /**
         * RegisterPostLinkTokenRequest encryption.
         * @member {api.IIdentityEncryption|null|undefined} encryption
         * @memberof api.RegisterPostLinkTokenRequest
         * @instance
         */
        RegisterPostLinkTokenRequest.prototype.encryption = null;

        /**
         * Creates a new RegisterPostLinkTokenRequest instance using the specified properties.
         * @function create
         * @memberof api.RegisterPostLinkTokenRequest
         * @static
         * @param {api.IRegisterPostLinkTokenRequest=} [properties] Properties to set
         * @returns {api.RegisterPostLinkTokenRequest} RegisterPostLinkTokenRequest instance
         */
        RegisterPostLinkTokenRequest.create = function create(properties) {
            return new RegisterPostLinkTokenRequest(properties);
        };

        /**
         * Encodes the specified RegisterPostLinkTokenRequest message. Does not implicitly {@link api.RegisterPostLinkTokenRequest.verify|verify} messages.
         * @function encode
         * @memberof api.RegisterPostLinkTokenRequest
         * @static
         * @param {api.IRegisterPostLinkTokenRequest} message RegisterPostLinkTokenRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterPostLinkTokenRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.token != null && message.hasOwnProperty("token"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.token);
            if (message.identity != null && message.hasOwnProperty("identity"))
                $root.api.IdentityFields.encode(message.identity, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.api.IdentityEncryption.encode(message.encryption, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RegisterPostLinkTokenRequest message, length delimited. Does not implicitly {@link api.RegisterPostLinkTokenRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.RegisterPostLinkTokenRequest
         * @static
         * @param {api.IRegisterPostLinkTokenRequest} message RegisterPostLinkTokenRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterPostLinkTokenRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterPostLinkTokenRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.RegisterPostLinkTokenRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.RegisterPostLinkTokenRequest} RegisterPostLinkTokenRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterPostLinkTokenRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.RegisterPostLinkTokenRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.token = reader.string();
                    break;
                case 2:
                    message.identity = $root.api.IdentityFields.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.encryption = $root.api.IdentityEncryption.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterPostLinkTokenRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.RegisterPostLinkTokenRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.RegisterPostLinkTokenRequest} RegisterPostLinkTokenRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterPostLinkTokenRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterPostLinkTokenRequest message.
         * @function verify
         * @memberof api.RegisterPostLinkTokenRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterPostLinkTokenRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!$util.isString(message.token))
                    return "token: string expected";
            if (message.identity != null && message.hasOwnProperty("identity")) {
                var error = $root.api.IdentityFields.verify(message.identity);
                if (error)
                    return "identity." + error;
            }
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.api.IdentityEncryption.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            return null;
        };

        /**
         * Creates a RegisterPostLinkTokenRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.RegisterPostLinkTokenRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.RegisterPostLinkTokenRequest} RegisterPostLinkTokenRequest
         */
        RegisterPostLinkTokenRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.RegisterPostLinkTokenRequest)
                return object;
            var message = new $root.api.RegisterPostLinkTokenRequest();
            if (object.token != null)
                message.token = String(object.token);
            if (object.identity != null) {
                if (typeof object.identity !== "object")
                    throw TypeError(".api.RegisterPostLinkTokenRequest.identity: object expected");
                message.identity = $root.api.IdentityFields.fromObject(object.identity);
            }
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".api.RegisterPostLinkTokenRequest.encryption: object expected");
                message.encryption = $root.api.IdentityEncryption.fromObject(object.encryption);
            }
            return message;
        };

        /**
         * Creates a plain object from a RegisterPostLinkTokenRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.RegisterPostLinkTokenRequest
         * @static
         * @param {api.RegisterPostLinkTokenRequest} message RegisterPostLinkTokenRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegisterPostLinkTokenRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.token = "";
                object.identity = null;
                object.encryption = null;
            }
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = message.token;
            if (message.identity != null && message.hasOwnProperty("identity"))
                object.identity = $root.api.IdentityFields.toObject(message.identity, options);
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.api.IdentityEncryption.toObject(message.encryption, options);
            return object;
        };

        /**
         * Converts this RegisterPostLinkTokenRequest to JSON.
         * @function toJSON
         * @memberof api.RegisterPostLinkTokenRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegisterPostLinkTokenRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegisterPostLinkTokenRequest;
    })();

    api.ProtoError = (function() {

        /**
         * Properties of a ProtoError.
         * @memberof api
         * @interface IProtoError
         * @property {number|null} [code] ProtoError code
         * @property {api.PepsErrorKind|null} [kind] ProtoError kind
         * @property {google.protobuf.IAny|null} [payload] ProtoError payload
         */

        /**
         * Constructs a new ProtoError.
         * @memberof api
         * @classdesc Represents a ProtoError.
         * @implements IProtoError
         * @constructor
         * @param {api.IProtoError=} [properties] Properties to set
         */
        function ProtoError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoError code.
         * @member {number} code
         * @memberof api.ProtoError
         * @instance
         */
        ProtoError.prototype.code = 0;

        /**
         * ProtoError kind.
         * @member {api.PepsErrorKind} kind
         * @memberof api.ProtoError
         * @instance
         */
        ProtoError.prototype.kind = 0;

        /**
         * ProtoError payload.
         * @member {google.protobuf.IAny|null|undefined} payload
         * @memberof api.ProtoError
         * @instance
         */
        ProtoError.prototype.payload = null;

        /**
         * Creates a new ProtoError instance using the specified properties.
         * @function create
         * @memberof api.ProtoError
         * @static
         * @param {api.IProtoError=} [properties] Properties to set
         * @returns {api.ProtoError} ProtoError instance
         */
        ProtoError.create = function create(properties) {
            return new ProtoError(properties);
        };

        /**
         * Encodes the specified ProtoError message. Does not implicitly {@link api.ProtoError.verify|verify} messages.
         * @function encode
         * @memberof api.ProtoError
         * @static
         * @param {api.IProtoError} message ProtoError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && message.hasOwnProperty("code"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.code);
            if (message.kind != null && message.hasOwnProperty("kind"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.kind);
            if (message.payload != null && message.hasOwnProperty("payload"))
                $root.google.protobuf.Any.encode(message.payload, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ProtoError message, length delimited. Does not implicitly {@link api.ProtoError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ProtoError
         * @static
         * @param {api.IProtoError} message ProtoError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoError message from the specified reader or buffer.
         * @function decode
         * @memberof api.ProtoError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ProtoError} ProtoError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ProtoError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.uint32();
                    break;
                case 2:
                    message.kind = reader.int32();
                    break;
                case 3:
                    message.payload = $root.google.protobuf.Any.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ProtoError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ProtoError} ProtoError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoError message.
         * @function verify
         * @memberof api.ProtoError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.code != null && message.hasOwnProperty("code"))
                if (!$util.isInteger(message.code))
                    return "code: integer expected";
            if (message.kind != null && message.hasOwnProperty("kind"))
                switch (message.kind) {
                default:
                    return "kind: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 33:
                case 34:
                case 35:
                case 36:
                    break;
                }
            if (message.payload != null && message.hasOwnProperty("payload")) {
                var error = $root.google.protobuf.Any.verify(message.payload);
                if (error)
                    return "payload." + error;
            }
            return null;
        };

        /**
         * Creates a ProtoError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ProtoError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ProtoError} ProtoError
         */
        ProtoError.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ProtoError)
                return object;
            var message = new $root.api.ProtoError();
            if (object.code != null)
                message.code = object.code >>> 0;
            switch (object.kind) {
            case "ServerInternalError":
            case 0:
                message.kind = 0;
                break;
            case "SessionExpired":
            case 1:
                message.kind = 1;
                break;
            case "SessionStale":
            case 2:
                message.kind = 2;
                break;
            case "SessionInvalidSalt":
            case 3:
                message.kind = 3;
                break;
            case "AssumeStale":
            case 4:
                message.kind = 4;
                break;
            case "RequestBadUriParams":
            case 6:
                message.kind = 6;
                break;
            case "RequestMissingHeader":
            case 7:
                message.kind = 7;
                break;
            case "RequestDecodeHeader":
            case 8:
                message.kind = 8;
                break;
            case "RequestBadRequest":
            case 9:
                message.kind = 9;
                break;
            case "IdentityCannotAssumeOwnership":
            case 10:
                message.kind = 10;
                break;
            case "IdentityCannotAssumeAccess":
            case 11:
                message.kind = 11;
                break;
            case "IdentitySignatureMismatch":
            case 12:
                message.kind = 12;
                break;
            case "IdentityInvalidLogin":
            case 13:
                message.kind = 13;
                break;
            case "IdentityAlreadyExists":
            case 14:
                message.kind = 14;
                break;
            case "IdentityNotFound":
            case 15:
                message.kind = 15;
                break;
            case "IdentityVersionMismatch":
            case 16:
                message.kind = 16;
                break;
            case "IdentityNotAdmin":
            case 17:
                message.kind = 17;
                break;
            case "IdentitySharingKindMismatch":
            case 19:
                message.kind = 19;
                break;
            case "IdentityEmailNotAssociated":
            case 20:
                message.kind = 20;
                break;
            case "IdentityEmailAlreadyAssociated":
            case 21:
                message.kind = 21;
                break;
            case "IdentityPrincipalEmailNotSet":
            case 22:
                message.kind = 22;
                break;
            case "IdentityPrincipalEmailAlreadyExists":
            case 23:
                message.kind = 23;
                break;
            case "ResourceNotFound":
            case 24:
                message.kind = 24;
                break;
            case "RegisterInvalidEmail":
            case 25:
                message.kind = 25;
                break;
            case "RegisterTokenNotFound":
            case 26:
                message.kind = 26;
                break;
            case "ChannelNotFound":
            case 27:
                message.kind = 27;
                break;
            case "DelegatedAccessNotFound":
            case 28:
                message.kind = 28;
                break;
            case "InvalidToken":
            case 29:
                message.kind = 29;
                break;
            case "ApplicationConfigNotFound":
            case 33:
                message.kind = 33;
                break;
            case "ApplicationConfigInvalid":
            case 34:
                message.kind = 34;
                break;
            case "NamedResourceNotFound":
            case 35:
                message.kind = 35;
                break;
            case "ApplicationInvalidToken":
            case 36:
                message.kind = 36;
                break;
            }
            if (object.payload != null) {
                if (typeof object.payload !== "object")
                    throw TypeError(".api.ProtoError.payload: object expected");
                message.payload = $root.google.protobuf.Any.fromObject(object.payload);
            }
            return message;
        };

        /**
         * Creates a plain object from a ProtoError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ProtoError
         * @static
         * @param {api.ProtoError} message ProtoError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.code = 0;
                object.kind = options.enums === String ? "ServerInternalError" : 0;
                object.payload = null;
            }
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            if (message.kind != null && message.hasOwnProperty("kind"))
                object.kind = options.enums === String ? $root.api.PepsErrorKind[message.kind] : message.kind;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = $root.google.protobuf.Any.toObject(message.payload, options);
            return object;
        };

        /**
         * Converts this ProtoError to JSON.
         * @function toJSON
         * @memberof api.ProtoError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoError;
    })();

    /**
     * PepsErrorKind enum.
     * @name api.PepsErrorKind
     * @enum {string}
     * @property {number} ServerInternalError=0 ServerInternalError value
     * @property {number} SessionExpired=1 SessionExpired value
     * @property {number} SessionStale=2 SessionStale value
     * @property {number} SessionInvalidSalt=3 SessionInvalidSalt value
     * @property {number} AssumeStale=4 AssumeStale value
     * @property {number} RequestBadUriParams=6 RequestBadUriParams value
     * @property {number} RequestMissingHeader=7 RequestMissingHeader value
     * @property {number} RequestDecodeHeader=8 RequestDecodeHeader value
     * @property {number} RequestBadRequest=9 RequestBadRequest value
     * @property {number} IdentityCannotAssumeOwnership=10 IdentityCannotAssumeOwnership value
     * @property {number} IdentityCannotAssumeAccess=11 IdentityCannotAssumeAccess value
     * @property {number} IdentitySignatureMismatch=12 IdentitySignatureMismatch value
     * @property {number} IdentityInvalidLogin=13 IdentityInvalidLogin value
     * @property {number} IdentityAlreadyExists=14 IdentityAlreadyExists value
     * @property {number} IdentityNotFound=15 IdentityNotFound value
     * @property {number} IdentityVersionMismatch=16 IdentityVersionMismatch value
     * @property {number} IdentityNotAdmin=17 IdentityNotAdmin value
     * @property {number} IdentitySharingKindMismatch=19 IdentitySharingKindMismatch value
     * @property {number} IdentityEmailNotAssociated=20 IdentityEmailNotAssociated value
     * @property {number} IdentityEmailAlreadyAssociated=21 IdentityEmailAlreadyAssociated value
     * @property {number} IdentityPrincipalEmailNotSet=22 IdentityPrincipalEmailNotSet value
     * @property {number} IdentityPrincipalEmailAlreadyExists=23 IdentityPrincipalEmailAlreadyExists value
     * @property {number} ResourceNotFound=24 ResourceNotFound value
     * @property {number} RegisterInvalidEmail=25 RegisterInvalidEmail value
     * @property {number} RegisterTokenNotFound=26 RegisterTokenNotFound value
     * @property {number} ChannelNotFound=27 ChannelNotFound value
     * @property {number} DelegatedAccessNotFound=28 DelegatedAccessNotFound value
     * @property {number} InvalidToken=29 InvalidToken value
     * @property {number} ApplicationConfigNotFound=33 ApplicationConfigNotFound value
     * @property {number} ApplicationConfigInvalid=34 ApplicationConfigInvalid value
     * @property {number} NamedResourceNotFound=35 NamedResourceNotFound value
     * @property {number} ApplicationInvalidToken=36 ApplicationInvalidToken value
     */
    api.PepsErrorKind = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ServerInternalError"] = 0;
        values[valuesById[1] = "SessionExpired"] = 1;
        values[valuesById[2] = "SessionStale"] = 2;
        values[valuesById[3] = "SessionInvalidSalt"] = 3;
        values[valuesById[4] = "AssumeStale"] = 4;
        values[valuesById[6] = "RequestBadUriParams"] = 6;
        values[valuesById[7] = "RequestMissingHeader"] = 7;
        values[valuesById[8] = "RequestDecodeHeader"] = 8;
        values[valuesById[9] = "RequestBadRequest"] = 9;
        values[valuesById[10] = "IdentityCannotAssumeOwnership"] = 10;
        values[valuesById[11] = "IdentityCannotAssumeAccess"] = 11;
        values[valuesById[12] = "IdentitySignatureMismatch"] = 12;
        values[valuesById[13] = "IdentityInvalidLogin"] = 13;
        values[valuesById[14] = "IdentityAlreadyExists"] = 14;
        values[valuesById[15] = "IdentityNotFound"] = 15;
        values[valuesById[16] = "IdentityVersionMismatch"] = 16;
        values[valuesById[17] = "IdentityNotAdmin"] = 17;
        values[valuesById[19] = "IdentitySharingKindMismatch"] = 19;
        values[valuesById[20] = "IdentityEmailNotAssociated"] = 20;
        values[valuesById[21] = "IdentityEmailAlreadyAssociated"] = 21;
        values[valuesById[22] = "IdentityPrincipalEmailNotSet"] = 22;
        values[valuesById[23] = "IdentityPrincipalEmailAlreadyExists"] = 23;
        values[valuesById[24] = "ResourceNotFound"] = 24;
        values[valuesById[25] = "RegisterInvalidEmail"] = 25;
        values[valuesById[26] = "RegisterTokenNotFound"] = 26;
        values[valuesById[27] = "ChannelNotFound"] = 27;
        values[valuesById[28] = "DelegatedAccessNotFound"] = 28;
        values[valuesById[29] = "InvalidToken"] = 29;
        values[valuesById[33] = "ApplicationConfigNotFound"] = 33;
        values[valuesById[34] = "ApplicationConfigInvalid"] = 34;
        values[valuesById[35] = "NamedResourceNotFound"] = 35;
        values[valuesById[36] = "ApplicationInvalidToken"] = 36;
        return values;
    })();

    api.PayloadServerInternalError = (function() {

        /**
         * Properties of a PayloadServerInternalError.
         * @memberof api
         * @interface IPayloadServerInternalError
         * @property {string|null} [reason] PayloadServerInternalError reason
         */

        /**
         * Constructs a new PayloadServerInternalError.
         * @memberof api
         * @classdesc Represents a PayloadServerInternalError.
         * @implements IPayloadServerInternalError
         * @constructor
         * @param {api.IPayloadServerInternalError=} [properties] Properties to set
         */
        function PayloadServerInternalError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadServerInternalError reason.
         * @member {string} reason
         * @memberof api.PayloadServerInternalError
         * @instance
         */
        PayloadServerInternalError.prototype.reason = "";

        /**
         * Creates a new PayloadServerInternalError instance using the specified properties.
         * @function create
         * @memberof api.PayloadServerInternalError
         * @static
         * @param {api.IPayloadServerInternalError=} [properties] Properties to set
         * @returns {api.PayloadServerInternalError} PayloadServerInternalError instance
         */
        PayloadServerInternalError.create = function create(properties) {
            return new PayloadServerInternalError(properties);
        };

        /**
         * Encodes the specified PayloadServerInternalError message. Does not implicitly {@link api.PayloadServerInternalError.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadServerInternalError
         * @static
         * @param {api.IPayloadServerInternalError} message PayloadServerInternalError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadServerInternalError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reason != null && message.hasOwnProperty("reason"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.reason);
            return writer;
        };

        /**
         * Encodes the specified PayloadServerInternalError message, length delimited. Does not implicitly {@link api.PayloadServerInternalError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadServerInternalError
         * @static
         * @param {api.IPayloadServerInternalError} message PayloadServerInternalError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadServerInternalError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadServerInternalError message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadServerInternalError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadServerInternalError} PayloadServerInternalError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadServerInternalError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadServerInternalError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadServerInternalError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadServerInternalError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadServerInternalError} PayloadServerInternalError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadServerInternalError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadServerInternalError message.
         * @function verify
         * @memberof api.PayloadServerInternalError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadServerInternalError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            return null;
        };

        /**
         * Creates a PayloadServerInternalError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadServerInternalError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadServerInternalError} PayloadServerInternalError
         */
        PayloadServerInternalError.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadServerInternalError)
                return object;
            var message = new $root.api.PayloadServerInternalError();
            if (object.reason != null)
                message.reason = String(object.reason);
            return message;
        };

        /**
         * Creates a plain object from a PayloadServerInternalError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadServerInternalError
         * @static
         * @param {api.PayloadServerInternalError} message PayloadServerInternalError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadServerInternalError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.reason = "";
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            return object;
        };

        /**
         * Converts this PayloadServerInternalError to JSON.
         * @function toJSON
         * @memberof api.PayloadServerInternalError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadServerInternalError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadServerInternalError;
    })();

    api.PayloadRequestBadUriParams = (function() {

        /**
         * Properties of a PayloadRequestBadUriParams.
         * @memberof api
         * @interface IPayloadRequestBadUriParams
         * @property {string|null} [key] PayloadRequestBadUriParams key
         * @property {string|null} [value] PayloadRequestBadUriParams value
         * @property {string|null} [expected] PayloadRequestBadUriParams expected
         */

        /**
         * Constructs a new PayloadRequestBadUriParams.
         * @memberof api
         * @classdesc Represents a PayloadRequestBadUriParams.
         * @implements IPayloadRequestBadUriParams
         * @constructor
         * @param {api.IPayloadRequestBadUriParams=} [properties] Properties to set
         */
        function PayloadRequestBadUriParams(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadRequestBadUriParams key.
         * @member {string} key
         * @memberof api.PayloadRequestBadUriParams
         * @instance
         */
        PayloadRequestBadUriParams.prototype.key = "";

        /**
         * PayloadRequestBadUriParams value.
         * @member {string} value
         * @memberof api.PayloadRequestBadUriParams
         * @instance
         */
        PayloadRequestBadUriParams.prototype.value = "";

        /**
         * PayloadRequestBadUriParams expected.
         * @member {string} expected
         * @memberof api.PayloadRequestBadUriParams
         * @instance
         */
        PayloadRequestBadUriParams.prototype.expected = "";

        /**
         * Creates a new PayloadRequestBadUriParams instance using the specified properties.
         * @function create
         * @memberof api.PayloadRequestBadUriParams
         * @static
         * @param {api.IPayloadRequestBadUriParams=} [properties] Properties to set
         * @returns {api.PayloadRequestBadUriParams} PayloadRequestBadUriParams instance
         */
        PayloadRequestBadUriParams.create = function create(properties) {
            return new PayloadRequestBadUriParams(properties);
        };

        /**
         * Encodes the specified PayloadRequestBadUriParams message. Does not implicitly {@link api.PayloadRequestBadUriParams.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadRequestBadUriParams
         * @static
         * @param {api.IPayloadRequestBadUriParams} message PayloadRequestBadUriParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRequestBadUriParams.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && message.hasOwnProperty("key"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
            if (message.expected != null && message.hasOwnProperty("expected"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.expected);
            return writer;
        };

        /**
         * Encodes the specified PayloadRequestBadUriParams message, length delimited. Does not implicitly {@link api.PayloadRequestBadUriParams.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadRequestBadUriParams
         * @static
         * @param {api.IPayloadRequestBadUriParams} message PayloadRequestBadUriParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRequestBadUriParams.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadRequestBadUriParams message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadRequestBadUriParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadRequestBadUriParams} PayloadRequestBadUriParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRequestBadUriParams.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadRequestBadUriParams();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                case 3:
                    message.expected = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadRequestBadUriParams message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadRequestBadUriParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadRequestBadUriParams} PayloadRequestBadUriParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRequestBadUriParams.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadRequestBadUriParams message.
         * @function verify
         * @memberof api.PayloadRequestBadUriParams
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadRequestBadUriParams.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!$util.isString(message.key))
                    return "key: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            if (message.expected != null && message.hasOwnProperty("expected"))
                if (!$util.isString(message.expected))
                    return "expected: string expected";
            return null;
        };

        /**
         * Creates a PayloadRequestBadUriParams message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadRequestBadUriParams
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadRequestBadUriParams} PayloadRequestBadUriParams
         */
        PayloadRequestBadUriParams.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadRequestBadUriParams)
                return object;
            var message = new $root.api.PayloadRequestBadUriParams();
            if (object.key != null)
                message.key = String(object.key);
            if (object.value != null)
                message.value = String(object.value);
            if (object.expected != null)
                message.expected = String(object.expected);
            return message;
        };

        /**
         * Creates a plain object from a PayloadRequestBadUriParams message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadRequestBadUriParams
         * @static
         * @param {api.PayloadRequestBadUriParams} message PayloadRequestBadUriParams
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadRequestBadUriParams.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.key = "";
                object.value = "";
                object.expected = "";
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = message.key;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            if (message.expected != null && message.hasOwnProperty("expected"))
                object.expected = message.expected;
            return object;
        };

        /**
         * Converts this PayloadRequestBadUriParams to JSON.
         * @function toJSON
         * @memberof api.PayloadRequestBadUriParams
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadRequestBadUriParams.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadRequestBadUriParams;
    })();

    api.PayloadRequestMissingHeader = (function() {

        /**
         * Properties of a PayloadRequestMissingHeader.
         * @memberof api
         * @interface IPayloadRequestMissingHeader
         * @property {string|null} [name] PayloadRequestMissingHeader name
         */

        /**
         * Constructs a new PayloadRequestMissingHeader.
         * @memberof api
         * @classdesc Represents a PayloadRequestMissingHeader.
         * @implements IPayloadRequestMissingHeader
         * @constructor
         * @param {api.IPayloadRequestMissingHeader=} [properties] Properties to set
         */
        function PayloadRequestMissingHeader(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadRequestMissingHeader name.
         * @member {string} name
         * @memberof api.PayloadRequestMissingHeader
         * @instance
         */
        PayloadRequestMissingHeader.prototype.name = "";

        /**
         * Creates a new PayloadRequestMissingHeader instance using the specified properties.
         * @function create
         * @memberof api.PayloadRequestMissingHeader
         * @static
         * @param {api.IPayloadRequestMissingHeader=} [properties] Properties to set
         * @returns {api.PayloadRequestMissingHeader} PayloadRequestMissingHeader instance
         */
        PayloadRequestMissingHeader.create = function create(properties) {
            return new PayloadRequestMissingHeader(properties);
        };

        /**
         * Encodes the specified PayloadRequestMissingHeader message. Does not implicitly {@link api.PayloadRequestMissingHeader.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadRequestMissingHeader
         * @static
         * @param {api.IPayloadRequestMissingHeader} message PayloadRequestMissingHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRequestMissingHeader.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified PayloadRequestMissingHeader message, length delimited. Does not implicitly {@link api.PayloadRequestMissingHeader.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadRequestMissingHeader
         * @static
         * @param {api.IPayloadRequestMissingHeader} message PayloadRequestMissingHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRequestMissingHeader.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadRequestMissingHeader message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadRequestMissingHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadRequestMissingHeader} PayloadRequestMissingHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRequestMissingHeader.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadRequestMissingHeader();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadRequestMissingHeader message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadRequestMissingHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadRequestMissingHeader} PayloadRequestMissingHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRequestMissingHeader.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadRequestMissingHeader message.
         * @function verify
         * @memberof api.PayloadRequestMissingHeader
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadRequestMissingHeader.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a PayloadRequestMissingHeader message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadRequestMissingHeader
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadRequestMissingHeader} PayloadRequestMissingHeader
         */
        PayloadRequestMissingHeader.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadRequestMissingHeader)
                return object;
            var message = new $root.api.PayloadRequestMissingHeader();
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a PayloadRequestMissingHeader message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadRequestMissingHeader
         * @static
         * @param {api.PayloadRequestMissingHeader} message PayloadRequestMissingHeader
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadRequestMissingHeader.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.name = "";
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this PayloadRequestMissingHeader to JSON.
         * @function toJSON
         * @memberof api.PayloadRequestMissingHeader
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadRequestMissingHeader.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadRequestMissingHeader;
    })();

    api.PayloadRequestDecodeHeader = (function() {

        /**
         * Properties of a PayloadRequestDecodeHeader.
         * @memberof api
         * @interface IPayloadRequestDecodeHeader
         * @property {string|null} [name] PayloadRequestDecodeHeader name
         * @property {string|null} [value] PayloadRequestDecodeHeader value
         */

        /**
         * Constructs a new PayloadRequestDecodeHeader.
         * @memberof api
         * @classdesc Represents a PayloadRequestDecodeHeader.
         * @implements IPayloadRequestDecodeHeader
         * @constructor
         * @param {api.IPayloadRequestDecodeHeader=} [properties] Properties to set
         */
        function PayloadRequestDecodeHeader(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadRequestDecodeHeader name.
         * @member {string} name
         * @memberof api.PayloadRequestDecodeHeader
         * @instance
         */
        PayloadRequestDecodeHeader.prototype.name = "";

        /**
         * PayloadRequestDecodeHeader value.
         * @member {string} value
         * @memberof api.PayloadRequestDecodeHeader
         * @instance
         */
        PayloadRequestDecodeHeader.prototype.value = "";

        /**
         * Creates a new PayloadRequestDecodeHeader instance using the specified properties.
         * @function create
         * @memberof api.PayloadRequestDecodeHeader
         * @static
         * @param {api.IPayloadRequestDecodeHeader=} [properties] Properties to set
         * @returns {api.PayloadRequestDecodeHeader} PayloadRequestDecodeHeader instance
         */
        PayloadRequestDecodeHeader.create = function create(properties) {
            return new PayloadRequestDecodeHeader(properties);
        };

        /**
         * Encodes the specified PayloadRequestDecodeHeader message. Does not implicitly {@link api.PayloadRequestDecodeHeader.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadRequestDecodeHeader
         * @static
         * @param {api.IPayloadRequestDecodeHeader} message PayloadRequestDecodeHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRequestDecodeHeader.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified PayloadRequestDecodeHeader message, length delimited. Does not implicitly {@link api.PayloadRequestDecodeHeader.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadRequestDecodeHeader
         * @static
         * @param {api.IPayloadRequestDecodeHeader} message PayloadRequestDecodeHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRequestDecodeHeader.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadRequestDecodeHeader message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadRequestDecodeHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadRequestDecodeHeader} PayloadRequestDecodeHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRequestDecodeHeader.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadRequestDecodeHeader();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadRequestDecodeHeader message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadRequestDecodeHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadRequestDecodeHeader} PayloadRequestDecodeHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRequestDecodeHeader.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadRequestDecodeHeader message.
         * @function verify
         * @memberof api.PayloadRequestDecodeHeader
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadRequestDecodeHeader.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };

        /**
         * Creates a PayloadRequestDecodeHeader message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadRequestDecodeHeader
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadRequestDecodeHeader} PayloadRequestDecodeHeader
         */
        PayloadRequestDecodeHeader.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadRequestDecodeHeader)
                return object;
            var message = new $root.api.PayloadRequestDecodeHeader();
            if (object.name != null)
                message.name = String(object.name);
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from a PayloadRequestDecodeHeader message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadRequestDecodeHeader
         * @static
         * @param {api.PayloadRequestDecodeHeader} message PayloadRequestDecodeHeader
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadRequestDecodeHeader.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.value = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this PayloadRequestDecodeHeader to JSON.
         * @function toJSON
         * @memberof api.PayloadRequestDecodeHeader
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadRequestDecodeHeader.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadRequestDecodeHeader;
    })();

    api.PayloadRequestBadRequest = (function() {

        /**
         * Properties of a PayloadRequestBadRequest.
         * @memberof api
         * @interface IPayloadRequestBadRequest
         * @property {string|null} [hint] PayloadRequestBadRequest hint
         */

        /**
         * Constructs a new PayloadRequestBadRequest.
         * @memberof api
         * @classdesc Represents a PayloadRequestBadRequest.
         * @implements IPayloadRequestBadRequest
         * @constructor
         * @param {api.IPayloadRequestBadRequest=} [properties] Properties to set
         */
        function PayloadRequestBadRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadRequestBadRequest hint.
         * @member {string} hint
         * @memberof api.PayloadRequestBadRequest
         * @instance
         */
        PayloadRequestBadRequest.prototype.hint = "";

        /**
         * Creates a new PayloadRequestBadRequest instance using the specified properties.
         * @function create
         * @memberof api.PayloadRequestBadRequest
         * @static
         * @param {api.IPayloadRequestBadRequest=} [properties] Properties to set
         * @returns {api.PayloadRequestBadRequest} PayloadRequestBadRequest instance
         */
        PayloadRequestBadRequest.create = function create(properties) {
            return new PayloadRequestBadRequest(properties);
        };

        /**
         * Encodes the specified PayloadRequestBadRequest message. Does not implicitly {@link api.PayloadRequestBadRequest.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadRequestBadRequest
         * @static
         * @param {api.IPayloadRequestBadRequest} message PayloadRequestBadRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRequestBadRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hint != null && message.hasOwnProperty("hint"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.hint);
            return writer;
        };

        /**
         * Encodes the specified PayloadRequestBadRequest message, length delimited. Does not implicitly {@link api.PayloadRequestBadRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadRequestBadRequest
         * @static
         * @param {api.IPayloadRequestBadRequest} message PayloadRequestBadRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRequestBadRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadRequestBadRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadRequestBadRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadRequestBadRequest} PayloadRequestBadRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRequestBadRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadRequestBadRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hint = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadRequestBadRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadRequestBadRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadRequestBadRequest} PayloadRequestBadRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRequestBadRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadRequestBadRequest message.
         * @function verify
         * @memberof api.PayloadRequestBadRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadRequestBadRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hint != null && message.hasOwnProperty("hint"))
                if (!$util.isString(message.hint))
                    return "hint: string expected";
            return null;
        };

        /**
         * Creates a PayloadRequestBadRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadRequestBadRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadRequestBadRequest} PayloadRequestBadRequest
         */
        PayloadRequestBadRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadRequestBadRequest)
                return object;
            var message = new $root.api.PayloadRequestBadRequest();
            if (object.hint != null)
                message.hint = String(object.hint);
            return message;
        };

        /**
         * Creates a plain object from a PayloadRequestBadRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadRequestBadRequest
         * @static
         * @param {api.PayloadRequestBadRequest} message PayloadRequestBadRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadRequestBadRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.hint = "";
            if (message.hint != null && message.hasOwnProperty("hint"))
                object.hint = message.hint;
            return object;
        };

        /**
         * Converts this PayloadRequestBadRequest to JSON.
         * @function toJSON
         * @memberof api.PayloadRequestBadRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadRequestBadRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadRequestBadRequest;
    })();

    api.PayloadIdentityCannotAssumeOwnership = (function() {

        /**
         * Properties of a PayloadIdentityCannotAssumeOwnership.
         * @memberof api
         * @interface IPayloadIdentityCannotAssumeOwnership
         * @property {string|null} [owner] PayloadIdentityCannotAssumeOwnership owner
         */

        /**
         * Constructs a new PayloadIdentityCannotAssumeOwnership.
         * @memberof api
         * @classdesc Represents a PayloadIdentityCannotAssumeOwnership.
         * @implements IPayloadIdentityCannotAssumeOwnership
         * @constructor
         * @param {api.IPayloadIdentityCannotAssumeOwnership=} [properties] Properties to set
         */
        function PayloadIdentityCannotAssumeOwnership(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentityCannotAssumeOwnership owner.
         * @member {string} owner
         * @memberof api.PayloadIdentityCannotAssumeOwnership
         * @instance
         */
        PayloadIdentityCannotAssumeOwnership.prototype.owner = "";

        /**
         * Creates a new PayloadIdentityCannotAssumeOwnership instance using the specified properties.
         * @function create
         * @memberof api.PayloadIdentityCannotAssumeOwnership
         * @static
         * @param {api.IPayloadIdentityCannotAssumeOwnership=} [properties] Properties to set
         * @returns {api.PayloadIdentityCannotAssumeOwnership} PayloadIdentityCannotAssumeOwnership instance
         */
        PayloadIdentityCannotAssumeOwnership.create = function create(properties) {
            return new PayloadIdentityCannotAssumeOwnership(properties);
        };

        /**
         * Encodes the specified PayloadIdentityCannotAssumeOwnership message. Does not implicitly {@link api.PayloadIdentityCannotAssumeOwnership.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadIdentityCannotAssumeOwnership
         * @static
         * @param {api.IPayloadIdentityCannotAssumeOwnership} message PayloadIdentityCannotAssumeOwnership message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityCannotAssumeOwnership.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner != null && message.hasOwnProperty("owner"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.owner);
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentityCannotAssumeOwnership message, length delimited. Does not implicitly {@link api.PayloadIdentityCannotAssumeOwnership.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadIdentityCannotAssumeOwnership
         * @static
         * @param {api.IPayloadIdentityCannotAssumeOwnership} message PayloadIdentityCannotAssumeOwnership message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityCannotAssumeOwnership.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentityCannotAssumeOwnership message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadIdentityCannotAssumeOwnership
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadIdentityCannotAssumeOwnership} PayloadIdentityCannotAssumeOwnership
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityCannotAssumeOwnership.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadIdentityCannotAssumeOwnership();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentityCannotAssumeOwnership message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadIdentityCannotAssumeOwnership
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadIdentityCannotAssumeOwnership} PayloadIdentityCannotAssumeOwnership
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityCannotAssumeOwnership.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentityCannotAssumeOwnership message.
         * @function verify
         * @memberof api.PayloadIdentityCannotAssumeOwnership
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentityCannotAssumeOwnership.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner != null && message.hasOwnProperty("owner"))
                if (!$util.isString(message.owner))
                    return "owner: string expected";
            return null;
        };

        /**
         * Creates a PayloadIdentityCannotAssumeOwnership message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadIdentityCannotAssumeOwnership
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadIdentityCannotAssumeOwnership} PayloadIdentityCannotAssumeOwnership
         */
        PayloadIdentityCannotAssumeOwnership.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadIdentityCannotAssumeOwnership)
                return object;
            var message = new $root.api.PayloadIdentityCannotAssumeOwnership();
            if (object.owner != null)
                message.owner = String(object.owner);
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentityCannotAssumeOwnership message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadIdentityCannotAssumeOwnership
         * @static
         * @param {api.PayloadIdentityCannotAssumeOwnership} message PayloadIdentityCannotAssumeOwnership
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentityCannotAssumeOwnership.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.owner = "";
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = message.owner;
            return object;
        };

        /**
         * Converts this PayloadIdentityCannotAssumeOwnership to JSON.
         * @function toJSON
         * @memberof api.PayloadIdentityCannotAssumeOwnership
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentityCannotAssumeOwnership.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentityCannotAssumeOwnership;
    })();

    api.PayloadIdentityCannotAssumeAccess = (function() {

        /**
         * Properties of a PayloadIdentityCannotAssumeAccess.
         * @memberof api
         * @interface IPayloadIdentityCannotAssumeAccess
         * @property {api.IdentityAccessKeyKind|null} [kind] PayloadIdentityCannotAssumeAccess kind
         */

        /**
         * Constructs a new PayloadIdentityCannotAssumeAccess.
         * @memberof api
         * @classdesc Represents a PayloadIdentityCannotAssumeAccess.
         * @implements IPayloadIdentityCannotAssumeAccess
         * @constructor
         * @param {api.IPayloadIdentityCannotAssumeAccess=} [properties] Properties to set
         */
        function PayloadIdentityCannotAssumeAccess(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentityCannotAssumeAccess kind.
         * @member {api.IdentityAccessKeyKind} kind
         * @memberof api.PayloadIdentityCannotAssumeAccess
         * @instance
         */
        PayloadIdentityCannotAssumeAccess.prototype.kind = 0;

        /**
         * Creates a new PayloadIdentityCannotAssumeAccess instance using the specified properties.
         * @function create
         * @memberof api.PayloadIdentityCannotAssumeAccess
         * @static
         * @param {api.IPayloadIdentityCannotAssumeAccess=} [properties] Properties to set
         * @returns {api.PayloadIdentityCannotAssumeAccess} PayloadIdentityCannotAssumeAccess instance
         */
        PayloadIdentityCannotAssumeAccess.create = function create(properties) {
            return new PayloadIdentityCannotAssumeAccess(properties);
        };

        /**
         * Encodes the specified PayloadIdentityCannotAssumeAccess message. Does not implicitly {@link api.PayloadIdentityCannotAssumeAccess.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadIdentityCannotAssumeAccess
         * @static
         * @param {api.IPayloadIdentityCannotAssumeAccess} message PayloadIdentityCannotAssumeAccess message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityCannotAssumeAccess.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.kind != null && message.hasOwnProperty("kind"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.kind);
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentityCannotAssumeAccess message, length delimited. Does not implicitly {@link api.PayloadIdentityCannotAssumeAccess.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadIdentityCannotAssumeAccess
         * @static
         * @param {api.IPayloadIdentityCannotAssumeAccess} message PayloadIdentityCannotAssumeAccess message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityCannotAssumeAccess.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentityCannotAssumeAccess message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadIdentityCannotAssumeAccess
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadIdentityCannotAssumeAccess} PayloadIdentityCannotAssumeAccess
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityCannotAssumeAccess.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadIdentityCannotAssumeAccess();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.kind = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentityCannotAssumeAccess message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadIdentityCannotAssumeAccess
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadIdentityCannotAssumeAccess} PayloadIdentityCannotAssumeAccess
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityCannotAssumeAccess.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentityCannotAssumeAccess message.
         * @function verify
         * @memberof api.PayloadIdentityCannotAssumeAccess
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentityCannotAssumeAccess.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.kind != null && message.hasOwnProperty("kind"))
                switch (message.kind) {
                default:
                    return "kind: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a PayloadIdentityCannotAssumeAccess message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadIdentityCannotAssumeAccess
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadIdentityCannotAssumeAccess} PayloadIdentityCannotAssumeAccess
         */
        PayloadIdentityCannotAssumeAccess.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadIdentityCannotAssumeAccess)
                return object;
            var message = new $root.api.PayloadIdentityCannotAssumeAccess();
            switch (object.kind) {
            case "READ":
            case 0:
                message.kind = 0;
                break;
            case "WRITE":
            case 1:
                message.kind = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentityCannotAssumeAccess message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadIdentityCannotAssumeAccess
         * @static
         * @param {api.PayloadIdentityCannotAssumeAccess} message PayloadIdentityCannotAssumeAccess
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentityCannotAssumeAccess.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.kind = options.enums === String ? "READ" : 0;
            if (message.kind != null && message.hasOwnProperty("kind"))
                object.kind = options.enums === String ? $root.api.IdentityAccessKeyKind[message.kind] : message.kind;
            return object;
        };

        /**
         * Converts this PayloadIdentityCannotAssumeAccess to JSON.
         * @function toJSON
         * @memberof api.PayloadIdentityCannotAssumeAccess
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentityCannotAssumeAccess.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentityCannotAssumeAccess;
    })();

    api.PayloadIdentitySignatureMismatch = (function() {

        /**
         * Properties of a PayloadIdentitySignatureMismatch.
         * @memberof api
         * @interface IPayloadIdentitySignatureMismatch
         * @property {api.IIdentityKeyID|null} [key] PayloadIdentitySignatureMismatch key
         */

        /**
         * Constructs a new PayloadIdentitySignatureMismatch.
         * @memberof api
         * @classdesc Represents a PayloadIdentitySignatureMismatch.
         * @implements IPayloadIdentitySignatureMismatch
         * @constructor
         * @param {api.IPayloadIdentitySignatureMismatch=} [properties] Properties to set
         */
        function PayloadIdentitySignatureMismatch(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentitySignatureMismatch key.
         * @member {api.IIdentityKeyID|null|undefined} key
         * @memberof api.PayloadIdentitySignatureMismatch
         * @instance
         */
        PayloadIdentitySignatureMismatch.prototype.key = null;

        /**
         * Creates a new PayloadIdentitySignatureMismatch instance using the specified properties.
         * @function create
         * @memberof api.PayloadIdentitySignatureMismatch
         * @static
         * @param {api.IPayloadIdentitySignatureMismatch=} [properties] Properties to set
         * @returns {api.PayloadIdentitySignatureMismatch} PayloadIdentitySignatureMismatch instance
         */
        PayloadIdentitySignatureMismatch.create = function create(properties) {
            return new PayloadIdentitySignatureMismatch(properties);
        };

        /**
         * Encodes the specified PayloadIdentitySignatureMismatch message. Does not implicitly {@link api.PayloadIdentitySignatureMismatch.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadIdentitySignatureMismatch
         * @static
         * @param {api.IPayloadIdentitySignatureMismatch} message PayloadIdentitySignatureMismatch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentitySignatureMismatch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && message.hasOwnProperty("key"))
                $root.api.IdentityKeyID.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentitySignatureMismatch message, length delimited. Does not implicitly {@link api.PayloadIdentitySignatureMismatch.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadIdentitySignatureMismatch
         * @static
         * @param {api.IPayloadIdentitySignatureMismatch} message PayloadIdentitySignatureMismatch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentitySignatureMismatch.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentitySignatureMismatch message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadIdentitySignatureMismatch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadIdentitySignatureMismatch} PayloadIdentitySignatureMismatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentitySignatureMismatch.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadIdentitySignatureMismatch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentitySignatureMismatch message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadIdentitySignatureMismatch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadIdentitySignatureMismatch} PayloadIdentitySignatureMismatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentitySignatureMismatch.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentitySignatureMismatch message.
         * @function verify
         * @memberof api.PayloadIdentitySignatureMismatch
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentitySignatureMismatch.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key")) {
                var error = $root.api.IdentityKeyID.verify(message.key);
                if (error)
                    return "key." + error;
            }
            return null;
        };

        /**
         * Creates a PayloadIdentitySignatureMismatch message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadIdentitySignatureMismatch
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadIdentitySignatureMismatch} PayloadIdentitySignatureMismatch
         */
        PayloadIdentitySignatureMismatch.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadIdentitySignatureMismatch)
                return object;
            var message = new $root.api.PayloadIdentitySignatureMismatch();
            if (object.key != null) {
                if (typeof object.key !== "object")
                    throw TypeError(".api.PayloadIdentitySignatureMismatch.key: object expected");
                message.key = $root.api.IdentityKeyID.fromObject(object.key);
            }
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentitySignatureMismatch message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadIdentitySignatureMismatch
         * @static
         * @param {api.PayloadIdentitySignatureMismatch} message PayloadIdentitySignatureMismatch
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentitySignatureMismatch.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.key = null;
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = $root.api.IdentityKeyID.toObject(message.key, options);
            return object;
        };

        /**
         * Converts this PayloadIdentitySignatureMismatch to JSON.
         * @function toJSON
         * @memberof api.PayloadIdentitySignatureMismatch
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentitySignatureMismatch.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentitySignatureMismatch;
    })();

    api.PayloadIdentityInvalidLogin = (function() {

        /**
         * Properties of a PayloadIdentityInvalidLogin.
         * @memberof api
         * @interface IPayloadIdentityInvalidLogin
         * @property {string|null} [login] PayloadIdentityInvalidLogin login
         */

        /**
         * Constructs a new PayloadIdentityInvalidLogin.
         * @memberof api
         * @classdesc Represents a PayloadIdentityInvalidLogin.
         * @implements IPayloadIdentityInvalidLogin
         * @constructor
         * @param {api.IPayloadIdentityInvalidLogin=} [properties] Properties to set
         */
        function PayloadIdentityInvalidLogin(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentityInvalidLogin login.
         * @member {string} login
         * @memberof api.PayloadIdentityInvalidLogin
         * @instance
         */
        PayloadIdentityInvalidLogin.prototype.login = "";

        /**
         * Creates a new PayloadIdentityInvalidLogin instance using the specified properties.
         * @function create
         * @memberof api.PayloadIdentityInvalidLogin
         * @static
         * @param {api.IPayloadIdentityInvalidLogin=} [properties] Properties to set
         * @returns {api.PayloadIdentityInvalidLogin} PayloadIdentityInvalidLogin instance
         */
        PayloadIdentityInvalidLogin.create = function create(properties) {
            return new PayloadIdentityInvalidLogin(properties);
        };

        /**
         * Encodes the specified PayloadIdentityInvalidLogin message. Does not implicitly {@link api.PayloadIdentityInvalidLogin.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadIdentityInvalidLogin
         * @static
         * @param {api.IPayloadIdentityInvalidLogin} message PayloadIdentityInvalidLogin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityInvalidLogin.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentityInvalidLogin message, length delimited. Does not implicitly {@link api.PayloadIdentityInvalidLogin.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadIdentityInvalidLogin
         * @static
         * @param {api.IPayloadIdentityInvalidLogin} message PayloadIdentityInvalidLogin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityInvalidLogin.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentityInvalidLogin message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadIdentityInvalidLogin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadIdentityInvalidLogin} PayloadIdentityInvalidLogin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityInvalidLogin.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadIdentityInvalidLogin();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentityInvalidLogin message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadIdentityInvalidLogin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadIdentityInvalidLogin} PayloadIdentityInvalidLogin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityInvalidLogin.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentityInvalidLogin message.
         * @function verify
         * @memberof api.PayloadIdentityInvalidLogin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentityInvalidLogin.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            return null;
        };

        /**
         * Creates a PayloadIdentityInvalidLogin message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadIdentityInvalidLogin
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadIdentityInvalidLogin} PayloadIdentityInvalidLogin
         */
        PayloadIdentityInvalidLogin.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadIdentityInvalidLogin)
                return object;
            var message = new $root.api.PayloadIdentityInvalidLogin();
            if (object.login != null)
                message.login = String(object.login);
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentityInvalidLogin message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadIdentityInvalidLogin
         * @static
         * @param {api.PayloadIdentityInvalidLogin} message PayloadIdentityInvalidLogin
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentityInvalidLogin.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.login = "";
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            return object;
        };

        /**
         * Converts this PayloadIdentityInvalidLogin to JSON.
         * @function toJSON
         * @memberof api.PayloadIdentityInvalidLogin
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentityInvalidLogin.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentityInvalidLogin;
    })();

    api.PayloadIdentityAlreadyExists = (function() {

        /**
         * Properties of a PayloadIdentityAlreadyExists.
         * @memberof api
         * @interface IPayloadIdentityAlreadyExists
         * @property {string|null} [login] PayloadIdentityAlreadyExists login
         */

        /**
         * Constructs a new PayloadIdentityAlreadyExists.
         * @memberof api
         * @classdesc Represents a PayloadIdentityAlreadyExists.
         * @implements IPayloadIdentityAlreadyExists
         * @constructor
         * @param {api.IPayloadIdentityAlreadyExists=} [properties] Properties to set
         */
        function PayloadIdentityAlreadyExists(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentityAlreadyExists login.
         * @member {string} login
         * @memberof api.PayloadIdentityAlreadyExists
         * @instance
         */
        PayloadIdentityAlreadyExists.prototype.login = "";

        /**
         * Creates a new PayloadIdentityAlreadyExists instance using the specified properties.
         * @function create
         * @memberof api.PayloadIdentityAlreadyExists
         * @static
         * @param {api.IPayloadIdentityAlreadyExists=} [properties] Properties to set
         * @returns {api.PayloadIdentityAlreadyExists} PayloadIdentityAlreadyExists instance
         */
        PayloadIdentityAlreadyExists.create = function create(properties) {
            return new PayloadIdentityAlreadyExists(properties);
        };

        /**
         * Encodes the specified PayloadIdentityAlreadyExists message. Does not implicitly {@link api.PayloadIdentityAlreadyExists.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadIdentityAlreadyExists
         * @static
         * @param {api.IPayloadIdentityAlreadyExists} message PayloadIdentityAlreadyExists message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityAlreadyExists.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentityAlreadyExists message, length delimited. Does not implicitly {@link api.PayloadIdentityAlreadyExists.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadIdentityAlreadyExists
         * @static
         * @param {api.IPayloadIdentityAlreadyExists} message PayloadIdentityAlreadyExists message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityAlreadyExists.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentityAlreadyExists message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadIdentityAlreadyExists
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadIdentityAlreadyExists} PayloadIdentityAlreadyExists
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityAlreadyExists.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadIdentityAlreadyExists();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentityAlreadyExists message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadIdentityAlreadyExists
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadIdentityAlreadyExists} PayloadIdentityAlreadyExists
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityAlreadyExists.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentityAlreadyExists message.
         * @function verify
         * @memberof api.PayloadIdentityAlreadyExists
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentityAlreadyExists.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            return null;
        };

        /**
         * Creates a PayloadIdentityAlreadyExists message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadIdentityAlreadyExists
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadIdentityAlreadyExists} PayloadIdentityAlreadyExists
         */
        PayloadIdentityAlreadyExists.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadIdentityAlreadyExists)
                return object;
            var message = new $root.api.PayloadIdentityAlreadyExists();
            if (object.login != null)
                message.login = String(object.login);
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentityAlreadyExists message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadIdentityAlreadyExists
         * @static
         * @param {api.PayloadIdentityAlreadyExists} message PayloadIdentityAlreadyExists
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentityAlreadyExists.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.login = "";
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            return object;
        };

        /**
         * Converts this PayloadIdentityAlreadyExists to JSON.
         * @function toJSON
         * @memberof api.PayloadIdentityAlreadyExists
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentityAlreadyExists.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentityAlreadyExists;
    })();

    api.PayloadIdentityNotFound = (function() {

        /**
         * Properties of a PayloadIdentityNotFound.
         * @memberof api
         * @interface IPayloadIdentityNotFound
         * @property {string|null} [login] PayloadIdentityNotFound login
         */

        /**
         * Constructs a new PayloadIdentityNotFound.
         * @memberof api
         * @classdesc Represents a PayloadIdentityNotFound.
         * @implements IPayloadIdentityNotFound
         * @constructor
         * @param {api.IPayloadIdentityNotFound=} [properties] Properties to set
         */
        function PayloadIdentityNotFound(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentityNotFound login.
         * @member {string} login
         * @memberof api.PayloadIdentityNotFound
         * @instance
         */
        PayloadIdentityNotFound.prototype.login = "";

        /**
         * Creates a new PayloadIdentityNotFound instance using the specified properties.
         * @function create
         * @memberof api.PayloadIdentityNotFound
         * @static
         * @param {api.IPayloadIdentityNotFound=} [properties] Properties to set
         * @returns {api.PayloadIdentityNotFound} PayloadIdentityNotFound instance
         */
        PayloadIdentityNotFound.create = function create(properties) {
            return new PayloadIdentityNotFound(properties);
        };

        /**
         * Encodes the specified PayloadIdentityNotFound message. Does not implicitly {@link api.PayloadIdentityNotFound.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadIdentityNotFound
         * @static
         * @param {api.IPayloadIdentityNotFound} message PayloadIdentityNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityNotFound.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentityNotFound message, length delimited. Does not implicitly {@link api.PayloadIdentityNotFound.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadIdentityNotFound
         * @static
         * @param {api.IPayloadIdentityNotFound} message PayloadIdentityNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityNotFound.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentityNotFound message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadIdentityNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadIdentityNotFound} PayloadIdentityNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityNotFound.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadIdentityNotFound();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentityNotFound message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadIdentityNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadIdentityNotFound} PayloadIdentityNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityNotFound.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentityNotFound message.
         * @function verify
         * @memberof api.PayloadIdentityNotFound
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentityNotFound.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            return null;
        };

        /**
         * Creates a PayloadIdentityNotFound message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadIdentityNotFound
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadIdentityNotFound} PayloadIdentityNotFound
         */
        PayloadIdentityNotFound.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadIdentityNotFound)
                return object;
            var message = new $root.api.PayloadIdentityNotFound();
            if (object.login != null)
                message.login = String(object.login);
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentityNotFound message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadIdentityNotFound
         * @static
         * @param {api.PayloadIdentityNotFound} message PayloadIdentityNotFound
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentityNotFound.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.login = "";
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            return object;
        };

        /**
         * Converts this PayloadIdentityNotFound to JSON.
         * @function toJSON
         * @memberof api.PayloadIdentityNotFound
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentityNotFound.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentityNotFound;
    })();

    api.PayloadIdentityVersionMismatch = (function() {

        /**
         * Properties of a PayloadIdentityVersionMismatch.
         * @memberof api
         * @interface IPayloadIdentityVersionMismatch
         * @property {api.IIdentityKeyID|null} [key] PayloadIdentityVersionMismatch key
         * @property {number|null} [expected] PayloadIdentityVersionMismatch expected
         */

        /**
         * Constructs a new PayloadIdentityVersionMismatch.
         * @memberof api
         * @classdesc Represents a PayloadIdentityVersionMismatch.
         * @implements IPayloadIdentityVersionMismatch
         * @constructor
         * @param {api.IPayloadIdentityVersionMismatch=} [properties] Properties to set
         */
        function PayloadIdentityVersionMismatch(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentityVersionMismatch key.
         * @member {api.IIdentityKeyID|null|undefined} key
         * @memberof api.PayloadIdentityVersionMismatch
         * @instance
         */
        PayloadIdentityVersionMismatch.prototype.key = null;

        /**
         * PayloadIdentityVersionMismatch expected.
         * @member {number} expected
         * @memberof api.PayloadIdentityVersionMismatch
         * @instance
         */
        PayloadIdentityVersionMismatch.prototype.expected = 0;

        /**
         * Creates a new PayloadIdentityVersionMismatch instance using the specified properties.
         * @function create
         * @memberof api.PayloadIdentityVersionMismatch
         * @static
         * @param {api.IPayloadIdentityVersionMismatch=} [properties] Properties to set
         * @returns {api.PayloadIdentityVersionMismatch} PayloadIdentityVersionMismatch instance
         */
        PayloadIdentityVersionMismatch.create = function create(properties) {
            return new PayloadIdentityVersionMismatch(properties);
        };

        /**
         * Encodes the specified PayloadIdentityVersionMismatch message. Does not implicitly {@link api.PayloadIdentityVersionMismatch.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadIdentityVersionMismatch
         * @static
         * @param {api.IPayloadIdentityVersionMismatch} message PayloadIdentityVersionMismatch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityVersionMismatch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && message.hasOwnProperty("key"))
                $root.api.IdentityKeyID.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.expected != null && message.hasOwnProperty("expected"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.expected);
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentityVersionMismatch message, length delimited. Does not implicitly {@link api.PayloadIdentityVersionMismatch.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadIdentityVersionMismatch
         * @static
         * @param {api.IPayloadIdentityVersionMismatch} message PayloadIdentityVersionMismatch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityVersionMismatch.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentityVersionMismatch message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadIdentityVersionMismatch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadIdentityVersionMismatch} PayloadIdentityVersionMismatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityVersionMismatch.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadIdentityVersionMismatch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.expected = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentityVersionMismatch message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadIdentityVersionMismatch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadIdentityVersionMismatch} PayloadIdentityVersionMismatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityVersionMismatch.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentityVersionMismatch message.
         * @function verify
         * @memberof api.PayloadIdentityVersionMismatch
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentityVersionMismatch.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key")) {
                var error = $root.api.IdentityKeyID.verify(message.key);
                if (error)
                    return "key." + error;
            }
            if (message.expected != null && message.hasOwnProperty("expected"))
                if (!$util.isInteger(message.expected))
                    return "expected: integer expected";
            return null;
        };

        /**
         * Creates a PayloadIdentityVersionMismatch message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadIdentityVersionMismatch
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadIdentityVersionMismatch} PayloadIdentityVersionMismatch
         */
        PayloadIdentityVersionMismatch.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadIdentityVersionMismatch)
                return object;
            var message = new $root.api.PayloadIdentityVersionMismatch();
            if (object.key != null) {
                if (typeof object.key !== "object")
                    throw TypeError(".api.PayloadIdentityVersionMismatch.key: object expected");
                message.key = $root.api.IdentityKeyID.fromObject(object.key);
            }
            if (object.expected != null)
                message.expected = object.expected >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentityVersionMismatch message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadIdentityVersionMismatch
         * @static
         * @param {api.PayloadIdentityVersionMismatch} message PayloadIdentityVersionMismatch
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentityVersionMismatch.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.key = null;
                object.expected = 0;
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = $root.api.IdentityKeyID.toObject(message.key, options);
            if (message.expected != null && message.hasOwnProperty("expected"))
                object.expected = message.expected;
            return object;
        };

        /**
         * Converts this PayloadIdentityVersionMismatch to JSON.
         * @function toJSON
         * @memberof api.PayloadIdentityVersionMismatch
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentityVersionMismatch.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentityVersionMismatch;
    })();

    api.PayloadIdentityNotAdmin = (function() {

        /**
         * Properties of a PayloadIdentityNotAdmin.
         * @memberof api
         * @interface IPayloadIdentityNotAdmin
         * @property {string|null} [login] PayloadIdentityNotAdmin login
         */

        /**
         * Constructs a new PayloadIdentityNotAdmin.
         * @memberof api
         * @classdesc Represents a PayloadIdentityNotAdmin.
         * @implements IPayloadIdentityNotAdmin
         * @constructor
         * @param {api.IPayloadIdentityNotAdmin=} [properties] Properties to set
         */
        function PayloadIdentityNotAdmin(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentityNotAdmin login.
         * @member {string} login
         * @memberof api.PayloadIdentityNotAdmin
         * @instance
         */
        PayloadIdentityNotAdmin.prototype.login = "";

        /**
         * Creates a new PayloadIdentityNotAdmin instance using the specified properties.
         * @function create
         * @memberof api.PayloadIdentityNotAdmin
         * @static
         * @param {api.IPayloadIdentityNotAdmin=} [properties] Properties to set
         * @returns {api.PayloadIdentityNotAdmin} PayloadIdentityNotAdmin instance
         */
        PayloadIdentityNotAdmin.create = function create(properties) {
            return new PayloadIdentityNotAdmin(properties);
        };

        /**
         * Encodes the specified PayloadIdentityNotAdmin message. Does not implicitly {@link api.PayloadIdentityNotAdmin.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadIdentityNotAdmin
         * @static
         * @param {api.IPayloadIdentityNotAdmin} message PayloadIdentityNotAdmin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityNotAdmin.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentityNotAdmin message, length delimited. Does not implicitly {@link api.PayloadIdentityNotAdmin.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadIdentityNotAdmin
         * @static
         * @param {api.IPayloadIdentityNotAdmin} message PayloadIdentityNotAdmin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityNotAdmin.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentityNotAdmin message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadIdentityNotAdmin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadIdentityNotAdmin} PayloadIdentityNotAdmin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityNotAdmin.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadIdentityNotAdmin();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentityNotAdmin message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadIdentityNotAdmin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadIdentityNotAdmin} PayloadIdentityNotAdmin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityNotAdmin.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentityNotAdmin message.
         * @function verify
         * @memberof api.PayloadIdentityNotAdmin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentityNotAdmin.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            return null;
        };

        /**
         * Creates a PayloadIdentityNotAdmin message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadIdentityNotAdmin
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadIdentityNotAdmin} PayloadIdentityNotAdmin
         */
        PayloadIdentityNotAdmin.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadIdentityNotAdmin)
                return object;
            var message = new $root.api.PayloadIdentityNotAdmin();
            if (object.login != null)
                message.login = String(object.login);
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentityNotAdmin message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadIdentityNotAdmin
         * @static
         * @param {api.PayloadIdentityNotAdmin} message PayloadIdentityNotAdmin
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentityNotAdmin.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.login = "";
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            return object;
        };

        /**
         * Converts this PayloadIdentityNotAdmin to JSON.
         * @function toJSON
         * @memberof api.PayloadIdentityNotAdmin
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentityNotAdmin.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentityNotAdmin;
    })();

    api.PayloadIdentityEmailNotAssociated = (function() {

        /**
         * Properties of a PayloadIdentityEmailNotAssociated.
         * @memberof api
         * @interface IPayloadIdentityEmailNotAssociated
         * @property {string|null} [login] PayloadIdentityEmailNotAssociated login
         * @property {string|null} [email] PayloadIdentityEmailNotAssociated email
         */

        /**
         * Constructs a new PayloadIdentityEmailNotAssociated.
         * @memberof api
         * @classdesc Represents a PayloadIdentityEmailNotAssociated.
         * @implements IPayloadIdentityEmailNotAssociated
         * @constructor
         * @param {api.IPayloadIdentityEmailNotAssociated=} [properties] Properties to set
         */
        function PayloadIdentityEmailNotAssociated(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentityEmailNotAssociated login.
         * @member {string} login
         * @memberof api.PayloadIdentityEmailNotAssociated
         * @instance
         */
        PayloadIdentityEmailNotAssociated.prototype.login = "";

        /**
         * PayloadIdentityEmailNotAssociated email.
         * @member {string} email
         * @memberof api.PayloadIdentityEmailNotAssociated
         * @instance
         */
        PayloadIdentityEmailNotAssociated.prototype.email = "";

        /**
         * Creates a new PayloadIdentityEmailNotAssociated instance using the specified properties.
         * @function create
         * @memberof api.PayloadIdentityEmailNotAssociated
         * @static
         * @param {api.IPayloadIdentityEmailNotAssociated=} [properties] Properties to set
         * @returns {api.PayloadIdentityEmailNotAssociated} PayloadIdentityEmailNotAssociated instance
         */
        PayloadIdentityEmailNotAssociated.create = function create(properties) {
            return new PayloadIdentityEmailNotAssociated(properties);
        };

        /**
         * Encodes the specified PayloadIdentityEmailNotAssociated message. Does not implicitly {@link api.PayloadIdentityEmailNotAssociated.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadIdentityEmailNotAssociated
         * @static
         * @param {api.IPayloadIdentityEmailNotAssociated} message PayloadIdentityEmailNotAssociated message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityEmailNotAssociated.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.email);
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentityEmailNotAssociated message, length delimited. Does not implicitly {@link api.PayloadIdentityEmailNotAssociated.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadIdentityEmailNotAssociated
         * @static
         * @param {api.IPayloadIdentityEmailNotAssociated} message PayloadIdentityEmailNotAssociated message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityEmailNotAssociated.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentityEmailNotAssociated message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadIdentityEmailNotAssociated
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadIdentityEmailNotAssociated} PayloadIdentityEmailNotAssociated
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityEmailNotAssociated.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadIdentityEmailNotAssociated();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.email = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentityEmailNotAssociated message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadIdentityEmailNotAssociated
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadIdentityEmailNotAssociated} PayloadIdentityEmailNotAssociated
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityEmailNotAssociated.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentityEmailNotAssociated message.
         * @function verify
         * @memberof api.PayloadIdentityEmailNotAssociated
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentityEmailNotAssociated.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            return null;
        };

        /**
         * Creates a PayloadIdentityEmailNotAssociated message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadIdentityEmailNotAssociated
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadIdentityEmailNotAssociated} PayloadIdentityEmailNotAssociated
         */
        PayloadIdentityEmailNotAssociated.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadIdentityEmailNotAssociated)
                return object;
            var message = new $root.api.PayloadIdentityEmailNotAssociated();
            if (object.login != null)
                message.login = String(object.login);
            if (object.email != null)
                message.email = String(object.email);
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentityEmailNotAssociated message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadIdentityEmailNotAssociated
         * @static
         * @param {api.PayloadIdentityEmailNotAssociated} message PayloadIdentityEmailNotAssociated
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentityEmailNotAssociated.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.email = "";
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            return object;
        };

        /**
         * Converts this PayloadIdentityEmailNotAssociated to JSON.
         * @function toJSON
         * @memberof api.PayloadIdentityEmailNotAssociated
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentityEmailNotAssociated.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentityEmailNotAssociated;
    })();

    api.PayloadIdentityEmailAlreadyAssociated = (function() {

        /**
         * Properties of a PayloadIdentityEmailAlreadyAssociated.
         * @memberof api
         * @interface IPayloadIdentityEmailAlreadyAssociated
         * @property {string|null} [login] PayloadIdentityEmailAlreadyAssociated login
         * @property {string|null} [email] PayloadIdentityEmailAlreadyAssociated email
         */

        /**
         * Constructs a new PayloadIdentityEmailAlreadyAssociated.
         * @memberof api
         * @classdesc Represents a PayloadIdentityEmailAlreadyAssociated.
         * @implements IPayloadIdentityEmailAlreadyAssociated
         * @constructor
         * @param {api.IPayloadIdentityEmailAlreadyAssociated=} [properties] Properties to set
         */
        function PayloadIdentityEmailAlreadyAssociated(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentityEmailAlreadyAssociated login.
         * @member {string} login
         * @memberof api.PayloadIdentityEmailAlreadyAssociated
         * @instance
         */
        PayloadIdentityEmailAlreadyAssociated.prototype.login = "";

        /**
         * PayloadIdentityEmailAlreadyAssociated email.
         * @member {string} email
         * @memberof api.PayloadIdentityEmailAlreadyAssociated
         * @instance
         */
        PayloadIdentityEmailAlreadyAssociated.prototype.email = "";

        /**
         * Creates a new PayloadIdentityEmailAlreadyAssociated instance using the specified properties.
         * @function create
         * @memberof api.PayloadIdentityEmailAlreadyAssociated
         * @static
         * @param {api.IPayloadIdentityEmailAlreadyAssociated=} [properties] Properties to set
         * @returns {api.PayloadIdentityEmailAlreadyAssociated} PayloadIdentityEmailAlreadyAssociated instance
         */
        PayloadIdentityEmailAlreadyAssociated.create = function create(properties) {
            return new PayloadIdentityEmailAlreadyAssociated(properties);
        };

        /**
         * Encodes the specified PayloadIdentityEmailAlreadyAssociated message. Does not implicitly {@link api.PayloadIdentityEmailAlreadyAssociated.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadIdentityEmailAlreadyAssociated
         * @static
         * @param {api.IPayloadIdentityEmailAlreadyAssociated} message PayloadIdentityEmailAlreadyAssociated message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityEmailAlreadyAssociated.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.email);
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentityEmailAlreadyAssociated message, length delimited. Does not implicitly {@link api.PayloadIdentityEmailAlreadyAssociated.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadIdentityEmailAlreadyAssociated
         * @static
         * @param {api.IPayloadIdentityEmailAlreadyAssociated} message PayloadIdentityEmailAlreadyAssociated message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityEmailAlreadyAssociated.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentityEmailAlreadyAssociated message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadIdentityEmailAlreadyAssociated
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadIdentityEmailAlreadyAssociated} PayloadIdentityEmailAlreadyAssociated
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityEmailAlreadyAssociated.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadIdentityEmailAlreadyAssociated();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.email = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentityEmailAlreadyAssociated message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadIdentityEmailAlreadyAssociated
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadIdentityEmailAlreadyAssociated} PayloadIdentityEmailAlreadyAssociated
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityEmailAlreadyAssociated.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentityEmailAlreadyAssociated message.
         * @function verify
         * @memberof api.PayloadIdentityEmailAlreadyAssociated
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentityEmailAlreadyAssociated.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            return null;
        };

        /**
         * Creates a PayloadIdentityEmailAlreadyAssociated message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadIdentityEmailAlreadyAssociated
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadIdentityEmailAlreadyAssociated} PayloadIdentityEmailAlreadyAssociated
         */
        PayloadIdentityEmailAlreadyAssociated.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadIdentityEmailAlreadyAssociated)
                return object;
            var message = new $root.api.PayloadIdentityEmailAlreadyAssociated();
            if (object.login != null)
                message.login = String(object.login);
            if (object.email != null)
                message.email = String(object.email);
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentityEmailAlreadyAssociated message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadIdentityEmailAlreadyAssociated
         * @static
         * @param {api.PayloadIdentityEmailAlreadyAssociated} message PayloadIdentityEmailAlreadyAssociated
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentityEmailAlreadyAssociated.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.email = "";
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            return object;
        };

        /**
         * Converts this PayloadIdentityEmailAlreadyAssociated to JSON.
         * @function toJSON
         * @memberof api.PayloadIdentityEmailAlreadyAssociated
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentityEmailAlreadyAssociated.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentityEmailAlreadyAssociated;
    })();

    api.PayloadIdentityPrincipalEmailNotSet = (function() {

        /**
         * Properties of a PayloadIdentityPrincipalEmailNotSet.
         * @memberof api
         * @interface IPayloadIdentityPrincipalEmailNotSet
         * @property {string|null} [login] PayloadIdentityPrincipalEmailNotSet login
         */

        /**
         * Constructs a new PayloadIdentityPrincipalEmailNotSet.
         * @memberof api
         * @classdesc Represents a PayloadIdentityPrincipalEmailNotSet.
         * @implements IPayloadIdentityPrincipalEmailNotSet
         * @constructor
         * @param {api.IPayloadIdentityPrincipalEmailNotSet=} [properties] Properties to set
         */
        function PayloadIdentityPrincipalEmailNotSet(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentityPrincipalEmailNotSet login.
         * @member {string} login
         * @memberof api.PayloadIdentityPrincipalEmailNotSet
         * @instance
         */
        PayloadIdentityPrincipalEmailNotSet.prototype.login = "";

        /**
         * Creates a new PayloadIdentityPrincipalEmailNotSet instance using the specified properties.
         * @function create
         * @memberof api.PayloadIdentityPrincipalEmailNotSet
         * @static
         * @param {api.IPayloadIdentityPrincipalEmailNotSet=} [properties] Properties to set
         * @returns {api.PayloadIdentityPrincipalEmailNotSet} PayloadIdentityPrincipalEmailNotSet instance
         */
        PayloadIdentityPrincipalEmailNotSet.create = function create(properties) {
            return new PayloadIdentityPrincipalEmailNotSet(properties);
        };

        /**
         * Encodes the specified PayloadIdentityPrincipalEmailNotSet message. Does not implicitly {@link api.PayloadIdentityPrincipalEmailNotSet.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadIdentityPrincipalEmailNotSet
         * @static
         * @param {api.IPayloadIdentityPrincipalEmailNotSet} message PayloadIdentityPrincipalEmailNotSet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityPrincipalEmailNotSet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentityPrincipalEmailNotSet message, length delimited. Does not implicitly {@link api.PayloadIdentityPrincipalEmailNotSet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadIdentityPrincipalEmailNotSet
         * @static
         * @param {api.IPayloadIdentityPrincipalEmailNotSet} message PayloadIdentityPrincipalEmailNotSet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityPrincipalEmailNotSet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentityPrincipalEmailNotSet message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadIdentityPrincipalEmailNotSet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadIdentityPrincipalEmailNotSet} PayloadIdentityPrincipalEmailNotSet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityPrincipalEmailNotSet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadIdentityPrincipalEmailNotSet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentityPrincipalEmailNotSet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadIdentityPrincipalEmailNotSet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadIdentityPrincipalEmailNotSet} PayloadIdentityPrincipalEmailNotSet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityPrincipalEmailNotSet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentityPrincipalEmailNotSet message.
         * @function verify
         * @memberof api.PayloadIdentityPrincipalEmailNotSet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentityPrincipalEmailNotSet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            return null;
        };

        /**
         * Creates a PayloadIdentityPrincipalEmailNotSet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadIdentityPrincipalEmailNotSet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadIdentityPrincipalEmailNotSet} PayloadIdentityPrincipalEmailNotSet
         */
        PayloadIdentityPrincipalEmailNotSet.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadIdentityPrincipalEmailNotSet)
                return object;
            var message = new $root.api.PayloadIdentityPrincipalEmailNotSet();
            if (object.login != null)
                message.login = String(object.login);
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentityPrincipalEmailNotSet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadIdentityPrincipalEmailNotSet
         * @static
         * @param {api.PayloadIdentityPrincipalEmailNotSet} message PayloadIdentityPrincipalEmailNotSet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentityPrincipalEmailNotSet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.login = "";
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            return object;
        };

        /**
         * Converts this PayloadIdentityPrincipalEmailNotSet to JSON.
         * @function toJSON
         * @memberof api.PayloadIdentityPrincipalEmailNotSet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentityPrincipalEmailNotSet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentityPrincipalEmailNotSet;
    })();

    api.PayloadIdentityPrincipalEmailAlreadyExists = (function() {

        /**
         * Properties of a PayloadIdentityPrincipalEmailAlreadyExists.
         * @memberof api
         * @interface IPayloadIdentityPrincipalEmailAlreadyExists
         * @property {string|null} [login] PayloadIdentityPrincipalEmailAlreadyExists login
         * @property {string|null} [email] PayloadIdentityPrincipalEmailAlreadyExists email
         */

        /**
         * Constructs a new PayloadIdentityPrincipalEmailAlreadyExists.
         * @memberof api
         * @classdesc Represents a PayloadIdentityPrincipalEmailAlreadyExists.
         * @implements IPayloadIdentityPrincipalEmailAlreadyExists
         * @constructor
         * @param {api.IPayloadIdentityPrincipalEmailAlreadyExists=} [properties] Properties to set
         */
        function PayloadIdentityPrincipalEmailAlreadyExists(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentityPrincipalEmailAlreadyExists login.
         * @member {string} login
         * @memberof api.PayloadIdentityPrincipalEmailAlreadyExists
         * @instance
         */
        PayloadIdentityPrincipalEmailAlreadyExists.prototype.login = "";

        /**
         * PayloadIdentityPrincipalEmailAlreadyExists email.
         * @member {string} email
         * @memberof api.PayloadIdentityPrincipalEmailAlreadyExists
         * @instance
         */
        PayloadIdentityPrincipalEmailAlreadyExists.prototype.email = "";

        /**
         * Creates a new PayloadIdentityPrincipalEmailAlreadyExists instance using the specified properties.
         * @function create
         * @memberof api.PayloadIdentityPrincipalEmailAlreadyExists
         * @static
         * @param {api.IPayloadIdentityPrincipalEmailAlreadyExists=} [properties] Properties to set
         * @returns {api.PayloadIdentityPrincipalEmailAlreadyExists} PayloadIdentityPrincipalEmailAlreadyExists instance
         */
        PayloadIdentityPrincipalEmailAlreadyExists.create = function create(properties) {
            return new PayloadIdentityPrincipalEmailAlreadyExists(properties);
        };

        /**
         * Encodes the specified PayloadIdentityPrincipalEmailAlreadyExists message. Does not implicitly {@link api.PayloadIdentityPrincipalEmailAlreadyExists.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadIdentityPrincipalEmailAlreadyExists
         * @static
         * @param {api.IPayloadIdentityPrincipalEmailAlreadyExists} message PayloadIdentityPrincipalEmailAlreadyExists message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityPrincipalEmailAlreadyExists.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.email);
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentityPrincipalEmailAlreadyExists message, length delimited. Does not implicitly {@link api.PayloadIdentityPrincipalEmailAlreadyExists.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadIdentityPrincipalEmailAlreadyExists
         * @static
         * @param {api.IPayloadIdentityPrincipalEmailAlreadyExists} message PayloadIdentityPrincipalEmailAlreadyExists message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityPrincipalEmailAlreadyExists.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentityPrincipalEmailAlreadyExists message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadIdentityPrincipalEmailAlreadyExists
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadIdentityPrincipalEmailAlreadyExists} PayloadIdentityPrincipalEmailAlreadyExists
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityPrincipalEmailAlreadyExists.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadIdentityPrincipalEmailAlreadyExists();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.email = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentityPrincipalEmailAlreadyExists message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadIdentityPrincipalEmailAlreadyExists
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadIdentityPrincipalEmailAlreadyExists} PayloadIdentityPrincipalEmailAlreadyExists
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityPrincipalEmailAlreadyExists.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentityPrincipalEmailAlreadyExists message.
         * @function verify
         * @memberof api.PayloadIdentityPrincipalEmailAlreadyExists
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentityPrincipalEmailAlreadyExists.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            return null;
        };

        /**
         * Creates a PayloadIdentityPrincipalEmailAlreadyExists message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadIdentityPrincipalEmailAlreadyExists
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadIdentityPrincipalEmailAlreadyExists} PayloadIdentityPrincipalEmailAlreadyExists
         */
        PayloadIdentityPrincipalEmailAlreadyExists.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadIdentityPrincipalEmailAlreadyExists)
                return object;
            var message = new $root.api.PayloadIdentityPrincipalEmailAlreadyExists();
            if (object.login != null)
                message.login = String(object.login);
            if (object.email != null)
                message.email = String(object.email);
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentityPrincipalEmailAlreadyExists message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadIdentityPrincipalEmailAlreadyExists
         * @static
         * @param {api.PayloadIdentityPrincipalEmailAlreadyExists} message PayloadIdentityPrincipalEmailAlreadyExists
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentityPrincipalEmailAlreadyExists.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.email = "";
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            return object;
        };

        /**
         * Converts this PayloadIdentityPrincipalEmailAlreadyExists to JSON.
         * @function toJSON
         * @memberof api.PayloadIdentityPrincipalEmailAlreadyExists
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentityPrincipalEmailAlreadyExists.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentityPrincipalEmailAlreadyExists;
    })();

    api.PayloadResourceNotFound = (function() {

        /**
         * Properties of a PayloadResourceNotFound.
         * @memberof api
         * @interface IPayloadResourceNotFound
         * @property {number|Long|null} [id] PayloadResourceNotFound id
         */

        /**
         * Constructs a new PayloadResourceNotFound.
         * @memberof api
         * @classdesc Represents a PayloadResourceNotFound.
         * @implements IPayloadResourceNotFound
         * @constructor
         * @param {api.IPayloadResourceNotFound=} [properties] Properties to set
         */
        function PayloadResourceNotFound(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadResourceNotFound id.
         * @member {number|Long} id
         * @memberof api.PayloadResourceNotFound
         * @instance
         */
        PayloadResourceNotFound.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new PayloadResourceNotFound instance using the specified properties.
         * @function create
         * @memberof api.PayloadResourceNotFound
         * @static
         * @param {api.IPayloadResourceNotFound=} [properties] Properties to set
         * @returns {api.PayloadResourceNotFound} PayloadResourceNotFound instance
         */
        PayloadResourceNotFound.create = function create(properties) {
            return new PayloadResourceNotFound(properties);
        };

        /**
         * Encodes the specified PayloadResourceNotFound message. Does not implicitly {@link api.PayloadResourceNotFound.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadResourceNotFound
         * @static
         * @param {api.IPayloadResourceNotFound} message PayloadResourceNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadResourceNotFound.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            return writer;
        };

        /**
         * Encodes the specified PayloadResourceNotFound message, length delimited. Does not implicitly {@link api.PayloadResourceNotFound.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadResourceNotFound
         * @static
         * @param {api.IPayloadResourceNotFound} message PayloadResourceNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadResourceNotFound.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadResourceNotFound message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadResourceNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadResourceNotFound} PayloadResourceNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadResourceNotFound.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadResourceNotFound();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadResourceNotFound message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadResourceNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadResourceNotFound} PayloadResourceNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadResourceNotFound.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadResourceNotFound message.
         * @function verify
         * @memberof api.PayloadResourceNotFound
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadResourceNotFound.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            return null;
        };

        /**
         * Creates a PayloadResourceNotFound message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadResourceNotFound
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadResourceNotFound} PayloadResourceNotFound
         */
        PayloadResourceNotFound.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadResourceNotFound)
                return object;
            var message = new $root.api.PayloadResourceNotFound();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a PayloadResourceNotFound message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadResourceNotFound
         * @static
         * @param {api.PayloadResourceNotFound} message PayloadResourceNotFound
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadResourceNotFound.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            return object;
        };

        /**
         * Converts this PayloadResourceNotFound to JSON.
         * @function toJSON
         * @memberof api.PayloadResourceNotFound
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadResourceNotFound.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadResourceNotFound;
    })();

    api.PayloadRegisterInvalidEmail = (function() {

        /**
         * Properties of a PayloadRegisterInvalidEmail.
         * @memberof api
         * @interface IPayloadRegisterInvalidEmail
         * @property {string|null} [email] PayloadRegisterInvalidEmail email
         */

        /**
         * Constructs a new PayloadRegisterInvalidEmail.
         * @memberof api
         * @classdesc Represents a PayloadRegisterInvalidEmail.
         * @implements IPayloadRegisterInvalidEmail
         * @constructor
         * @param {api.IPayloadRegisterInvalidEmail=} [properties] Properties to set
         */
        function PayloadRegisterInvalidEmail(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadRegisterInvalidEmail email.
         * @member {string} email
         * @memberof api.PayloadRegisterInvalidEmail
         * @instance
         */
        PayloadRegisterInvalidEmail.prototype.email = "";

        /**
         * Creates a new PayloadRegisterInvalidEmail instance using the specified properties.
         * @function create
         * @memberof api.PayloadRegisterInvalidEmail
         * @static
         * @param {api.IPayloadRegisterInvalidEmail=} [properties] Properties to set
         * @returns {api.PayloadRegisterInvalidEmail} PayloadRegisterInvalidEmail instance
         */
        PayloadRegisterInvalidEmail.create = function create(properties) {
            return new PayloadRegisterInvalidEmail(properties);
        };

        /**
         * Encodes the specified PayloadRegisterInvalidEmail message. Does not implicitly {@link api.PayloadRegisterInvalidEmail.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadRegisterInvalidEmail
         * @static
         * @param {api.IPayloadRegisterInvalidEmail} message PayloadRegisterInvalidEmail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRegisterInvalidEmail.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.email);
            return writer;
        };

        /**
         * Encodes the specified PayloadRegisterInvalidEmail message, length delimited. Does not implicitly {@link api.PayloadRegisterInvalidEmail.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadRegisterInvalidEmail
         * @static
         * @param {api.IPayloadRegisterInvalidEmail} message PayloadRegisterInvalidEmail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRegisterInvalidEmail.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadRegisterInvalidEmail message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadRegisterInvalidEmail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadRegisterInvalidEmail} PayloadRegisterInvalidEmail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRegisterInvalidEmail.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadRegisterInvalidEmail();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadRegisterInvalidEmail message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadRegisterInvalidEmail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadRegisterInvalidEmail} PayloadRegisterInvalidEmail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRegisterInvalidEmail.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadRegisterInvalidEmail message.
         * @function verify
         * @memberof api.PayloadRegisterInvalidEmail
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadRegisterInvalidEmail.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            return null;
        };

        /**
         * Creates a PayloadRegisterInvalidEmail message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadRegisterInvalidEmail
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadRegisterInvalidEmail} PayloadRegisterInvalidEmail
         */
        PayloadRegisterInvalidEmail.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadRegisterInvalidEmail)
                return object;
            var message = new $root.api.PayloadRegisterInvalidEmail();
            if (object.email != null)
                message.email = String(object.email);
            return message;
        };

        /**
         * Creates a plain object from a PayloadRegisterInvalidEmail message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadRegisterInvalidEmail
         * @static
         * @param {api.PayloadRegisterInvalidEmail} message PayloadRegisterInvalidEmail
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadRegisterInvalidEmail.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.email = "";
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            return object;
        };

        /**
         * Converts this PayloadRegisterInvalidEmail to JSON.
         * @function toJSON
         * @memberof api.PayloadRegisterInvalidEmail
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadRegisterInvalidEmail.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadRegisterInvalidEmail;
    })();

    api.PayloadRegisterTokenNotFound = (function() {

        /**
         * Properties of a PayloadRegisterTokenNotFound.
         * @memberof api
         * @interface IPayloadRegisterTokenNotFound
         * @property {Uint8Array|null} [token] PayloadRegisterTokenNotFound token
         */

        /**
         * Constructs a new PayloadRegisterTokenNotFound.
         * @memberof api
         * @classdesc Represents a PayloadRegisterTokenNotFound.
         * @implements IPayloadRegisterTokenNotFound
         * @constructor
         * @param {api.IPayloadRegisterTokenNotFound=} [properties] Properties to set
         */
        function PayloadRegisterTokenNotFound(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadRegisterTokenNotFound token.
         * @member {Uint8Array} token
         * @memberof api.PayloadRegisterTokenNotFound
         * @instance
         */
        PayloadRegisterTokenNotFound.prototype.token = $util.newBuffer([]);

        /**
         * Creates a new PayloadRegisterTokenNotFound instance using the specified properties.
         * @function create
         * @memberof api.PayloadRegisterTokenNotFound
         * @static
         * @param {api.IPayloadRegisterTokenNotFound=} [properties] Properties to set
         * @returns {api.PayloadRegisterTokenNotFound} PayloadRegisterTokenNotFound instance
         */
        PayloadRegisterTokenNotFound.create = function create(properties) {
            return new PayloadRegisterTokenNotFound(properties);
        };

        /**
         * Encodes the specified PayloadRegisterTokenNotFound message. Does not implicitly {@link api.PayloadRegisterTokenNotFound.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadRegisterTokenNotFound
         * @static
         * @param {api.IPayloadRegisterTokenNotFound} message PayloadRegisterTokenNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRegisterTokenNotFound.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.token != null && message.hasOwnProperty("token"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.token);
            return writer;
        };

        /**
         * Encodes the specified PayloadRegisterTokenNotFound message, length delimited. Does not implicitly {@link api.PayloadRegisterTokenNotFound.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadRegisterTokenNotFound
         * @static
         * @param {api.IPayloadRegisterTokenNotFound} message PayloadRegisterTokenNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRegisterTokenNotFound.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadRegisterTokenNotFound message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadRegisterTokenNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadRegisterTokenNotFound} PayloadRegisterTokenNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRegisterTokenNotFound.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadRegisterTokenNotFound();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.token = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadRegisterTokenNotFound message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadRegisterTokenNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadRegisterTokenNotFound} PayloadRegisterTokenNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRegisterTokenNotFound.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadRegisterTokenNotFound message.
         * @function verify
         * @memberof api.PayloadRegisterTokenNotFound
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadRegisterTokenNotFound.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                    return "token: buffer expected";
            return null;
        };

        /**
         * Creates a PayloadRegisterTokenNotFound message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadRegisterTokenNotFound
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadRegisterTokenNotFound} PayloadRegisterTokenNotFound
         */
        PayloadRegisterTokenNotFound.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadRegisterTokenNotFound)
                return object;
            var message = new $root.api.PayloadRegisterTokenNotFound();
            if (object.token != null)
                if (typeof object.token === "string")
                    $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                else if (object.token.length)
                    message.token = object.token;
            return message;
        };

        /**
         * Creates a plain object from a PayloadRegisterTokenNotFound message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadRegisterTokenNotFound
         * @static
         * @param {api.PayloadRegisterTokenNotFound} message PayloadRegisterTokenNotFound
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadRegisterTokenNotFound.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.token = "";
                else {
                    object.token = [];
                    if (options.bytes !== Array)
                        object.token = $util.newBuffer(object.token);
                }
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
            return object;
        };

        /**
         * Converts this PayloadRegisterTokenNotFound to JSON.
         * @function toJSON
         * @memberof api.PayloadRegisterTokenNotFound
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadRegisterTokenNotFound.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadRegisterTokenNotFound;
    })();

    api.PayloadChannelNotFound = (function() {

        /**
         * Properties of a PayloadChannelNotFound.
         * @memberof api
         * @interface IPayloadChannelNotFound
         * @property {number|Long|null} [id] PayloadChannelNotFound id
         */

        /**
         * Constructs a new PayloadChannelNotFound.
         * @memberof api
         * @classdesc Represents a PayloadChannelNotFound.
         * @implements IPayloadChannelNotFound
         * @constructor
         * @param {api.IPayloadChannelNotFound=} [properties] Properties to set
         */
        function PayloadChannelNotFound(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadChannelNotFound id.
         * @member {number|Long} id
         * @memberof api.PayloadChannelNotFound
         * @instance
         */
        PayloadChannelNotFound.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new PayloadChannelNotFound instance using the specified properties.
         * @function create
         * @memberof api.PayloadChannelNotFound
         * @static
         * @param {api.IPayloadChannelNotFound=} [properties] Properties to set
         * @returns {api.PayloadChannelNotFound} PayloadChannelNotFound instance
         */
        PayloadChannelNotFound.create = function create(properties) {
            return new PayloadChannelNotFound(properties);
        };

        /**
         * Encodes the specified PayloadChannelNotFound message. Does not implicitly {@link api.PayloadChannelNotFound.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadChannelNotFound
         * @static
         * @param {api.IPayloadChannelNotFound} message PayloadChannelNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadChannelNotFound.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            return writer;
        };

        /**
         * Encodes the specified PayloadChannelNotFound message, length delimited. Does not implicitly {@link api.PayloadChannelNotFound.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadChannelNotFound
         * @static
         * @param {api.IPayloadChannelNotFound} message PayloadChannelNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadChannelNotFound.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadChannelNotFound message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadChannelNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadChannelNotFound} PayloadChannelNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadChannelNotFound.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadChannelNotFound();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadChannelNotFound message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadChannelNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadChannelNotFound} PayloadChannelNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadChannelNotFound.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadChannelNotFound message.
         * @function verify
         * @memberof api.PayloadChannelNotFound
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadChannelNotFound.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            return null;
        };

        /**
         * Creates a PayloadChannelNotFound message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadChannelNotFound
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadChannelNotFound} PayloadChannelNotFound
         */
        PayloadChannelNotFound.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadChannelNotFound)
                return object;
            var message = new $root.api.PayloadChannelNotFound();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a PayloadChannelNotFound message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadChannelNotFound
         * @static
         * @param {api.PayloadChannelNotFound} message PayloadChannelNotFound
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadChannelNotFound.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            return object;
        };

        /**
         * Converts this PayloadChannelNotFound to JSON.
         * @function toJSON
         * @memberof api.PayloadChannelNotFound
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadChannelNotFound.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadChannelNotFound;
    })();

    api.PayloadDelegatedAccessNotFound = (function() {

        /**
         * Properties of a PayloadDelegatedAccessNotFound.
         * @memberof api
         * @interface IPayloadDelegatedAccessNotFound
         * @property {number|Long|null} [id] PayloadDelegatedAccessNotFound id
         */

        /**
         * Constructs a new PayloadDelegatedAccessNotFound.
         * @memberof api
         * @classdesc Represents a PayloadDelegatedAccessNotFound.
         * @implements IPayloadDelegatedAccessNotFound
         * @constructor
         * @param {api.IPayloadDelegatedAccessNotFound=} [properties] Properties to set
         */
        function PayloadDelegatedAccessNotFound(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadDelegatedAccessNotFound id.
         * @member {number|Long} id
         * @memberof api.PayloadDelegatedAccessNotFound
         * @instance
         */
        PayloadDelegatedAccessNotFound.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new PayloadDelegatedAccessNotFound instance using the specified properties.
         * @function create
         * @memberof api.PayloadDelegatedAccessNotFound
         * @static
         * @param {api.IPayloadDelegatedAccessNotFound=} [properties] Properties to set
         * @returns {api.PayloadDelegatedAccessNotFound} PayloadDelegatedAccessNotFound instance
         */
        PayloadDelegatedAccessNotFound.create = function create(properties) {
            return new PayloadDelegatedAccessNotFound(properties);
        };

        /**
         * Encodes the specified PayloadDelegatedAccessNotFound message. Does not implicitly {@link api.PayloadDelegatedAccessNotFound.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadDelegatedAccessNotFound
         * @static
         * @param {api.IPayloadDelegatedAccessNotFound} message PayloadDelegatedAccessNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadDelegatedAccessNotFound.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            return writer;
        };

        /**
         * Encodes the specified PayloadDelegatedAccessNotFound message, length delimited. Does not implicitly {@link api.PayloadDelegatedAccessNotFound.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadDelegatedAccessNotFound
         * @static
         * @param {api.IPayloadDelegatedAccessNotFound} message PayloadDelegatedAccessNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadDelegatedAccessNotFound.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadDelegatedAccessNotFound message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadDelegatedAccessNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadDelegatedAccessNotFound} PayloadDelegatedAccessNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadDelegatedAccessNotFound.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadDelegatedAccessNotFound();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadDelegatedAccessNotFound message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadDelegatedAccessNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadDelegatedAccessNotFound} PayloadDelegatedAccessNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadDelegatedAccessNotFound.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadDelegatedAccessNotFound message.
         * @function verify
         * @memberof api.PayloadDelegatedAccessNotFound
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadDelegatedAccessNotFound.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            return null;
        };

        /**
         * Creates a PayloadDelegatedAccessNotFound message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadDelegatedAccessNotFound
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadDelegatedAccessNotFound} PayloadDelegatedAccessNotFound
         */
        PayloadDelegatedAccessNotFound.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadDelegatedAccessNotFound)
                return object;
            var message = new $root.api.PayloadDelegatedAccessNotFound();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a PayloadDelegatedAccessNotFound message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadDelegatedAccessNotFound
         * @static
         * @param {api.PayloadDelegatedAccessNotFound} message PayloadDelegatedAccessNotFound
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadDelegatedAccessNotFound.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            return object;
        };

        /**
         * Converts this PayloadDelegatedAccessNotFound to JSON.
         * @function toJSON
         * @memberof api.PayloadDelegatedAccessNotFound
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadDelegatedAccessNotFound.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadDelegatedAccessNotFound;
    })();

    api.PayloadInvalidToken = (function() {

        /**
         * Properties of a PayloadInvalidToken.
         * @memberof api
         * @interface IPayloadInvalidToken
         * @property {Uint8Array|null} [token] PayloadInvalidToken token
         */

        /**
         * Constructs a new PayloadInvalidToken.
         * @memberof api
         * @classdesc Represents a PayloadInvalidToken.
         * @implements IPayloadInvalidToken
         * @constructor
         * @param {api.IPayloadInvalidToken=} [properties] Properties to set
         */
        function PayloadInvalidToken(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadInvalidToken token.
         * @member {Uint8Array} token
         * @memberof api.PayloadInvalidToken
         * @instance
         */
        PayloadInvalidToken.prototype.token = $util.newBuffer([]);

        /**
         * Creates a new PayloadInvalidToken instance using the specified properties.
         * @function create
         * @memberof api.PayloadInvalidToken
         * @static
         * @param {api.IPayloadInvalidToken=} [properties] Properties to set
         * @returns {api.PayloadInvalidToken} PayloadInvalidToken instance
         */
        PayloadInvalidToken.create = function create(properties) {
            return new PayloadInvalidToken(properties);
        };

        /**
         * Encodes the specified PayloadInvalidToken message. Does not implicitly {@link api.PayloadInvalidToken.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadInvalidToken
         * @static
         * @param {api.IPayloadInvalidToken} message PayloadInvalidToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadInvalidToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.token != null && message.hasOwnProperty("token"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.token);
            return writer;
        };

        /**
         * Encodes the specified PayloadInvalidToken message, length delimited. Does not implicitly {@link api.PayloadInvalidToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadInvalidToken
         * @static
         * @param {api.IPayloadInvalidToken} message PayloadInvalidToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadInvalidToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadInvalidToken message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadInvalidToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadInvalidToken} PayloadInvalidToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadInvalidToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadInvalidToken();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.token = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadInvalidToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadInvalidToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadInvalidToken} PayloadInvalidToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadInvalidToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadInvalidToken message.
         * @function verify
         * @memberof api.PayloadInvalidToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadInvalidToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                    return "token: buffer expected";
            return null;
        };

        /**
         * Creates a PayloadInvalidToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadInvalidToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadInvalidToken} PayloadInvalidToken
         */
        PayloadInvalidToken.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadInvalidToken)
                return object;
            var message = new $root.api.PayloadInvalidToken();
            if (object.token != null)
                if (typeof object.token === "string")
                    $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                else if (object.token.length)
                    message.token = object.token;
            return message;
        };

        /**
         * Creates a plain object from a PayloadInvalidToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadInvalidToken
         * @static
         * @param {api.PayloadInvalidToken} message PayloadInvalidToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadInvalidToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.token = "";
                else {
                    object.token = [];
                    if (options.bytes !== Array)
                        object.token = $util.newBuffer(object.token);
                }
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
            return object;
        };

        /**
         * Converts this PayloadInvalidToken to JSON.
         * @function toJSON
         * @memberof api.PayloadInvalidToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadInvalidToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadInvalidToken;
    })();

    api.PayloadNamedResourceNotFound = (function() {

        /**
         * Properties of a PayloadNamedResourceNotFound.
         * @memberof api
         * @interface IPayloadNamedResourceNotFound
         * @property {string|null} [login] PayloadNamedResourceNotFound login
         * @property {string|null} [name] PayloadNamedResourceNotFound name
         */

        /**
         * Constructs a new PayloadNamedResourceNotFound.
         * @memberof api
         * @classdesc Represents a PayloadNamedResourceNotFound.
         * @implements IPayloadNamedResourceNotFound
         * @constructor
         * @param {api.IPayloadNamedResourceNotFound=} [properties] Properties to set
         */
        function PayloadNamedResourceNotFound(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadNamedResourceNotFound login.
         * @member {string} login
         * @memberof api.PayloadNamedResourceNotFound
         * @instance
         */
        PayloadNamedResourceNotFound.prototype.login = "";

        /**
         * PayloadNamedResourceNotFound name.
         * @member {string} name
         * @memberof api.PayloadNamedResourceNotFound
         * @instance
         */
        PayloadNamedResourceNotFound.prototype.name = "";

        /**
         * Creates a new PayloadNamedResourceNotFound instance using the specified properties.
         * @function create
         * @memberof api.PayloadNamedResourceNotFound
         * @static
         * @param {api.IPayloadNamedResourceNotFound=} [properties] Properties to set
         * @returns {api.PayloadNamedResourceNotFound} PayloadNamedResourceNotFound instance
         */
        PayloadNamedResourceNotFound.create = function create(properties) {
            return new PayloadNamedResourceNotFound(properties);
        };

        /**
         * Encodes the specified PayloadNamedResourceNotFound message. Does not implicitly {@link api.PayloadNamedResourceNotFound.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadNamedResourceNotFound
         * @static
         * @param {api.IPayloadNamedResourceNotFound} message PayloadNamedResourceNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadNamedResourceNotFound.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified PayloadNamedResourceNotFound message, length delimited. Does not implicitly {@link api.PayloadNamedResourceNotFound.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadNamedResourceNotFound
         * @static
         * @param {api.IPayloadNamedResourceNotFound} message PayloadNamedResourceNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadNamedResourceNotFound.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadNamedResourceNotFound message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadNamedResourceNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadNamedResourceNotFound} PayloadNamedResourceNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadNamedResourceNotFound.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadNamedResourceNotFound();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadNamedResourceNotFound message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadNamedResourceNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadNamedResourceNotFound} PayloadNamedResourceNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadNamedResourceNotFound.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadNamedResourceNotFound message.
         * @function verify
         * @memberof api.PayloadNamedResourceNotFound
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadNamedResourceNotFound.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a PayloadNamedResourceNotFound message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadNamedResourceNotFound
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadNamedResourceNotFound} PayloadNamedResourceNotFound
         */
        PayloadNamedResourceNotFound.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadNamedResourceNotFound)
                return object;
            var message = new $root.api.PayloadNamedResourceNotFound();
            if (object.login != null)
                message.login = String(object.login);
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a PayloadNamedResourceNotFound message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadNamedResourceNotFound
         * @static
         * @param {api.PayloadNamedResourceNotFound} message PayloadNamedResourceNotFound
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadNamedResourceNotFound.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.name = "";
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this PayloadNamedResourceNotFound to JSON.
         * @function toJSON
         * @memberof api.PayloadNamedResourceNotFound
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadNamedResourceNotFound.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadNamedResourceNotFound;
    })();

    api.PayloadApplicationConfigInvalid = (function() {

        /**
         * Properties of a PayloadApplicationConfigInvalid.
         * @memberof api
         * @interface IPayloadApplicationConfigInvalid
         * @property {string|null} [hint] PayloadApplicationConfigInvalid hint
         */

        /**
         * Constructs a new PayloadApplicationConfigInvalid.
         * @memberof api
         * @classdesc Represents a PayloadApplicationConfigInvalid.
         * @implements IPayloadApplicationConfigInvalid
         * @constructor
         * @param {api.IPayloadApplicationConfigInvalid=} [properties] Properties to set
         */
        function PayloadApplicationConfigInvalid(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadApplicationConfigInvalid hint.
         * @member {string} hint
         * @memberof api.PayloadApplicationConfigInvalid
         * @instance
         */
        PayloadApplicationConfigInvalid.prototype.hint = "";

        /**
         * Creates a new PayloadApplicationConfigInvalid instance using the specified properties.
         * @function create
         * @memberof api.PayloadApplicationConfigInvalid
         * @static
         * @param {api.IPayloadApplicationConfigInvalid=} [properties] Properties to set
         * @returns {api.PayloadApplicationConfigInvalid} PayloadApplicationConfigInvalid instance
         */
        PayloadApplicationConfigInvalid.create = function create(properties) {
            return new PayloadApplicationConfigInvalid(properties);
        };

        /**
         * Encodes the specified PayloadApplicationConfigInvalid message. Does not implicitly {@link api.PayloadApplicationConfigInvalid.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadApplicationConfigInvalid
         * @static
         * @param {api.IPayloadApplicationConfigInvalid} message PayloadApplicationConfigInvalid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadApplicationConfigInvalid.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hint != null && message.hasOwnProperty("hint"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.hint);
            return writer;
        };

        /**
         * Encodes the specified PayloadApplicationConfigInvalid message, length delimited. Does not implicitly {@link api.PayloadApplicationConfigInvalid.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadApplicationConfigInvalid
         * @static
         * @param {api.IPayloadApplicationConfigInvalid} message PayloadApplicationConfigInvalid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadApplicationConfigInvalid.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadApplicationConfigInvalid message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadApplicationConfigInvalid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadApplicationConfigInvalid} PayloadApplicationConfigInvalid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadApplicationConfigInvalid.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadApplicationConfigInvalid();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hint = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadApplicationConfigInvalid message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadApplicationConfigInvalid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadApplicationConfigInvalid} PayloadApplicationConfigInvalid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadApplicationConfigInvalid.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadApplicationConfigInvalid message.
         * @function verify
         * @memberof api.PayloadApplicationConfigInvalid
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadApplicationConfigInvalid.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hint != null && message.hasOwnProperty("hint"))
                if (!$util.isString(message.hint))
                    return "hint: string expected";
            return null;
        };

        /**
         * Creates a PayloadApplicationConfigInvalid message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadApplicationConfigInvalid
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadApplicationConfigInvalid} PayloadApplicationConfigInvalid
         */
        PayloadApplicationConfigInvalid.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadApplicationConfigInvalid)
                return object;
            var message = new $root.api.PayloadApplicationConfigInvalid();
            if (object.hint != null)
                message.hint = String(object.hint);
            return message;
        };

        /**
         * Creates a plain object from a PayloadApplicationConfigInvalid message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadApplicationConfigInvalid
         * @static
         * @param {api.PayloadApplicationConfigInvalid} message PayloadApplicationConfigInvalid
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadApplicationConfigInvalid.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.hint = "";
            if (message.hint != null && message.hasOwnProperty("hint"))
                object.hint = message.hint;
            return object;
        };

        /**
         * Converts this PayloadApplicationConfigInvalid to JSON.
         * @function toJSON
         * @memberof api.PayloadApplicationConfigInvalid
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadApplicationConfigInvalid.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadApplicationConfigInvalid;
    })();

    api.PayloadApplicationConfigNotFound = (function() {

        /**
         * Properties of a PayloadApplicationConfigNotFound.
         * @memberof api
         * @interface IPayloadApplicationConfigNotFound
         * @property {string|null} [login] PayloadApplicationConfigNotFound login
         */

        /**
         * Constructs a new PayloadApplicationConfigNotFound.
         * @memberof api
         * @classdesc Represents a PayloadApplicationConfigNotFound.
         * @implements IPayloadApplicationConfigNotFound
         * @constructor
         * @param {api.IPayloadApplicationConfigNotFound=} [properties] Properties to set
         */
        function PayloadApplicationConfigNotFound(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadApplicationConfigNotFound login.
         * @member {string} login
         * @memberof api.PayloadApplicationConfigNotFound
         * @instance
         */
        PayloadApplicationConfigNotFound.prototype.login = "";

        /**
         * Creates a new PayloadApplicationConfigNotFound instance using the specified properties.
         * @function create
         * @memberof api.PayloadApplicationConfigNotFound
         * @static
         * @param {api.IPayloadApplicationConfigNotFound=} [properties] Properties to set
         * @returns {api.PayloadApplicationConfigNotFound} PayloadApplicationConfigNotFound instance
         */
        PayloadApplicationConfigNotFound.create = function create(properties) {
            return new PayloadApplicationConfigNotFound(properties);
        };

        /**
         * Encodes the specified PayloadApplicationConfigNotFound message. Does not implicitly {@link api.PayloadApplicationConfigNotFound.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadApplicationConfigNotFound
         * @static
         * @param {api.IPayloadApplicationConfigNotFound} message PayloadApplicationConfigNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadApplicationConfigNotFound.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            return writer;
        };

        /**
         * Encodes the specified PayloadApplicationConfigNotFound message, length delimited. Does not implicitly {@link api.PayloadApplicationConfigNotFound.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadApplicationConfigNotFound
         * @static
         * @param {api.IPayloadApplicationConfigNotFound} message PayloadApplicationConfigNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadApplicationConfigNotFound.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadApplicationConfigNotFound message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadApplicationConfigNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadApplicationConfigNotFound} PayloadApplicationConfigNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadApplicationConfigNotFound.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadApplicationConfigNotFound();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadApplicationConfigNotFound message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadApplicationConfigNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadApplicationConfigNotFound} PayloadApplicationConfigNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadApplicationConfigNotFound.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadApplicationConfigNotFound message.
         * @function verify
         * @memberof api.PayloadApplicationConfigNotFound
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadApplicationConfigNotFound.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            return null;
        };

        /**
         * Creates a PayloadApplicationConfigNotFound message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadApplicationConfigNotFound
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadApplicationConfigNotFound} PayloadApplicationConfigNotFound
         */
        PayloadApplicationConfigNotFound.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadApplicationConfigNotFound)
                return object;
            var message = new $root.api.PayloadApplicationConfigNotFound();
            if (object.login != null)
                message.login = String(object.login);
            return message;
        };

        /**
         * Creates a plain object from a PayloadApplicationConfigNotFound message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadApplicationConfigNotFound
         * @static
         * @param {api.PayloadApplicationConfigNotFound} message PayloadApplicationConfigNotFound
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadApplicationConfigNotFound.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.login = "";
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            return object;
        };

        /**
         * Converts this PayloadApplicationConfigNotFound to JSON.
         * @function toJSON
         * @memberof api.PayloadApplicationConfigNotFound
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadApplicationConfigNotFound.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadApplicationConfigNotFound;
    })();

    api.PayloadApplicationInvalidToken = (function() {

        /**
         * Properties of a PayloadApplicationInvalidToken.
         * @memberof api
         * @interface IPayloadApplicationInvalidToken
         * @property {string|null} [token] PayloadApplicationInvalidToken token
         * @property {string|null} [hint] PayloadApplicationInvalidToken hint
         */

        /**
         * Constructs a new PayloadApplicationInvalidToken.
         * @memberof api
         * @classdesc Represents a PayloadApplicationInvalidToken.
         * @implements IPayloadApplicationInvalidToken
         * @constructor
         * @param {api.IPayloadApplicationInvalidToken=} [properties] Properties to set
         */
        function PayloadApplicationInvalidToken(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadApplicationInvalidToken token.
         * @member {string} token
         * @memberof api.PayloadApplicationInvalidToken
         * @instance
         */
        PayloadApplicationInvalidToken.prototype.token = "";

        /**
         * PayloadApplicationInvalidToken hint.
         * @member {string} hint
         * @memberof api.PayloadApplicationInvalidToken
         * @instance
         */
        PayloadApplicationInvalidToken.prototype.hint = "";

        /**
         * Creates a new PayloadApplicationInvalidToken instance using the specified properties.
         * @function create
         * @memberof api.PayloadApplicationInvalidToken
         * @static
         * @param {api.IPayloadApplicationInvalidToken=} [properties] Properties to set
         * @returns {api.PayloadApplicationInvalidToken} PayloadApplicationInvalidToken instance
         */
        PayloadApplicationInvalidToken.create = function create(properties) {
            return new PayloadApplicationInvalidToken(properties);
        };

        /**
         * Encodes the specified PayloadApplicationInvalidToken message. Does not implicitly {@link api.PayloadApplicationInvalidToken.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadApplicationInvalidToken
         * @static
         * @param {api.IPayloadApplicationInvalidToken} message PayloadApplicationInvalidToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadApplicationInvalidToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.token != null && message.hasOwnProperty("token"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.token);
            if (message.hint != null && message.hasOwnProperty("hint"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.hint);
            return writer;
        };

        /**
         * Encodes the specified PayloadApplicationInvalidToken message, length delimited. Does not implicitly {@link api.PayloadApplicationInvalidToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadApplicationInvalidToken
         * @static
         * @param {api.IPayloadApplicationInvalidToken} message PayloadApplicationInvalidToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadApplicationInvalidToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadApplicationInvalidToken message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadApplicationInvalidToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadApplicationInvalidToken} PayloadApplicationInvalidToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadApplicationInvalidToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadApplicationInvalidToken();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.token = reader.string();
                    break;
                case 2:
                    message.hint = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadApplicationInvalidToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadApplicationInvalidToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadApplicationInvalidToken} PayloadApplicationInvalidToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadApplicationInvalidToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadApplicationInvalidToken message.
         * @function verify
         * @memberof api.PayloadApplicationInvalidToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadApplicationInvalidToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!$util.isString(message.token))
                    return "token: string expected";
            if (message.hint != null && message.hasOwnProperty("hint"))
                if (!$util.isString(message.hint))
                    return "hint: string expected";
            return null;
        };

        /**
         * Creates a PayloadApplicationInvalidToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadApplicationInvalidToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadApplicationInvalidToken} PayloadApplicationInvalidToken
         */
        PayloadApplicationInvalidToken.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadApplicationInvalidToken)
                return object;
            var message = new $root.api.PayloadApplicationInvalidToken();
            if (object.token != null)
                message.token = String(object.token);
            if (object.hint != null)
                message.hint = String(object.hint);
            return message;
        };

        /**
         * Creates a plain object from a PayloadApplicationInvalidToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadApplicationInvalidToken
         * @static
         * @param {api.PayloadApplicationInvalidToken} message PayloadApplicationInvalidToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadApplicationInvalidToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.token = "";
                object.hint = "";
            }
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = message.token;
            if (message.hint != null && message.hasOwnProperty("hint"))
                object.hint = message.hint;
            return object;
        };

        /**
         * Converts this PayloadApplicationInvalidToken to JSON.
         * @function toJSON
         * @memberof api.PayloadApplicationInvalidToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadApplicationInvalidToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadApplicationInvalidToken;
    })();

    return api;
})();

$root.google = (function() {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    var google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        var protobuf = {};

        protobuf.Any = (function() {

            /**
             * Properties of an Any.
             * @memberof google.protobuf
             * @interface IAny
             * @property {string|null} [type_url] Any type_url
             * @property {Uint8Array|null} [value] Any value
             */

            /**
             * Constructs a new Any.
             * @memberof google.protobuf
             * @classdesc Represents an Any.
             * @implements IAny
             * @constructor
             * @param {google.protobuf.IAny=} [properties] Properties to set
             */
            function Any(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Any type_url.
             * @member {string} type_url
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.type_url = "";

            /**
             * Any value.
             * @member {Uint8Array} value
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new Any instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny=} [properties] Properties to set
             * @returns {google.protobuf.Any} Any instance
             */
            Any.create = function create(properties) {
                return new Any(properties);
            };

            /**
             * Encodes the specified Any message. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.type_url);
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified Any message, length delimited. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Any message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Any();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type_url = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Any message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Any message.
             * @function verify
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Any.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    if (!$util.isString(message.type_url))
                        return "type_url: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates an Any message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Any} Any
             */
            Any.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Any)
                    return object;
                var message = new $root.google.protobuf.Any();
                if (object.type_url != null)
                    message.type_url = String(object.type_url);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from an Any message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.Any} message Any
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Any.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type_url = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    object.type_url = message.type_url;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this Any to JSON.
             * @function toJSON
             * @memberof google.protobuf.Any
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Any.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Any;
        })();

        return protobuf;
    })();

    return google;
})();

module.exports = $root;
